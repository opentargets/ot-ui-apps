yarn run v1.22.22
$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty
{
  "summary": {
    "changed": 0,
    "unchanged": 863,
    "matches": 0,
    "duration": { "secs": 0, "nanos": 134795917 },
    "errors": 380,
    "warnings": 0,
    "skipped": 0,
    "suggestedFixesSkipped": 0,
    "diagnosticsNotPrinted": 0
  },
  "diagnostics": [
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/associationsUtils/associations.js"
        },
        "span": [1611, 1656],
        "sourceCode": "import { v1 } from \"uuid\";\nimport { ENTITIES } from \"./index\";\n\nconst getEmptyRow = (id) => ({\n  dataSources: {},\n  prioritisations: {},\n  score: 0,\n  disease: { id },\n  target: { id },\n});\n\n/***********\n * HELPERS *\n ***********/\n\n/**\n * Extracts and returns associated target rows from the disease data.\n * @param {Object} data - The data object containing disease associations.\n * @returns {Array} Associated target rows.\n */\nexport const diseaseAssociationsTargetSelector = (data) =>\n  data[ENTITIES.DISEASE].associatedTargets.rows;\n\n/**\n * Extracts and returns associated disease rows from the target data.\n * @param {Object} data - The data object containing target associations.\n * @returns {Array} Associated disease rows.\n */\nexport const targetAssociationsDiseaseSelector = (data) =>\n  data[ENTITIES.TARGET].associatedDiseases.rows;\n\n/**\n * Extracts and returns prioritisation items from the target data for disease prioritisation.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Array} Prioritisation items.\n */\nexport const diseasePrioritisationTargetsSelector = (data) =>\n  data[ENTITIES.TARGET].prioritisation.items;\n\n/**\n * Processes the prioritisation data and converts it into a key-value pair object.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Object} Key-value pair object with prioritisation keys and their respective scores.\n */\nexport const getPrioritisationData = (data) => {\n  const dataRows = diseasePrioritisationTargetsSelector(data);\n  const prioritisations = dataRows.reduce(\n    (acc, curr) => ((acc[curr.key] = Number.parseFloat(curr.value)), acc),\n    {}\n  );\n  return { prioritisations };\n};\n\n/**\n * Processes data source scores and converts them into a key-value pair object.\n * @param {Object} data - The data object containing data source scores.\n * @returns {Object} Key-value pair object with component IDs and their respective scores.\n */\nexport const getDataSourcesData = (data) => {\n  const sources = data.datasourceScores.reduce(\n    (acc, curr) => ((acc[curr.componentId] = curr.score), acc),\n    {}\n  );\n  return sources;\n};\n\n/**\n * Retrieves metadata for a given row based on the fixed entity type.\n * @param {Object} parentEntity - The parent entity object.\n * @param {Object} row - The current row object.\n * @param {string} fixedEntity - The fixed entity type.\n * @returns {Object} Metadata object containing target symbol, disease name, and ID.\n */\nexport const getDataRowMetadata = (parentEntity, row, fixedEntity) => {\n  let targetSymbol;\n  let diseaseName;\n  let id;\n  switch (fixedEntity) {\n    case ENTITIES.DISEASE:\n      id = row.target.id;\n      targetSymbol = row.target.approvedSymbol;\n      diseaseName = parentEntity.disease.name;\n      break;\n    case ENTITIES.TARGET:\n      id = row.disease.id;\n      targetSymbol = parentEntity.target.approvedSymbol;\n      diseaseName = row.disease.name;\n      break;\n    default:\n      return { targetSymbol, diseaseName };\n  }\n  return { targetSymbol, diseaseName, id };\n};\n\n/**\n * Returns the total count of associated diseases or targets based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing associations count.\n * @returns {number} The total count of associated diseases or targets.\n */\nexport const getAllDataCount = (fixedEntity, data) => {\n  switch (fixedEntity) {\n    case ENTITIES.TARGET:\n      return data[ENTITIES.TARGET].associatedDiseases.count;\n    case ENTITIES.DISEASE:\n      return data[ENTITIES.DISEASE].associatedTargets.count;\n    default:\n      return 0;\n  }\n};\n\n/**\n * Aggregates and formats association data based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing association data.\n * @returns {Array} Formatted association data.\n */\nexport const getAssociationsData = (fixedEntity, data) => {\n  if (!data) return [];\n  const withPrioritisation = fixedEntity === ENTITIES.DISEASE;\n  const dataRows =\n    fixedEntity === ENTITIES.DISEASE\n      ? diseaseAssociationsTargetSelector(data)\n      : targetAssociationsDiseaseSelector(data);\n\n  return dataRows.map((row) => {\n    const dataSources = getDataSourcesData(row);\n    const { targetSymbol, diseaseName, id } = getDataRowMetadata(data, row, fixedEntity);\n    return {\n      score: row.score,\n      id,\n      targetSymbol,\n      diseaseName,\n      dataSources,\n      ...(!withPrioritisation && { disease: row.disease }),\n      ...(withPrioritisation && { target: row.target }),\n      ...(withPrioritisation && getPrioritisationData(row)),\n    };\n  });\n};\n\n/**\n * Generates an array of empty rows for initial loading.\n * @param {number} [rowCount=10] - The number of empty rows to generate.\n * @returns {Array} Array of empty rows.\n */\nexport const getInitialLoadingData = (rowCount = 10) => {\n  const arr = [];\n  for (let i = 0; i < rowCount; i++) {\n    arr.push(getEmptyRow(v1()));\n  }\n  return arr;\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/style/noCommaOperator",
      "severity": "error",
      "description": "The comma operator is disallowed.",
      "message": [{ "elements": [], "content": "The comma operator is disallowed." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Its use is often confusing and obscures side effects."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/associationsUtils/associations.js"
        },
        "span": [1657, 1658],
        "sourceCode": "import { v1 } from \"uuid\";\nimport { ENTITIES } from \"./index\";\n\nconst getEmptyRow = (id) => ({\n  dataSources: {},\n  prioritisations: {},\n  score: 0,\n  disease: { id },\n  target: { id },\n});\n\n/***********\n * HELPERS *\n ***********/\n\n/**\n * Extracts and returns associated target rows from the disease data.\n * @param {Object} data - The data object containing disease associations.\n * @returns {Array} Associated target rows.\n */\nexport const diseaseAssociationsTargetSelector = (data) =>\n  data[ENTITIES.DISEASE].associatedTargets.rows;\n\n/**\n * Extracts and returns associated disease rows from the target data.\n * @param {Object} data - The data object containing target associations.\n * @returns {Array} Associated disease rows.\n */\nexport const targetAssociationsDiseaseSelector = (data) =>\n  data[ENTITIES.TARGET].associatedDiseases.rows;\n\n/**\n * Extracts and returns prioritisation items from the target data for disease prioritisation.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Array} Prioritisation items.\n */\nexport const diseasePrioritisationTargetsSelector = (data) =>\n  data[ENTITIES.TARGET].prioritisation.items;\n\n/**\n * Processes the prioritisation data and converts it into a key-value pair object.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Object} Key-value pair object with prioritisation keys and their respective scores.\n */\nexport const getPrioritisationData = (data) => {\n  const dataRows = diseasePrioritisationTargetsSelector(data);\n  const prioritisations = dataRows.reduce(\n    (acc, curr) => ((acc[curr.key] = Number.parseFloat(curr.value)), acc),\n    {}\n  );\n  return { prioritisations };\n};\n\n/**\n * Processes data source scores and converts them into a key-value pair object.\n * @param {Object} data - The data object containing data source scores.\n * @returns {Object} Key-value pair object with component IDs and their respective scores.\n */\nexport const getDataSourcesData = (data) => {\n  const sources = data.datasourceScores.reduce(\n    (acc, curr) => ((acc[curr.componentId] = curr.score), acc),\n    {}\n  );\n  return sources;\n};\n\n/**\n * Retrieves metadata for a given row based on the fixed entity type.\n * @param {Object} parentEntity - The parent entity object.\n * @param {Object} row - The current row object.\n * @param {string} fixedEntity - The fixed entity type.\n * @returns {Object} Metadata object containing target symbol, disease name, and ID.\n */\nexport const getDataRowMetadata = (parentEntity, row, fixedEntity) => {\n  let targetSymbol;\n  let diseaseName;\n  let id;\n  switch (fixedEntity) {\n    case ENTITIES.DISEASE:\n      id = row.target.id;\n      targetSymbol = row.target.approvedSymbol;\n      diseaseName = parentEntity.disease.name;\n      break;\n    case ENTITIES.TARGET:\n      id = row.disease.id;\n      targetSymbol = parentEntity.target.approvedSymbol;\n      diseaseName = row.disease.name;\n      break;\n    default:\n      return { targetSymbol, diseaseName };\n  }\n  return { targetSymbol, diseaseName, id };\n};\n\n/**\n * Returns the total count of associated diseases or targets based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing associations count.\n * @returns {number} The total count of associated diseases or targets.\n */\nexport const getAllDataCount = (fixedEntity, data) => {\n  switch (fixedEntity) {\n    case ENTITIES.TARGET:\n      return data[ENTITIES.TARGET].associatedDiseases.count;\n    case ENTITIES.DISEASE:\n      return data[ENTITIES.DISEASE].associatedTargets.count;\n    default:\n      return 0;\n  }\n};\n\n/**\n * Aggregates and formats association data based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing association data.\n * @returns {Array} Formatted association data.\n */\nexport const getAssociationsData = (fixedEntity, data) => {\n  if (!data) return [];\n  const withPrioritisation = fixedEntity === ENTITIES.DISEASE;\n  const dataRows =\n    fixedEntity === ENTITIES.DISEASE\n      ? diseaseAssociationsTargetSelector(data)\n      : targetAssociationsDiseaseSelector(data);\n\n  return dataRows.map((row) => {\n    const dataSources = getDataSourcesData(row);\n    const { targetSymbol, diseaseName, id } = getDataRowMetadata(data, row, fixedEntity);\n    return {\n      score: row.score,\n      id,\n      targetSymbol,\n      diseaseName,\n      dataSources,\n      ...(!withPrioritisation && { disease: row.disease }),\n      ...(withPrioritisation && { target: row.target }),\n      ...(withPrioritisation && getPrioritisationData(row)),\n    };\n  });\n};\n\n/**\n * Generates an array of empty rows for initial loading.\n * @param {number} [rowCount=10] - The number of empty rows to generate.\n * @returns {Array} Array of empty rows.\n */\nexport const getInitialLoadingData = (rowCount = 10) => {\n  const arr = [];\n  for (let i = 0; i < rowCount; i++) {\n    arr.push(getEmptyRow(v1()));\n  }\n  return arr;\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/associationsUtils/associations.js"
        },
        "span": [2078, 2112],
        "sourceCode": "import { v1 } from \"uuid\";\nimport { ENTITIES } from \"./index\";\n\nconst getEmptyRow = (id) => ({\n  dataSources: {},\n  prioritisations: {},\n  score: 0,\n  disease: { id },\n  target: { id },\n});\n\n/***********\n * HELPERS *\n ***********/\n\n/**\n * Extracts and returns associated target rows from the disease data.\n * @param {Object} data - The data object containing disease associations.\n * @returns {Array} Associated target rows.\n */\nexport const diseaseAssociationsTargetSelector = (data) =>\n  data[ENTITIES.DISEASE].associatedTargets.rows;\n\n/**\n * Extracts and returns associated disease rows from the target data.\n * @param {Object} data - The data object containing target associations.\n * @returns {Array} Associated disease rows.\n */\nexport const targetAssociationsDiseaseSelector = (data) =>\n  data[ENTITIES.TARGET].associatedDiseases.rows;\n\n/**\n * Extracts and returns prioritisation items from the target data for disease prioritisation.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Array} Prioritisation items.\n */\nexport const diseasePrioritisationTargetsSelector = (data) =>\n  data[ENTITIES.TARGET].prioritisation.items;\n\n/**\n * Processes the prioritisation data and converts it into a key-value pair object.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Object} Key-value pair object with prioritisation keys and their respective scores.\n */\nexport const getPrioritisationData = (data) => {\n  const dataRows = diseasePrioritisationTargetsSelector(data);\n  const prioritisations = dataRows.reduce(\n    (acc, curr) => ((acc[curr.key] = Number.parseFloat(curr.value)), acc),\n    {}\n  );\n  return { prioritisations };\n};\n\n/**\n * Processes data source scores and converts them into a key-value pair object.\n * @param {Object} data - The data object containing data source scores.\n * @returns {Object} Key-value pair object with component IDs and their respective scores.\n */\nexport const getDataSourcesData = (data) => {\n  const sources = data.datasourceScores.reduce(\n    (acc, curr) => ((acc[curr.componentId] = curr.score), acc),\n    {}\n  );\n  return sources;\n};\n\n/**\n * Retrieves metadata for a given row based on the fixed entity type.\n * @param {Object} parentEntity - The parent entity object.\n * @param {Object} row - The current row object.\n * @param {string} fixedEntity - The fixed entity type.\n * @returns {Object} Metadata object containing target symbol, disease name, and ID.\n */\nexport const getDataRowMetadata = (parentEntity, row, fixedEntity) => {\n  let targetSymbol;\n  let diseaseName;\n  let id;\n  switch (fixedEntity) {\n    case ENTITIES.DISEASE:\n      id = row.target.id;\n      targetSymbol = row.target.approvedSymbol;\n      diseaseName = parentEntity.disease.name;\n      break;\n    case ENTITIES.TARGET:\n      id = row.disease.id;\n      targetSymbol = parentEntity.target.approvedSymbol;\n      diseaseName = row.disease.name;\n      break;\n    default:\n      return { targetSymbol, diseaseName };\n  }\n  return { targetSymbol, diseaseName, id };\n};\n\n/**\n * Returns the total count of associated diseases or targets based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing associations count.\n * @returns {number} The total count of associated diseases or targets.\n */\nexport const getAllDataCount = (fixedEntity, data) => {\n  switch (fixedEntity) {\n    case ENTITIES.TARGET:\n      return data[ENTITIES.TARGET].associatedDiseases.count;\n    case ENTITIES.DISEASE:\n      return data[ENTITIES.DISEASE].associatedTargets.count;\n    default:\n      return 0;\n  }\n};\n\n/**\n * Aggregates and formats association data based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing association data.\n * @returns {Array} Formatted association data.\n */\nexport const getAssociationsData = (fixedEntity, data) => {\n  if (!data) return [];\n  const withPrioritisation = fixedEntity === ENTITIES.DISEASE;\n  const dataRows =\n    fixedEntity === ENTITIES.DISEASE\n      ? diseaseAssociationsTargetSelector(data)\n      : targetAssociationsDiseaseSelector(data);\n\n  return dataRows.map((row) => {\n    const dataSources = getDataSourcesData(row);\n    const { targetSymbol, diseaseName, id } = getDataRowMetadata(data, row, fixedEntity);\n    return {\n      score: row.score,\n      id,\n      targetSymbol,\n      diseaseName,\n      dataSources,\n      ...(!withPrioritisation && { disease: row.disease }),\n      ...(withPrioritisation && { target: row.target }),\n      ...(withPrioritisation && getPrioritisationData(row)),\n    };\n  });\n};\n\n/**\n * Generates an array of empty rows for initial loading.\n * @param {number} [rowCount=10] - The number of empty rows to generate.\n * @returns {Array} Array of empty rows.\n */\nexport const getInitialLoadingData = (rowCount = 10) => {\n  const arr = [];\n  for (let i = 0; i < rowCount; i++) {\n    arr.push(getEmptyRow(v1()));\n  }\n  return arr;\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/style/noCommaOperator",
      "severity": "error",
      "description": "The comma operator is disallowed.",
      "message": [{ "elements": [], "content": "The comma operator is disallowed." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Its use is often confusing and obscures side effects."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/associationsUtils/associations.js"
        },
        "span": [2113, 2114],
        "sourceCode": "import { v1 } from \"uuid\";\nimport { ENTITIES } from \"./index\";\n\nconst getEmptyRow = (id) => ({\n  dataSources: {},\n  prioritisations: {},\n  score: 0,\n  disease: { id },\n  target: { id },\n});\n\n/***********\n * HELPERS *\n ***********/\n\n/**\n * Extracts and returns associated target rows from the disease data.\n * @param {Object} data - The data object containing disease associations.\n * @returns {Array} Associated target rows.\n */\nexport const diseaseAssociationsTargetSelector = (data) =>\n  data[ENTITIES.DISEASE].associatedTargets.rows;\n\n/**\n * Extracts and returns associated disease rows from the target data.\n * @param {Object} data - The data object containing target associations.\n * @returns {Array} Associated disease rows.\n */\nexport const targetAssociationsDiseaseSelector = (data) =>\n  data[ENTITIES.TARGET].associatedDiseases.rows;\n\n/**\n * Extracts and returns prioritisation items from the target data for disease prioritisation.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Array} Prioritisation items.\n */\nexport const diseasePrioritisationTargetsSelector = (data) =>\n  data[ENTITIES.TARGET].prioritisation.items;\n\n/**\n * Processes the prioritisation data and converts it into a key-value pair object.\n * @param {Object} data - The data object containing prioritisation items.\n * @returns {Object} Key-value pair object with prioritisation keys and their respective scores.\n */\nexport const getPrioritisationData = (data) => {\n  const dataRows = diseasePrioritisationTargetsSelector(data);\n  const prioritisations = dataRows.reduce(\n    (acc, curr) => ((acc[curr.key] = Number.parseFloat(curr.value)), acc),\n    {}\n  );\n  return { prioritisations };\n};\n\n/**\n * Processes data source scores and converts them into a key-value pair object.\n * @param {Object} data - The data object containing data source scores.\n * @returns {Object} Key-value pair object with component IDs and their respective scores.\n */\nexport const getDataSourcesData = (data) => {\n  const sources = data.datasourceScores.reduce(\n    (acc, curr) => ((acc[curr.componentId] = curr.score), acc),\n    {}\n  );\n  return sources;\n};\n\n/**\n * Retrieves metadata for a given row based on the fixed entity type.\n * @param {Object} parentEntity - The parent entity object.\n * @param {Object} row - The current row object.\n * @param {string} fixedEntity - The fixed entity type.\n * @returns {Object} Metadata object containing target symbol, disease name, and ID.\n */\nexport const getDataRowMetadata = (parentEntity, row, fixedEntity) => {\n  let targetSymbol;\n  let diseaseName;\n  let id;\n  switch (fixedEntity) {\n    case ENTITIES.DISEASE:\n      id = row.target.id;\n      targetSymbol = row.target.approvedSymbol;\n      diseaseName = parentEntity.disease.name;\n      break;\n    case ENTITIES.TARGET:\n      id = row.disease.id;\n      targetSymbol = parentEntity.target.approvedSymbol;\n      diseaseName = row.disease.name;\n      break;\n    default:\n      return { targetSymbol, diseaseName };\n  }\n  return { targetSymbol, diseaseName, id };\n};\n\n/**\n * Returns the total count of associated diseases or targets based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing associations count.\n * @returns {number} The total count of associated diseases or targets.\n */\nexport const getAllDataCount = (fixedEntity, data) => {\n  switch (fixedEntity) {\n    case ENTITIES.TARGET:\n      return data[ENTITIES.TARGET].associatedDiseases.count;\n    case ENTITIES.DISEASE:\n      return data[ENTITIES.DISEASE].associatedTargets.count;\n    default:\n      return 0;\n  }\n};\n\n/**\n * Aggregates and formats association data based on the fixed entity type.\n * @param {string} fixedEntity - The fixed entity type.\n * @param {Object} data - The data object containing association data.\n * @returns {Array} Formatted association data.\n */\nexport const getAssociationsData = (fixedEntity, data) => {\n  if (!data) return [];\n  const withPrioritisation = fixedEntity === ENTITIES.DISEASE;\n  const dataRows =\n    fixedEntity === ENTITIES.DISEASE\n      ? diseaseAssociationsTargetSelector(data)\n      : targetAssociationsDiseaseSelector(data);\n\n  return dataRows.map((row) => {\n    const dataSources = getDataSourcesData(row);\n    const { targetSymbol, diseaseName, id } = getDataRowMetadata(data, row, fixedEntity);\n    return {\n      score: row.score,\n      id,\n      targetSymbol,\n      diseaseName,\n      dataSources,\n      ...(!withPrioritisation && { disease: row.disease }),\n      ...(withPrioritisation && { target: row.target }),\n      ...(withPrioritisation && getPrioritisationData(row)),\n    };\n  });\n};\n\n/**\n * Generates an array of empty rows for initial loading.\n * @param {number} [rowCount=10] - The number of empty rows to generate.\n * @returns {Array} Array of empty rows.\n */\nexport const getInitialLoadingData = (rowCount = 10) => {\n  const arr = [];\n  for (let i = 0; i < rowCount; i++) {\n    arr.push(getEmptyRow(v1()));\n  }\n  return arr;\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/providers/OTApolloProvider/apollo.tsx" },
        "span": [402, 509],
        "sourceCode": "import { ApolloClient, ApolloLink, HttpLink, InMemoryCache, from } from \"@apollo/client\";\nimport type { Config } from \"@ot/config\";\n\nexport const createApolloClient = (config: Config) => {\n  const httpLink = new HttpLink({\n    uri: config.urlApi,\n  });\n\n  const errorLink = new ApolloLink((operation, forward) => {\n    return forward(operation).map((response) => {\n      if (response.errors) {\n        response.errors.forEach((error) => {\n          console.error(`GraphQL Error: ${error.message}`);\n        });\n      }\n      return response;\n    });\n  });\n\n  return new ApolloClient({\n    link: from([errorLink, httpLink]),\n    cache: new InMemoryCache({\n      possibleTypes: {\n        EntityUnionType: [\"Target\", \"Drug\", \"Disease\", \"Variant\", \"Gwas\"],\n      },\n      typePolicies: {\n        ScoredComponent: {\n          keyFields: [\"componentId\", \"score\"],\n        },\n        Indications: {\n          keyFields: [],\n        },\n        MechanismsOfAction: {\n          keyFields: [],\n        },\n        Hallmarks: {\n          keyFields: [],\n        },\n        AlleleFrequency: {\n          keyFields: [\"populationName\"],\n        },\n        InSilicoPredictor: {\n          keyFields: [\"method\"],\n        },\n      },\n    }),\n    headers: { \"OT-Platform\": \"true\" },\n    defaultOptions: {\n      watchQuery: {\n        fetchPolicy: \"cache-and-network\",\n      },\n    },\n  });\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: dispatch",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: dispatch"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [917, 925],
              "sourceCode": "import { faSearch } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, InputAdornment, TextField, styled, useTheme } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { useDebounce } from \"ui\";\nimport { setEntitySearch } from \"../context/aotfActions\";\nimport useAotfContext from \"../hooks/useAotfContext\";\n\nconst NameFilterInput = styled(TextField)(() => ({\n  borderRadius: \"2px\",\n  margin: 0,\n  \"& .MuiInputBase-input\": {\n    fontSize: \"0.875rem\",\n  },\n  \"& input::placeholder\": {\n    color: \"#000\",\n  },\n}));\n\nconst NameFilter = () => {\n  const { entityToGet, dispatch, entitySearch } = useAotfContext();\n  const placeHolderEntity = entityToGet === \"target\" ? \"target\" : \"disease\";\n\n  const [inputValue, setInputValue] = useState(\"\");\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  useEffect(() => {\n    dispatch(setEntitySearch(debouncedInputValue));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    if (entitySearch !== inputValue) setInputValue(entitySearch);\n  }, [entitySearch]);\n\n  return (\n    <Box sx={{ width: { md: 220 } }}>\n      <NameFilterInput\n        value={inputValue}\n        onChange={(event) => {\n          setInputValue(event.target.value);\n        }}\n        size=\"small\"\n        fullWidth\n        InputProps={{\n          startAdornment: (\n            <InputAdornment position=\"start\">\n              <FontAwesomeIcon icon={faSearch} />\n            </InputAdornment>\n          ),\n        }}\n        placeholder={`Search ${placeHolderEntity}...`}\n      />\n    </Box>\n  );\n};\n\nexport default NameFilter;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/NameFilter.tsx"
        },
        "span": [895, 904],
        "sourceCode": "import { faSearch } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, InputAdornment, TextField, styled, useTheme } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { useDebounce } from \"ui\";\nimport { setEntitySearch } from \"../context/aotfActions\";\nimport useAotfContext from \"../hooks/useAotfContext\";\n\nconst NameFilterInput = styled(TextField)(() => ({\n  borderRadius: \"2px\",\n  margin: 0,\n  \"& .MuiInputBase-input\": {\n    fontSize: \"0.875rem\",\n  },\n  \"& input::placeholder\": {\n    color: \"#000\",\n  },\n}));\n\nconst NameFilter = () => {\n  const { entityToGet, dispatch, entitySearch } = useAotfContext();\n  const placeHolderEntity = entityToGet === \"target\" ? \"target\" : \"disease\";\n\n  const [inputValue, setInputValue] = useState(\"\");\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  useEffect(() => {\n    dispatch(setEntitySearch(debouncedInputValue));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    if (entitySearch !== inputValue) setInputValue(entitySearch);\n  }, [entitySearch]);\n\n  return (\n    <Box sx={{ width: { md: 220 } }}>\n      <NameFilterInput\n        value={inputValue}\n        onChange={(event) => {\n          setInputValue(event.target.value);\n        }}\n        size=\"small\"\n        fullWidth\n        InputProps={{\n          startAdornment: (\n            <InputAdornment position=\"start\">\n              <FontAwesomeIcon icon={faSearch} />\n            </InputAdornment>\n          ),\n        }}\n        placeholder={`Search ${placeHolderEntity}...`}\n      />\n    </Box>\n  );\n};\n\nexport default NameFilter;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: inputValue",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: inputValue"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1040, 1050],
              "sourceCode": "import { faSearch } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, InputAdornment, TextField, styled, useTheme } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { useDebounce } from \"ui\";\nimport { setEntitySearch } from \"../context/aotfActions\";\nimport useAotfContext from \"../hooks/useAotfContext\";\n\nconst NameFilterInput = styled(TextField)(() => ({\n  borderRadius: \"2px\",\n  margin: 0,\n  \"& .MuiInputBase-input\": {\n    fontSize: \"0.875rem\",\n  },\n  \"& input::placeholder\": {\n    color: \"#000\",\n  },\n}));\n\nconst NameFilter = () => {\n  const { entityToGet, dispatch, entitySearch } = useAotfContext();\n  const placeHolderEntity = entityToGet === \"target\" ? \"target\" : \"disease\";\n\n  const [inputValue, setInputValue] = useState(\"\");\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  useEffect(() => {\n    dispatch(setEntitySearch(debouncedInputValue));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    if (entitySearch !== inputValue) setInputValue(entitySearch);\n  }, [entitySearch]);\n\n  return (\n    <Box sx={{ width: { md: 220 } }}>\n      <NameFilterInput\n        value={inputValue}\n        onChange={(event) => {\n          setInputValue(event.target.value);\n        }}\n        size=\"small\"\n        fullWidth\n        InputProps={{\n          startAdornment: (\n            <InputAdornment position=\"start\">\n              <FontAwesomeIcon icon={faSearch} />\n            </InputAdornment>\n          ),\n        }}\n        placeholder={`Search ${placeHolderEntity}...`}\n      />\n    </Box>\n  );\n};\n\nexport default NameFilter;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/NameFilter.tsx"
        },
        "span": [997, 1006],
        "sourceCode": "import { faSearch } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, InputAdornment, TextField, styled, useTheme } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { useDebounce } from \"ui\";\nimport { setEntitySearch } from \"../context/aotfActions\";\nimport useAotfContext from \"../hooks/useAotfContext\";\n\nconst NameFilterInput = styled(TextField)(() => ({\n  borderRadius: \"2px\",\n  margin: 0,\n  \"& .MuiInputBase-input\": {\n    fontSize: \"0.875rem\",\n  },\n  \"& input::placeholder\": {\n    color: \"#000\",\n  },\n}));\n\nconst NameFilter = () => {\n  const { entityToGet, dispatch, entitySearch } = useAotfContext();\n  const placeHolderEntity = entityToGet === \"target\" ? \"target\" : \"disease\";\n\n  const [inputValue, setInputValue] = useState(\"\");\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  useEffect(() => {\n    dispatch(setEntitySearch(debouncedInputValue));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    if (entitySearch !== inputValue) setInputValue(entitySearch);\n  }, [entitySearch]);\n\n  return (\n    <Box sx={{ width: { md: 220 } }}>\n      <NameFilterInput\n        value={inputValue}\n        onChange={(event) => {\n          setInputValue(event.target.value);\n        }}\n        size=\"small\"\n        fullWidth\n        InputProps={{\n          startAdornment: (\n            <InputAdornment position=\"start\">\n              <FontAwesomeIcon icon={faSearch} />\n            </InputAdornment>\n          ),\n        }}\n        placeholder={`Search ${placeHolderEntity}...`}\n      />\n    </Box>\n  );\n};\n\nexport default NameFilter;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [3152, 3169],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: associationsQuery",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: associationsQuery"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2045, 2062],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: datasources.map",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: datasources.map"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2327, 2342],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: entitySearch",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: entitySearch"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2290, 2302],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: state",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: state" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1219, 1224],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: query",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: query" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1409, 1414],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: index",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: index" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2120, 2125],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: id",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: id" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1290, 1292],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: entity",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: entity" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2584, 2590],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: filter",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: filter" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2176, 2182],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: enableIndirect",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: enableIndirect"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2212, 2226],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client.query",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: client.query"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2015, 2027],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1386, 1398],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: diseaseId",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: diseaseId"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2099, 2108],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/RowInteractors/useRowInteractors.js"
        },
        "span": [1109, 1118],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  getAssociationsData,\n  getInitialLoadingData,\n  getInteractorIds,\n} from \"../../associationsUtils\";\n\nimport DiseaseAssociationsQuery from \"../../../../pages/DiseasePage/DiseaseAssociations/DiseaseAssociationsQuery.gql\";\nimport InteractionsQuery from \"./InteractorsQuery.gql\";\n\nconst INITIAL_ROW_COUNT = 8;\n\nconst INITIAL_USE_ASSOCIATION_STATE = {\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(INITIAL_ROW_COUNT),\n  initialLoading: true,\n  count: 0,\n  interactorsMetadata: [],\n};\n\n/********\n * HOOK *\n ********/\nfunction useRowInteractors({\n  client,\n  query = InteractionsQuery,\n  associationsQuery = DiseaseAssociationsQuery,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    source = INTERACTORS_SOURCES.INTACT,\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entityInteractors = null,\n    scoreThreshold = null,\n    entity,\n    diseaseId,\n    sortBy,\n    entitySearch = \"\",\n  },\n}) {\n  const [state, setState] = useState(INITIAL_USE_ASSOCIATION_STATE);\n\n  useEffect(() => {\n    let isCurrent = true;\n    async function getInteractors() {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const rowInteractorsId = id;\n      const rowInteractorsSource = source;\n\n      const targetRowInteractorsRequest = await client.query({\n        query,\n        variables: {\n          scoreThreshold,\n          sourceDatabase: rowInteractorsSource,\n          ensgId: rowInteractorsId,\n          index: 0,\n          size: 3000,\n        },\n      });\n\n      if (!targetRowInteractorsRequest?.data?.target?.interactions?.rows) {\n        setState({\n          interactorsMetadata: { count: 0 },\n          loading: false,\n          initialLoading: false,\n          count: 0,\n          data: [],\n        });\n        return;\n      }\n\n      const interactorsIds = getInteractorIds(targetRowInteractorsRequest);\n\n      const interactorsAssociationsRequest = await client.query({\n        query: associationsQuery,\n        variables: {\n          id: diseaseId,\n          index,\n          size: interactorsIds.length,\n          filter,\n          sortBy,\n          enableIndirect,\n          rowsFilter: interactorsIds,\n          entitySearch: entitySearch,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n        },\n      });\n\n      const interactorsAssociations = getAssociationsData(\n        entity,\n        interactorsAssociationsRequest.data\n      );\n\n      const interactorsAssociationsWithScore = addInteractorScore(\n        interactorsAssociations,\n        targetRowInteractorsRequest.data.target.interactions.rows\n      );\n\n      setState({\n        interactorsMetadata: targetRowInteractorsRequest.data.target.interactions,\n        loading: false,\n        initialLoading: false,\n        count: interactorsAssociationsWithScore.length,\n        data: interactorsAssociationsWithScore,\n      });\n    }\n    if (isCurrent) getInteractors();\n    return () => (isCurrent = false);\n  }, [source, sortBy, scoreThreshold]);\n\n  return state;\n}\n\nfunction addInteractorScore(associationsData, interactorsMetaData) {\n  return associationsData.map((element) => {\n    const foundInteractor = interactorsMetaData.find((x) => x.targetB?.id === element.id);\n    if (!foundInteractor) return { ...element, interactorScore: 0 };\n    return { ...element, interactorScore: foundInteractor.score };\n  });\n}\n\nexport default useRowInteractors;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/DataUploader/DataUploader.jsx"
        },
        "span": [11818, 11835],
        "sourceCode": "import {\n  faCheck,\n  faChevronDown,\n  faChevronLeft,\n  faClipboard,\n  faFileImport,\n  faPlay,\n  faXmark,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Accordion,\n  AccordionDetails,\n  AccordionSummary,\n  Box,\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  IconButton,\n  List,\n  ListSubheader,\n  Snackbar,\n  Step,\n  StepLabel,\n  Stepper,\n  ToggleButton,\n  ToggleButtonGroup,\n  Typography,\n} from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { Link, Tooltip, useApolloClient } from \"ui\";\nimport { v1 } from \"uuid\";\nimport * as XLSX from \"xlsx\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\nimport NestedItem from \"./NestedItem\";\nimport ValidationQuery from \"./ValidationQuery.gql\";\n\nconst BorderAccordion = styled(Accordion)(({ theme }) => ({\n  boxShadow: \"none\",\n  border: `1px solid ${theme.palette.primary.light}`,\n  borderRadius: `${theme.spacing(1)} !important`,\n}));\n\nconst StyledContainer = styled(\"div\")`\n  .dropzone {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 20px;\n    border-width: 2px;\n    border-radius: 2px;\n    border-color: #eeeeee;\n    border-style: dashed;\n    background-color: #fafafa;\n    color: #bdbdbd;\n    outline: none;\n    transition: border 0.24s ease-in-out;\n    margin-bottom: 16px;\n    cursor: pointer;\n  }\n  .dropzone:focus {\n    border-color: #3489ca;\n  }\n`;\n\nconst SuggestionBlockHeader = styled(\"div\")`\n  background-color: #cccccc;\n  border-radius: 8px 8px 0px 0px;\n  border-width: 2px;\n  border-style: solid;\n  border-color: #cccccc;\n  padding: 5px;\n  padding-left: 20px;\n`;\n\nconst SuggestionContainer = styled(\"div\")`\n  position: relative;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding-left: 20px;\n  padding-top: 10px;\n  padding-bottom: 10px;\n  border-width: 2px;\n  border-color: #eeeeee;\n  border-style: solid;\n  border-radius: 0px 0px 8px 8px;\n  background-color: #fafafa;\n  border-top: none;\n`;\n\nconst UploadButton = styled(Button)(({ theme }) => ({\n  border: theme.palette.primary.dark,\n  backgroundColor: theme.palette.primary.dark,\n  color: \"#fff\",\n  \"&:hover\": {\n    backgroundColor: theme.palette.secondary.main,\n  },\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n}));\n\nconst steps = [\"Add a file\", \"Entity validation\"];\n\nconst getEntityToUploadLabel = {\n  target: \"targets\",\n  disease: \"diseases\",\n};\n\nconst getValidationResults = async (entity, queryTerms, client) =>\n  client.query({\n    query: ValidationQuery,\n    variables: { entity, queryTerms },\n  });\n\nfunction formatQueryTermsResults(queryResult) {\n  const sortedResult = [...queryResult.data.mapIds.mappings].sort((a, b) =>\n    a.hits.length < b.hits.length ? 1 : -1\n  );\n  const parsedResult = sortedResult.map((qT) => {\n    const parsedQueryTerm = {\n      ...qT,\n      hits: [...qT.hits.map((e) => ({ ...e, checked: true }))],\n    };\n    return parsedQueryTerm;\n  });\n\n  return parsedResult;\n}\n\nconst uploadSuggestions = {\n  target: [\"ENSG00000232810\", \"interleukin 6\", \"TP53\", \"ENSG00000105329\", \"P15692\", \"CD4\"],\n  disease: [\"EFO_0000508\", \"neoplasm\", \"MONDO_0004992\", \"EFO_0000182\", \"infection\", \"OBI_1110021\"],\n};\n\nconst FileExample = ({ entity = \"target\", runAction }) => {\n  const examples = uploadSuggestions[entity];\n\n  const [open, setExpanded] = useState(false);\n  const [fileType, setFileType] = useState(\"text\");\n\n  const handleFileTypeChange = (_event, newFileType) => {\n    setFileType(newFileType);\n  };\n\n  const handleChange = () => {\n    setExpanded(!open);\n  };\n\n  function handleClickRun() {\n    runAction(examples);\n    setExpanded(false);\n  }\n\n  function copyToClipboard() {\n    navigator.clipboard.writeText(JSON.stringify(examples));\n  }\n  return (\n    <Box sx={{ mb: 6 }}>\n      <BorderAccordion expanded={open} onChange={() => handleChange()}>\n        <AccordionSummary\n          aria-controls=\"panel1a-content\"\n          id=\"panel1a-header\"\n          expandIcon={<FontAwesomeIcon icon={faChevronDown} />}\n        >\n          <Typography>Example format</Typography>\n        </AccordionSummary>\n        <AccordionDetails>\n          <Box>\n            <code>\n              <SuggestionBlockHeader>\n                <Typography variant=\"monoText\" display=\"inline\">\n                  File type:\n                </Typography>\n                <ToggleButtonGroup\n                  color=\"primary\"\n                  value={fileType}\n                  exclusive\n                  onChange={handleFileTypeChange}\n                  aria-label=\"File Example\"\n                  sx={{ ml: 2, background: \"white\" }}\n                >\n                  <ToggleButton value=\"text\">.txt</ToggleButton>\n                  <ToggleButton value=\"spreadsheet\">.csv /.tsv /.xlsx</ToggleButton>\n                  <ToggleButton value=\"json\">.json</ToggleButton>\n                </ToggleButtonGroup>\n              </SuggestionBlockHeader>\n              <SuggestionContainer>\n                <Box sx={{ position: \"absolute\", right: 10, display: \"flex\", gap: 1 }}>\n                  <Tooltip placement=\"bottom\" title=\"Run this sample\">\n                    <Button onClick={() => handleClickRun()}>\n                      <FontAwesomeIcon icon={faPlay} />\n                    </Button>\n                  </Tooltip>\n                  <Tooltip placement=\"bottom\" title=\"Copy to clipboard\">\n                    <Button onClick={() => copyToClipboard()}>\n                      <FontAwesomeIcon icon={faClipboard} />\n                    </Button>\n                  </Tooltip>\n                </Box>\n                <Box>\n                  {fileType === \"json\" && (\n                    <>\n                      [\n                      {examples.map((ex) => (\n                        <Typography key={v1()} variant=\"monoText\" display=\"block\" gutterBottom>\n                          {`\"${ex}\",`}\n                        </Typography>\n                      ))}\n                      ]\n                    </>\n                  )}\n                  {fileType === \"text\" &&\n                    examples.map((ex) => (\n                      <Typography key={v1()} variant=\"monoText\" display=\"block\" gutterBottom>\n                        {ex}\n                      </Typography>\n                    ))}\n                  {fileType === \"spreadsheet\" && (\n                    <table style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}>\n                      <thead>\n                        <tr style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}>\n                          <th>id</th>\n                        </tr>\n                      </thead>\n                      <tbody>\n                        {examples.map((ex) => (\n                          <tr\n                            key={v1()}\n                            style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}\n                          >\n                            <td>\n                              <Typography variant=\"monoText\" display=\"block\" gutterBottom>\n                                {ex}\n                              </Typography>\n                            </td>\n                          </tr>\n                        ))}\n                      </tbody>\n                    </table>\n                  )}\n                </Box>\n              </SuggestionContainer>\n            </code>\n          </Box>\n        </AccordionDetails>\n      </BorderAccordion>\n    </Box>\n  );\n};\n\nfunction DataUploader({ parentAction }) {\n  const [activeStep, setActiveStep] = useState(0);\n  const [queryTermsResults, setQueryTermsResults] = useState(null);\n  const { entityToGet, setUploadedEntries, uploadedEntries } = useAotfContext();\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [openErrorSnackbar, setOpenErrorSnackbar] = useState(false);\n  const client = useApolloClient();\n  const { getRootProps, getInputProps } = useDropzone({\n    accept: {\n      \"text/html\": [\".txt\"],\n      \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": [\n        \".csv\",\n        \".tsv\",\n        \".xlsx\",\n      ],\n      \"application/JSON\": [\".json\"],\n    },\n    onDrop: async ([file]) => {\n      const reader = new FileReader();\n      const fileType = getFileType(file.name);\n\n      if (fileType === \"spreadsheet\") reader.readAsBinaryString(file);\n      else if (fileType === \"text\") reader.readAsText(file);\n      else if (fileType === \"json\") reader.readAsText(file);\n      else setOpenErrorSnackbar(true);\n\n      reader.onload = async (e) => {\n        let contents;\n        if (fileType === \"spreadsheet\") contents = getDataFromSpreadsheet(e);\n        else if (fileType === \"text\") contents = getDataFromTextFile(e);\n        else if (fileType === \"json\") contents = JSON.parse(e.target.result);\n        else setOpenErrorSnackbar(true);\n\n        const result = await getValidationResults([entityToGet], contents, client);\n        setQueryTermsResults(formatQueryTermsResults(result));\n        setActiveStep(1);\n      };\n    },\n  });\n\n  function getDataFromSpreadsheet(file) {\n    const wb = XLSX.read(file.target.result, { type: \"binary\", bookVBA: true });\n    /* Get first worksheet */\n    const wsname = wb.SheetNames[0];\n    const ws = wb.Sheets[wsname];\n    /* Convert array of arrays */\n    const data = XLSX.utils.sheet_to_json(ws);\n\n    if (!Object.prototype.hasOwnProperty.call(data[0], \"id\")) {\n      setOpenErrorSnackbar(true);\n      console.error(\n        \"Please ensure the uploaded file is in the correct format (see allowed file types and example format)\"\n      );\n    }\n\n    const terms = data.map((item) => item.id);\n    return terms;\n  }\n\n  function getDataFromTextFile(file) {\n    const contents = file.target.result;\n    const terms = contents.split(\"\\n\");\n    return terms;\n  }\n\n  function getFileType(fileName) {\n    const fileType = fileName.split(\".\").pop();\n    switch (fileType) {\n      case \"csv\":\n        return \"spreadsheet\";\n      case \"tsv\":\n        return \"spreadsheet\";\n      case \"xlsx\":\n        return \"spreadsheet\";\n      case \"txt\":\n        return \"text\";\n      case \"json\":\n        return \"json\";\n      default:\n        return fileType;\n    }\n  }\n\n  const handleRunExample = async (terms) => {\n    const result = await getValidationResults([entityToGet], terms, client);\n    setQueryTermsResults(formatQueryTermsResults(result));\n    setActiveStep(1);\n  };\n\n  const entityToUploadLabel = getEntityToUploadLabel[entityToGet];\n\n  const handlePinElements = () => {\n    setActiveStep((prevActiveStep) => prevActiveStep + 1);\n    const allHits = [];\n    for (let index = 0; index < queryTermsResults.length; index++) {\n      const term = queryTermsResults[index];\n      for (let r = 0; r < term.hits.length; r++) {\n        const hit = term.hits[r];\n        if (hit.checked) allHits.push(hit.id);\n      }\n    }\n    setUploadedEntries([...uploadedEntries, ...allHits]);\n    handleClosePopover();\n  };\n\n  const handleBack = () => {\n    if (activeStep < 1) handleClosePopover();\n    else setActiveStep((prevActiveStep) => prevActiveStep - 1);\n  };\n\n  const handleReset = () => {\n    setActiveStep(0);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"downloader-popover\" : undefined;\n\n  const handleClickBTN = (event) => {\n    // parentAction();\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClosePopover = () => {\n    setAnchorEl(null);\n    setQueryTermsResults(null);\n    handleReset();\n  };\n\n  function handleParentChange(term) {\n    const checkboxUpdateState = [...queryTermsResults];\n    checkboxUpdateState.find((hitItem) => {\n      if (hitItem.term === term) {\n        hitItem.hits.every((el) => !el.checked)\n          ? hitItem.hits.map((el) => (el.checked = true))\n          : hitItem.hits.map((el) => (el.checked = false));\n      }\n    });\n    setQueryTermsResults(checkboxUpdateState);\n  }\n\n  function handleChangeChildCheckbox(hitId) {\n    const checkboxUpdateState = [...queryTermsResults];\n    checkboxUpdateState.find((hitItem) => {\n      hitItem.hits.find((el) => {\n        if (el.id === hitId) return (el.checked = !el.checked);\n      });\n    });\n    setQueryTermsResults(checkboxUpdateState);\n  }\n\n  function handleCloseErrorSnackbar() {\n    setOpenErrorSnackbar(false);\n  }\n\n  return (\n    <div>\n      <UploadButton\n        aria-describedby={popoverId}\n        onClick={handleClickBTN}\n        disableElevation\n        sx={{ height: 1, maxHeight: \"45px\" }}\n        aria-label=\"Upload list of entities\"\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFileImport} size=\"lg\" />\n        </Box>\n        {`Upload list of ${entityToUploadLabel}`}\n      </UploadButton>\n      <Dialog\n        onClose={handleClosePopover}\n        open={open}\n        sx={{\n          \".MuiDialog-paper\": {\n            width: \"70%\",\n            maxWidth: \"800px !important\",\n            borderRadius: (theme) => theme.spacing(1),\n          },\n        }}\n      >\n        <DialogTitle>{`Upload list of ${entityToUploadLabel}`}</DialogTitle>\n        <DialogContent sx={{ pb: 0, overflowY: \"scroll\" }} dividers>\n          <Typography\n            sx={{ m: (theme) => `${theme.spacing(1)} 0 ${theme.spacing(4)} 0` }}\n            variant=\"subtitle2\"\n            gutterBottom\n          >\n            Please upload a file here (allowed file formats - .txt / .csv / .tsv / .xlsx / .json)\n            containing your custom list of targets/diseases. The file should contain a single{\" \"}\n            {entityToGet} in every row. You will be able to visualise all the potential matches upon\n            validation of your input.\n            <br />\n            <Link\n              to=\"https://platform-docs.opentargets.org/web-interface/associations-on-the-fly#upload-functionality\"\n              external\n            >\n              Read more details here.\n            </Link>\n          </Typography>\n          {activeStep === 0 && <FileExample entity={entityToGet} runAction={handleRunExample} />}\n          <Box sx={{ m: (theme) => `${theme.spacing(1)} 0 ${theme.spacing(4)} 0` }}>\n            <Stepper activeStep={activeStep}>\n              {steps.map((label) => {\n                const stepProps = {};\n                const labelProps = {};\n                return (\n                  <Step key={label} {...stepProps}>\n                    <StepLabel {...labelProps}>{label}</StepLabel>\n                  </Step>\n                );\n              })}\n            </Stepper>\n          </Box>\n\n          {activeStep === 0 && (\n            <StyledContainer>\n              <div {...getRootProps({ className: \"dropzone\" })}>\n                <input {...getInputProps()} />\n                <p>Drag and drop a file here, or click to select file (see example format).</p>\n              </div>\n            </StyledContainer>\n          )}\n          {activeStep === 1 && (\n            <Box>\n              <Box sx={{ overflowY: \"scroll\" }}>\n                <List\n                  sx={{ width: \"100%\", maxWidth: 1, bgcolor: \"background.paper\" }}\n                  aria-labelledby=\"nested-list-subheader\"\n                  subheader={\n                    <ListSubheader sx={{ px: 1.5 }} component=\"div\" id=\"nested-list-subheader\">\n                      Validation mappings ( Upload count: {queryTermsResults.length})\n                    </ListSubheader>\n                  }\n                >\n                  {queryTermsResults.map(({ term, hits }) => (\n                    <NestedItem\n                      key={v1()}\n                      hits={hits}\n                      term={term}\n                      handleParentChange={handleParentChange}\n                      handleChangeChildCheckbox={handleChangeChildCheckbox}\n                    >\n                      {`${term} (${hits.length} hits)`}\n                    </NestedItem>\n                  ))}\n                </List>\n              </Box>\n            </Box>\n          )}\n        </DialogContent>\n\n        <DialogActions>\n          <Box sx={{ display: \"flex\", justifyContent: \"space-between\", mx: 2, my: 1, width: 1 }}>\n            <Button\n              aria-describedby={popoverId}\n              variant=\"outlined\"\n              disableElevation\n              startIcon={<FontAwesomeIcon icon={faChevronLeft} size=\"lg\" />}\n              onClick={handleBack}\n            >\n              Back\n            </Button>\n            {activeStep === 1 && (\n              <Button\n                aria-describedby={popoverId}\n                variant=\"outlined\"\n                disableElevation\n                startIcon={<FontAwesomeIcon icon={faCheck} size=\"lg\" />}\n                onClick={handlePinElements}\n              >\n                Upload hits\n              </Button>\n            )}\n          </Box>\n        </DialogActions>\n      </Dialog>\n      <Snackbar\n        open={openErrorSnackbar}\n        autoHideDuration={10000}\n        onClose={handleCloseErrorSnackbar}\n        message={\n          <Box sx={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\" }}>\n            Please ensure the uploaded file has id in column header (see example format)\n            <IconButton sx={{ color: \"white\" }} onClick={handleCloseErrorSnackbar}>\n              <FontAwesomeIcon icon={faXmark} />\n            </IconButton>\n          </Box>\n        }\n      />\n    </div>\n  );\n}\n\nexport default DataUploader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/DataUploader/DataUploader.jsx"
        },
        "span": [11876, 11894],
        "sourceCode": "import {\n  faCheck,\n  faChevronDown,\n  faChevronLeft,\n  faClipboard,\n  faFileImport,\n  faPlay,\n  faXmark,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Accordion,\n  AccordionDetails,\n  AccordionSummary,\n  Box,\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  IconButton,\n  List,\n  ListSubheader,\n  Snackbar,\n  Step,\n  StepLabel,\n  Stepper,\n  ToggleButton,\n  ToggleButtonGroup,\n  Typography,\n} from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { Link, Tooltip, useApolloClient } from \"ui\";\nimport { v1 } from \"uuid\";\nimport * as XLSX from \"xlsx\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\nimport NestedItem from \"./NestedItem\";\nimport ValidationQuery from \"./ValidationQuery.gql\";\n\nconst BorderAccordion = styled(Accordion)(({ theme }) => ({\n  boxShadow: \"none\",\n  border: `1px solid ${theme.palette.primary.light}`,\n  borderRadius: `${theme.spacing(1)} !important`,\n}));\n\nconst StyledContainer = styled(\"div\")`\n  .dropzone {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 20px;\n    border-width: 2px;\n    border-radius: 2px;\n    border-color: #eeeeee;\n    border-style: dashed;\n    background-color: #fafafa;\n    color: #bdbdbd;\n    outline: none;\n    transition: border 0.24s ease-in-out;\n    margin-bottom: 16px;\n    cursor: pointer;\n  }\n  .dropzone:focus {\n    border-color: #3489ca;\n  }\n`;\n\nconst SuggestionBlockHeader = styled(\"div\")`\n  background-color: #cccccc;\n  border-radius: 8px 8px 0px 0px;\n  border-width: 2px;\n  border-style: solid;\n  border-color: #cccccc;\n  padding: 5px;\n  padding-left: 20px;\n`;\n\nconst SuggestionContainer = styled(\"div\")`\n  position: relative;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding-left: 20px;\n  padding-top: 10px;\n  padding-bottom: 10px;\n  border-width: 2px;\n  border-color: #eeeeee;\n  border-style: solid;\n  border-radius: 0px 0px 8px 8px;\n  background-color: #fafafa;\n  border-top: none;\n`;\n\nconst UploadButton = styled(Button)(({ theme }) => ({\n  border: theme.palette.primary.dark,\n  backgroundColor: theme.palette.primary.dark,\n  color: \"#fff\",\n  \"&:hover\": {\n    backgroundColor: theme.palette.secondary.main,\n  },\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n}));\n\nconst steps = [\"Add a file\", \"Entity validation\"];\n\nconst getEntityToUploadLabel = {\n  target: \"targets\",\n  disease: \"diseases\",\n};\n\nconst getValidationResults = async (entity, queryTerms, client) =>\n  client.query({\n    query: ValidationQuery,\n    variables: { entity, queryTerms },\n  });\n\nfunction formatQueryTermsResults(queryResult) {\n  const sortedResult = [...queryResult.data.mapIds.mappings].sort((a, b) =>\n    a.hits.length < b.hits.length ? 1 : -1\n  );\n  const parsedResult = sortedResult.map((qT) => {\n    const parsedQueryTerm = {\n      ...qT,\n      hits: [...qT.hits.map((e) => ({ ...e, checked: true }))],\n    };\n    return parsedQueryTerm;\n  });\n\n  return parsedResult;\n}\n\nconst uploadSuggestions = {\n  target: [\"ENSG00000232810\", \"interleukin 6\", \"TP53\", \"ENSG00000105329\", \"P15692\", \"CD4\"],\n  disease: [\"EFO_0000508\", \"neoplasm\", \"MONDO_0004992\", \"EFO_0000182\", \"infection\", \"OBI_1110021\"],\n};\n\nconst FileExample = ({ entity = \"target\", runAction }) => {\n  const examples = uploadSuggestions[entity];\n\n  const [open, setExpanded] = useState(false);\n  const [fileType, setFileType] = useState(\"text\");\n\n  const handleFileTypeChange = (_event, newFileType) => {\n    setFileType(newFileType);\n  };\n\n  const handleChange = () => {\n    setExpanded(!open);\n  };\n\n  function handleClickRun() {\n    runAction(examples);\n    setExpanded(false);\n  }\n\n  function copyToClipboard() {\n    navigator.clipboard.writeText(JSON.stringify(examples));\n  }\n  return (\n    <Box sx={{ mb: 6 }}>\n      <BorderAccordion expanded={open} onChange={() => handleChange()}>\n        <AccordionSummary\n          aria-controls=\"panel1a-content\"\n          id=\"panel1a-header\"\n          expandIcon={<FontAwesomeIcon icon={faChevronDown} />}\n        >\n          <Typography>Example format</Typography>\n        </AccordionSummary>\n        <AccordionDetails>\n          <Box>\n            <code>\n              <SuggestionBlockHeader>\n                <Typography variant=\"monoText\" display=\"inline\">\n                  File type:\n                </Typography>\n                <ToggleButtonGroup\n                  color=\"primary\"\n                  value={fileType}\n                  exclusive\n                  onChange={handleFileTypeChange}\n                  aria-label=\"File Example\"\n                  sx={{ ml: 2, background: \"white\" }}\n                >\n                  <ToggleButton value=\"text\">.txt</ToggleButton>\n                  <ToggleButton value=\"spreadsheet\">.csv /.tsv /.xlsx</ToggleButton>\n                  <ToggleButton value=\"json\">.json</ToggleButton>\n                </ToggleButtonGroup>\n              </SuggestionBlockHeader>\n              <SuggestionContainer>\n                <Box sx={{ position: \"absolute\", right: 10, display: \"flex\", gap: 1 }}>\n                  <Tooltip placement=\"bottom\" title=\"Run this sample\">\n                    <Button onClick={() => handleClickRun()}>\n                      <FontAwesomeIcon icon={faPlay} />\n                    </Button>\n                  </Tooltip>\n                  <Tooltip placement=\"bottom\" title=\"Copy to clipboard\">\n                    <Button onClick={() => copyToClipboard()}>\n                      <FontAwesomeIcon icon={faClipboard} />\n                    </Button>\n                  </Tooltip>\n                </Box>\n                <Box>\n                  {fileType === \"json\" && (\n                    <>\n                      [\n                      {examples.map((ex) => (\n                        <Typography key={v1()} variant=\"monoText\" display=\"block\" gutterBottom>\n                          {`\"${ex}\",`}\n                        </Typography>\n                      ))}\n                      ]\n                    </>\n                  )}\n                  {fileType === \"text\" &&\n                    examples.map((ex) => (\n                      <Typography key={v1()} variant=\"monoText\" display=\"block\" gutterBottom>\n                        {ex}\n                      </Typography>\n                    ))}\n                  {fileType === \"spreadsheet\" && (\n                    <table style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}>\n                      <thead>\n                        <tr style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}>\n                          <th>id</th>\n                        </tr>\n                      </thead>\n                      <tbody>\n                        {examples.map((ex) => (\n                          <tr\n                            key={v1()}\n                            style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}\n                          >\n                            <td>\n                              <Typography variant=\"monoText\" display=\"block\" gutterBottom>\n                                {ex}\n                              </Typography>\n                            </td>\n                          </tr>\n                        ))}\n                      </tbody>\n                    </table>\n                  )}\n                </Box>\n              </SuggestionContainer>\n            </code>\n          </Box>\n        </AccordionDetails>\n      </BorderAccordion>\n    </Box>\n  );\n};\n\nfunction DataUploader({ parentAction }) {\n  const [activeStep, setActiveStep] = useState(0);\n  const [queryTermsResults, setQueryTermsResults] = useState(null);\n  const { entityToGet, setUploadedEntries, uploadedEntries } = useAotfContext();\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [openErrorSnackbar, setOpenErrorSnackbar] = useState(false);\n  const client = useApolloClient();\n  const { getRootProps, getInputProps } = useDropzone({\n    accept: {\n      \"text/html\": [\".txt\"],\n      \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": [\n        \".csv\",\n        \".tsv\",\n        \".xlsx\",\n      ],\n      \"application/JSON\": [\".json\"],\n    },\n    onDrop: async ([file]) => {\n      const reader = new FileReader();\n      const fileType = getFileType(file.name);\n\n      if (fileType === \"spreadsheet\") reader.readAsBinaryString(file);\n      else if (fileType === \"text\") reader.readAsText(file);\n      else if (fileType === \"json\") reader.readAsText(file);\n      else setOpenErrorSnackbar(true);\n\n      reader.onload = async (e) => {\n        let contents;\n        if (fileType === \"spreadsheet\") contents = getDataFromSpreadsheet(e);\n        else if (fileType === \"text\") contents = getDataFromTextFile(e);\n        else if (fileType === \"json\") contents = JSON.parse(e.target.result);\n        else setOpenErrorSnackbar(true);\n\n        const result = await getValidationResults([entityToGet], contents, client);\n        setQueryTermsResults(formatQueryTermsResults(result));\n        setActiveStep(1);\n      };\n    },\n  });\n\n  function getDataFromSpreadsheet(file) {\n    const wb = XLSX.read(file.target.result, { type: \"binary\", bookVBA: true });\n    /* Get first worksheet */\n    const wsname = wb.SheetNames[0];\n    const ws = wb.Sheets[wsname];\n    /* Convert array of arrays */\n    const data = XLSX.utils.sheet_to_json(ws);\n\n    if (!Object.prototype.hasOwnProperty.call(data[0], \"id\")) {\n      setOpenErrorSnackbar(true);\n      console.error(\n        \"Please ensure the uploaded file is in the correct format (see allowed file types and example format)\"\n      );\n    }\n\n    const terms = data.map((item) => item.id);\n    return terms;\n  }\n\n  function getDataFromTextFile(file) {\n    const contents = file.target.result;\n    const terms = contents.split(\"\\n\");\n    return terms;\n  }\n\n  function getFileType(fileName) {\n    const fileType = fileName.split(\".\").pop();\n    switch (fileType) {\n      case \"csv\":\n        return \"spreadsheet\";\n      case \"tsv\":\n        return \"spreadsheet\";\n      case \"xlsx\":\n        return \"spreadsheet\";\n      case \"txt\":\n        return \"text\";\n      case \"json\":\n        return \"json\";\n      default:\n        return fileType;\n    }\n  }\n\n  const handleRunExample = async (terms) => {\n    const result = await getValidationResults([entityToGet], terms, client);\n    setQueryTermsResults(formatQueryTermsResults(result));\n    setActiveStep(1);\n  };\n\n  const entityToUploadLabel = getEntityToUploadLabel[entityToGet];\n\n  const handlePinElements = () => {\n    setActiveStep((prevActiveStep) => prevActiveStep + 1);\n    const allHits = [];\n    for (let index = 0; index < queryTermsResults.length; index++) {\n      const term = queryTermsResults[index];\n      for (let r = 0; r < term.hits.length; r++) {\n        const hit = term.hits[r];\n        if (hit.checked) allHits.push(hit.id);\n      }\n    }\n    setUploadedEntries([...uploadedEntries, ...allHits]);\n    handleClosePopover();\n  };\n\n  const handleBack = () => {\n    if (activeStep < 1) handleClosePopover();\n    else setActiveStep((prevActiveStep) => prevActiveStep - 1);\n  };\n\n  const handleReset = () => {\n    setActiveStep(0);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"downloader-popover\" : undefined;\n\n  const handleClickBTN = (event) => {\n    // parentAction();\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClosePopover = () => {\n    setAnchorEl(null);\n    setQueryTermsResults(null);\n    handleReset();\n  };\n\n  function handleParentChange(term) {\n    const checkboxUpdateState = [...queryTermsResults];\n    checkboxUpdateState.find((hitItem) => {\n      if (hitItem.term === term) {\n        hitItem.hits.every((el) => !el.checked)\n          ? hitItem.hits.map((el) => (el.checked = true))\n          : hitItem.hits.map((el) => (el.checked = false));\n      }\n    });\n    setQueryTermsResults(checkboxUpdateState);\n  }\n\n  function handleChangeChildCheckbox(hitId) {\n    const checkboxUpdateState = [...queryTermsResults];\n    checkboxUpdateState.find((hitItem) => {\n      hitItem.hits.find((el) => {\n        if (el.id === hitId) return (el.checked = !el.checked);\n      });\n    });\n    setQueryTermsResults(checkboxUpdateState);\n  }\n\n  function handleCloseErrorSnackbar() {\n    setOpenErrorSnackbar(false);\n  }\n\n  return (\n    <div>\n      <UploadButton\n        aria-describedby={popoverId}\n        onClick={handleClickBTN}\n        disableElevation\n        sx={{ height: 1, maxHeight: \"45px\" }}\n        aria-label=\"Upload list of entities\"\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFileImport} size=\"lg\" />\n        </Box>\n        {`Upload list of ${entityToUploadLabel}`}\n      </UploadButton>\n      <Dialog\n        onClose={handleClosePopover}\n        open={open}\n        sx={{\n          \".MuiDialog-paper\": {\n            width: \"70%\",\n            maxWidth: \"800px !important\",\n            borderRadius: (theme) => theme.spacing(1),\n          },\n        }}\n      >\n        <DialogTitle>{`Upload list of ${entityToUploadLabel}`}</DialogTitle>\n        <DialogContent sx={{ pb: 0, overflowY: \"scroll\" }} dividers>\n          <Typography\n            sx={{ m: (theme) => `${theme.spacing(1)} 0 ${theme.spacing(4)} 0` }}\n            variant=\"subtitle2\"\n            gutterBottom\n          >\n            Please upload a file here (allowed file formats - .txt / .csv / .tsv / .xlsx / .json)\n            containing your custom list of targets/diseases. The file should contain a single{\" \"}\n            {entityToGet} in every row. You will be able to visualise all the potential matches upon\n            validation of your input.\n            <br />\n            <Link\n              to=\"https://platform-docs.opentargets.org/web-interface/associations-on-the-fly#upload-functionality\"\n              external\n            >\n              Read more details here.\n            </Link>\n          </Typography>\n          {activeStep === 0 && <FileExample entity={entityToGet} runAction={handleRunExample} />}\n          <Box sx={{ m: (theme) => `${theme.spacing(1)} 0 ${theme.spacing(4)} 0` }}>\n            <Stepper activeStep={activeStep}>\n              {steps.map((label) => {\n                const stepProps = {};\n                const labelProps = {};\n                return (\n                  <Step key={label} {...stepProps}>\n                    <StepLabel {...labelProps}>{label}</StepLabel>\n                  </Step>\n                );\n              })}\n            </Stepper>\n          </Box>\n\n          {activeStep === 0 && (\n            <StyledContainer>\n              <div {...getRootProps({ className: \"dropzone\" })}>\n                <input {...getInputProps()} />\n                <p>Drag and drop a file here, or click to select file (see example format).</p>\n              </div>\n            </StyledContainer>\n          )}\n          {activeStep === 1 && (\n            <Box>\n              <Box sx={{ overflowY: \"scroll\" }}>\n                <List\n                  sx={{ width: \"100%\", maxWidth: 1, bgcolor: \"background.paper\" }}\n                  aria-labelledby=\"nested-list-subheader\"\n                  subheader={\n                    <ListSubheader sx={{ px: 1.5 }} component=\"div\" id=\"nested-list-subheader\">\n                      Validation mappings ( Upload count: {queryTermsResults.length})\n                    </ListSubheader>\n                  }\n                >\n                  {queryTermsResults.map(({ term, hits }) => (\n                    <NestedItem\n                      key={v1()}\n                      hits={hits}\n                      term={term}\n                      handleParentChange={handleParentChange}\n                      handleChangeChildCheckbox={handleChangeChildCheckbox}\n                    >\n                      {`${term} (${hits.length} hits)`}\n                    </NestedItem>\n                  ))}\n                </List>\n              </Box>\n            </Box>\n          )}\n        </DialogContent>\n\n        <DialogActions>\n          <Box sx={{ display: \"flex\", justifyContent: \"space-between\", mx: 2, my: 1, width: 1 }}>\n            <Button\n              aria-describedby={popoverId}\n              variant=\"outlined\"\n              disableElevation\n              startIcon={<FontAwesomeIcon icon={faChevronLeft} size=\"lg\" />}\n              onClick={handleBack}\n            >\n              Back\n            </Button>\n            {activeStep === 1 && (\n              <Button\n                aria-describedby={popoverId}\n                variant=\"outlined\"\n                disableElevation\n                startIcon={<FontAwesomeIcon icon={faCheck} size=\"lg\" />}\n                onClick={handlePinElements}\n              >\n                Upload hits\n              </Button>\n            )}\n          </Box>\n        </DialogActions>\n      </Dialog>\n      <Snackbar\n        open={openErrorSnackbar}\n        autoHideDuration={10000}\n        onClose={handleCloseErrorSnackbar}\n        message={\n          <Box sx={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\" }}>\n            Please ensure the uploaded file has id in column header (see example format)\n            <IconButton sx={{ color: \"white\" }} onClick={handleCloseErrorSnackbar}>\n              <FontAwesomeIcon icon={faXmark} />\n            </IconButton>\n          </Box>\n        }\n      />\n    </div>\n  );\n}\n\nexport default DataUploader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/DataUploader/DataUploader.jsx"
        },
        "span": [12183, 12207],
        "sourceCode": "import {\n  faCheck,\n  faChevronDown,\n  faChevronLeft,\n  faClipboard,\n  faFileImport,\n  faPlay,\n  faXmark,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Accordion,\n  AccordionDetails,\n  AccordionSummary,\n  Box,\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  IconButton,\n  List,\n  ListSubheader,\n  Snackbar,\n  Step,\n  StepLabel,\n  Stepper,\n  ToggleButton,\n  ToggleButtonGroup,\n  Typography,\n} from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { Link, Tooltip, useApolloClient } from \"ui\";\nimport { v1 } from \"uuid\";\nimport * as XLSX from \"xlsx\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\nimport NestedItem from \"./NestedItem\";\nimport ValidationQuery from \"./ValidationQuery.gql\";\n\nconst BorderAccordion = styled(Accordion)(({ theme }) => ({\n  boxShadow: \"none\",\n  border: `1px solid ${theme.palette.primary.light}`,\n  borderRadius: `${theme.spacing(1)} !important`,\n}));\n\nconst StyledContainer = styled(\"div\")`\n  .dropzone {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 20px;\n    border-width: 2px;\n    border-radius: 2px;\n    border-color: #eeeeee;\n    border-style: dashed;\n    background-color: #fafafa;\n    color: #bdbdbd;\n    outline: none;\n    transition: border 0.24s ease-in-out;\n    margin-bottom: 16px;\n    cursor: pointer;\n  }\n  .dropzone:focus {\n    border-color: #3489ca;\n  }\n`;\n\nconst SuggestionBlockHeader = styled(\"div\")`\n  background-color: #cccccc;\n  border-radius: 8px 8px 0px 0px;\n  border-width: 2px;\n  border-style: solid;\n  border-color: #cccccc;\n  padding: 5px;\n  padding-left: 20px;\n`;\n\nconst SuggestionContainer = styled(\"div\")`\n  position: relative;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  padding-left: 20px;\n  padding-top: 10px;\n  padding-bottom: 10px;\n  border-width: 2px;\n  border-color: #eeeeee;\n  border-style: solid;\n  border-radius: 0px 0px 8px 8px;\n  background-color: #fafafa;\n  border-top: none;\n`;\n\nconst UploadButton = styled(Button)(({ theme }) => ({\n  border: theme.palette.primary.dark,\n  backgroundColor: theme.palette.primary.dark,\n  color: \"#fff\",\n  \"&:hover\": {\n    backgroundColor: theme.palette.secondary.main,\n  },\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n}));\n\nconst steps = [\"Add a file\", \"Entity validation\"];\n\nconst getEntityToUploadLabel = {\n  target: \"targets\",\n  disease: \"diseases\",\n};\n\nconst getValidationResults = async (entity, queryTerms, client) =>\n  client.query({\n    query: ValidationQuery,\n    variables: { entity, queryTerms },\n  });\n\nfunction formatQueryTermsResults(queryResult) {\n  const sortedResult = [...queryResult.data.mapIds.mappings].sort((a, b) =>\n    a.hits.length < b.hits.length ? 1 : -1\n  );\n  const parsedResult = sortedResult.map((qT) => {\n    const parsedQueryTerm = {\n      ...qT,\n      hits: [...qT.hits.map((e) => ({ ...e, checked: true }))],\n    };\n    return parsedQueryTerm;\n  });\n\n  return parsedResult;\n}\n\nconst uploadSuggestions = {\n  target: [\"ENSG00000232810\", \"interleukin 6\", \"TP53\", \"ENSG00000105329\", \"P15692\", \"CD4\"],\n  disease: [\"EFO_0000508\", \"neoplasm\", \"MONDO_0004992\", \"EFO_0000182\", \"infection\", \"OBI_1110021\"],\n};\n\nconst FileExample = ({ entity = \"target\", runAction }) => {\n  const examples = uploadSuggestions[entity];\n\n  const [open, setExpanded] = useState(false);\n  const [fileType, setFileType] = useState(\"text\");\n\n  const handleFileTypeChange = (_event, newFileType) => {\n    setFileType(newFileType);\n  };\n\n  const handleChange = () => {\n    setExpanded(!open);\n  };\n\n  function handleClickRun() {\n    runAction(examples);\n    setExpanded(false);\n  }\n\n  function copyToClipboard() {\n    navigator.clipboard.writeText(JSON.stringify(examples));\n  }\n  return (\n    <Box sx={{ mb: 6 }}>\n      <BorderAccordion expanded={open} onChange={() => handleChange()}>\n        <AccordionSummary\n          aria-controls=\"panel1a-content\"\n          id=\"panel1a-header\"\n          expandIcon={<FontAwesomeIcon icon={faChevronDown} />}\n        >\n          <Typography>Example format</Typography>\n        </AccordionSummary>\n        <AccordionDetails>\n          <Box>\n            <code>\n              <SuggestionBlockHeader>\n                <Typography variant=\"monoText\" display=\"inline\">\n                  File type:\n                </Typography>\n                <ToggleButtonGroup\n                  color=\"primary\"\n                  value={fileType}\n                  exclusive\n                  onChange={handleFileTypeChange}\n                  aria-label=\"File Example\"\n                  sx={{ ml: 2, background: \"white\" }}\n                >\n                  <ToggleButton value=\"text\">.txt</ToggleButton>\n                  <ToggleButton value=\"spreadsheet\">.csv /.tsv /.xlsx</ToggleButton>\n                  <ToggleButton value=\"json\">.json</ToggleButton>\n                </ToggleButtonGroup>\n              </SuggestionBlockHeader>\n              <SuggestionContainer>\n                <Box sx={{ position: \"absolute\", right: 10, display: \"flex\", gap: 1 }}>\n                  <Tooltip placement=\"bottom\" title=\"Run this sample\">\n                    <Button onClick={() => handleClickRun()}>\n                      <FontAwesomeIcon icon={faPlay} />\n                    </Button>\n                  </Tooltip>\n                  <Tooltip placement=\"bottom\" title=\"Copy to clipboard\">\n                    <Button onClick={() => copyToClipboard()}>\n                      <FontAwesomeIcon icon={faClipboard} />\n                    </Button>\n                  </Tooltip>\n                </Box>\n                <Box>\n                  {fileType === \"json\" && (\n                    <>\n                      [\n                      {examples.map((ex) => (\n                        <Typography key={v1()} variant=\"monoText\" display=\"block\" gutterBottom>\n                          {`\"${ex}\",`}\n                        </Typography>\n                      ))}\n                      ]\n                    </>\n                  )}\n                  {fileType === \"text\" &&\n                    examples.map((ex) => (\n                      <Typography key={v1()} variant=\"monoText\" display=\"block\" gutterBottom>\n                        {ex}\n                      </Typography>\n                    ))}\n                  {fileType === \"spreadsheet\" && (\n                    <table style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}>\n                      <thead>\n                        <tr style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}>\n                          <th>id</th>\n                        </tr>\n                      </thead>\n                      <tbody>\n                        {examples.map((ex) => (\n                          <tr\n                            key={v1()}\n                            style={{ border: \"1px solid black\", borderCollapse: \"collapse\" }}\n                          >\n                            <td>\n                              <Typography variant=\"monoText\" display=\"block\" gutterBottom>\n                                {ex}\n                              </Typography>\n                            </td>\n                          </tr>\n                        ))}\n                      </tbody>\n                    </table>\n                  )}\n                </Box>\n              </SuggestionContainer>\n            </code>\n          </Box>\n        </AccordionDetails>\n      </BorderAccordion>\n    </Box>\n  );\n};\n\nfunction DataUploader({ parentAction }) {\n  const [activeStep, setActiveStep] = useState(0);\n  const [queryTermsResults, setQueryTermsResults] = useState(null);\n  const { entityToGet, setUploadedEntries, uploadedEntries } = useAotfContext();\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [openErrorSnackbar, setOpenErrorSnackbar] = useState(false);\n  const client = useApolloClient();\n  const { getRootProps, getInputProps } = useDropzone({\n    accept: {\n      \"text/html\": [\".txt\"],\n      \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": [\n        \".csv\",\n        \".tsv\",\n        \".xlsx\",\n      ],\n      \"application/JSON\": [\".json\"],\n    },\n    onDrop: async ([file]) => {\n      const reader = new FileReader();\n      const fileType = getFileType(file.name);\n\n      if (fileType === \"spreadsheet\") reader.readAsBinaryString(file);\n      else if (fileType === \"text\") reader.readAsText(file);\n      else if (fileType === \"json\") reader.readAsText(file);\n      else setOpenErrorSnackbar(true);\n\n      reader.onload = async (e) => {\n        let contents;\n        if (fileType === \"spreadsheet\") contents = getDataFromSpreadsheet(e);\n        else if (fileType === \"text\") contents = getDataFromTextFile(e);\n        else if (fileType === \"json\") contents = JSON.parse(e.target.result);\n        else setOpenErrorSnackbar(true);\n\n        const result = await getValidationResults([entityToGet], contents, client);\n        setQueryTermsResults(formatQueryTermsResults(result));\n        setActiveStep(1);\n      };\n    },\n  });\n\n  function getDataFromSpreadsheet(file) {\n    const wb = XLSX.read(file.target.result, { type: \"binary\", bookVBA: true });\n    /* Get first worksheet */\n    const wsname = wb.SheetNames[0];\n    const ws = wb.Sheets[wsname];\n    /* Convert array of arrays */\n    const data = XLSX.utils.sheet_to_json(ws);\n\n    if (!Object.prototype.hasOwnProperty.call(data[0], \"id\")) {\n      setOpenErrorSnackbar(true);\n      console.error(\n        \"Please ensure the uploaded file is in the correct format (see allowed file types and example format)\"\n      );\n    }\n\n    const terms = data.map((item) => item.id);\n    return terms;\n  }\n\n  function getDataFromTextFile(file) {\n    const contents = file.target.result;\n    const terms = contents.split(\"\\n\");\n    return terms;\n  }\n\n  function getFileType(fileName) {\n    const fileType = fileName.split(\".\").pop();\n    switch (fileType) {\n      case \"csv\":\n        return \"spreadsheet\";\n      case \"tsv\":\n        return \"spreadsheet\";\n      case \"xlsx\":\n        return \"spreadsheet\";\n      case \"txt\":\n        return \"text\";\n      case \"json\":\n        return \"json\";\n      default:\n        return fileType;\n    }\n  }\n\n  const handleRunExample = async (terms) => {\n    const result = await getValidationResults([entityToGet], terms, client);\n    setQueryTermsResults(formatQueryTermsResults(result));\n    setActiveStep(1);\n  };\n\n  const entityToUploadLabel = getEntityToUploadLabel[entityToGet];\n\n  const handlePinElements = () => {\n    setActiveStep((prevActiveStep) => prevActiveStep + 1);\n    const allHits = [];\n    for (let index = 0; index < queryTermsResults.length; index++) {\n      const term = queryTermsResults[index];\n      for (let r = 0; r < term.hits.length; r++) {\n        const hit = term.hits[r];\n        if (hit.checked) allHits.push(hit.id);\n      }\n    }\n    setUploadedEntries([...uploadedEntries, ...allHits]);\n    handleClosePopover();\n  };\n\n  const handleBack = () => {\n    if (activeStep < 1) handleClosePopover();\n    else setActiveStep((prevActiveStep) => prevActiveStep - 1);\n  };\n\n  const handleReset = () => {\n    setActiveStep(0);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"downloader-popover\" : undefined;\n\n  const handleClickBTN = (event) => {\n    // parentAction();\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClosePopover = () => {\n    setAnchorEl(null);\n    setQueryTermsResults(null);\n    handleReset();\n  };\n\n  function handleParentChange(term) {\n    const checkboxUpdateState = [...queryTermsResults];\n    checkboxUpdateState.find((hitItem) => {\n      if (hitItem.term === term) {\n        hitItem.hits.every((el) => !el.checked)\n          ? hitItem.hits.map((el) => (el.checked = true))\n          : hitItem.hits.map((el) => (el.checked = false));\n      }\n    });\n    setQueryTermsResults(checkboxUpdateState);\n  }\n\n  function handleChangeChildCheckbox(hitId) {\n    const checkboxUpdateState = [...queryTermsResults];\n    checkboxUpdateState.find((hitItem) => {\n      hitItem.hits.find((el) => {\n        if (el.id === hitId) return (el.checked = !el.checked);\n      });\n    });\n    setQueryTermsResults(checkboxUpdateState);\n  }\n\n  function handleCloseErrorSnackbar() {\n    setOpenErrorSnackbar(false);\n  }\n\n  return (\n    <div>\n      <UploadButton\n        aria-describedby={popoverId}\n        onClick={handleClickBTN}\n        disableElevation\n        sx={{ height: 1, maxHeight: \"45px\" }}\n        aria-label=\"Upload list of entities\"\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFileImport} size=\"lg\" />\n        </Box>\n        {`Upload list of ${entityToUploadLabel}`}\n      </UploadButton>\n      <Dialog\n        onClose={handleClosePopover}\n        open={open}\n        sx={{\n          \".MuiDialog-paper\": {\n            width: \"70%\",\n            maxWidth: \"800px !important\",\n            borderRadius: (theme) => theme.spacing(1),\n          },\n        }}\n      >\n        <DialogTitle>{`Upload list of ${entityToUploadLabel}`}</DialogTitle>\n        <DialogContent sx={{ pb: 0, overflowY: \"scroll\" }} dividers>\n          <Typography\n            sx={{ m: (theme) => `${theme.spacing(1)} 0 ${theme.spacing(4)} 0` }}\n            variant=\"subtitle2\"\n            gutterBottom\n          >\n            Please upload a file here (allowed file formats - .txt / .csv / .tsv / .xlsx / .json)\n            containing your custom list of targets/diseases. The file should contain a single{\" \"}\n            {entityToGet} in every row. You will be able to visualise all the potential matches upon\n            validation of your input.\n            <br />\n            <Link\n              to=\"https://platform-docs.opentargets.org/web-interface/associations-on-the-fly#upload-functionality\"\n              external\n            >\n              Read more details here.\n            </Link>\n          </Typography>\n          {activeStep === 0 && <FileExample entity={entityToGet} runAction={handleRunExample} />}\n          <Box sx={{ m: (theme) => `${theme.spacing(1)} 0 ${theme.spacing(4)} 0` }}>\n            <Stepper activeStep={activeStep}>\n              {steps.map((label) => {\n                const stepProps = {};\n                const labelProps = {};\n                return (\n                  <Step key={label} {...stepProps}>\n                    <StepLabel {...labelProps}>{label}</StepLabel>\n                  </Step>\n                );\n              })}\n            </Stepper>\n          </Box>\n\n          {activeStep === 0 && (\n            <StyledContainer>\n              <div {...getRootProps({ className: \"dropzone\" })}>\n                <input {...getInputProps()} />\n                <p>Drag and drop a file here, or click to select file (see example format).</p>\n              </div>\n            </StyledContainer>\n          )}\n          {activeStep === 1 && (\n            <Box>\n              <Box sx={{ overflowY: \"scroll\" }}>\n                <List\n                  sx={{ width: \"100%\", maxWidth: 1, bgcolor: \"background.paper\" }}\n                  aria-labelledby=\"nested-list-subheader\"\n                  subheader={\n                    <ListSubheader sx={{ px: 1.5 }} component=\"div\" id=\"nested-list-subheader\">\n                      Validation mappings ( Upload count: {queryTermsResults.length})\n                    </ListSubheader>\n                  }\n                >\n                  {queryTermsResults.map(({ term, hits }) => (\n                    <NestedItem\n                      key={v1()}\n                      hits={hits}\n                      term={term}\n                      handleParentChange={handleParentChange}\n                      handleChangeChildCheckbox={handleChangeChildCheckbox}\n                    >\n                      {`${term} (${hits.length} hits)`}\n                    </NestedItem>\n                  ))}\n                </List>\n              </Box>\n            </Box>\n          )}\n        </DialogContent>\n\n        <DialogActions>\n          <Box sx={{ display: \"flex\", justifyContent: \"space-between\", mx: 2, my: 1, width: 1 }}>\n            <Button\n              aria-describedby={popoverId}\n              variant=\"outlined\"\n              disableElevation\n              startIcon={<FontAwesomeIcon icon={faChevronLeft} size=\"lg\" />}\n              onClick={handleBack}\n            >\n              Back\n            </Button>\n            {activeStep === 1 && (\n              <Button\n                aria-describedby={popoverId}\n                variant=\"outlined\"\n                disableElevation\n                startIcon={<FontAwesomeIcon icon={faCheck} size=\"lg\" />}\n                onClick={handlePinElements}\n              >\n                Upload hits\n              </Button>\n            )}\n          </Box>\n        </DialogActions>\n      </Dialog>\n      <Snackbar\n        open={openErrorSnackbar}\n        autoHideDuration={10000}\n        onClose={handleCloseErrorSnackbar}\n        message={\n          <Box sx={{ display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\" }}>\n            Please ensure the uploaded file has id in column header (see example format)\n            <IconButton sx={{ color: \"white\" }} onClick={handleCloseErrorSnackbar}>\n              <FontAwesomeIcon icon={faXmark} />\n            </IconButton>\n          </Box>\n        }\n      />\n    </div>\n  );\n}\n\nexport default DataUploader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/Table/TableAssociations.jsx"
        },
        "span": [3452, 4303],
        "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: associationsColorScale",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: associationsColorScale"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6119, 6141],
              "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5447, 5469],
              "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/Table/TableAssociations.jsx"
        },
        "span": [5107, 5114],
        "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: isAssociations",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: isAssociations"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6362, 6376],
              "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/Table/TableAssociations.jsx"
        },
        "span": [5107, 5114],
        "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: displayedTable",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: displayedTable"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6450, 6464],
              "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/components/Table/TableAssociations.jsx"
        },
        "span": [5107, 5114],
        "sourceCode": "import { createColumnHelper, getCoreRowModel, useReactTable } from \"@tanstack/react-table\";\nimport { useEffect, useMemo, useState } from \"react\";\n\nimport { Box, Collapse, Typography, styled } from \"@mui/material\";\n\nimport dataSourcesCols from \"../../static_datasets/dataSourcesAssoc\";\nimport prioritizationCols from \"../../static_datasets/prioritisationColumns\";\n\nimport HeaderControls from \"../HeaderControls\";\nimport AggregationsTooltip from \"./AssocTooltip\";\nimport CellName from \"./CellName\";\nimport TableBody from \"./TableBody\";\nimport TableCell from \"./TableCell\";\nimport TableFooter from \"./TableFooter\";\nimport TableHeader from \"./TableHeader\";\n\nimport useAotfContext from \"../../hooks/useAotfContext\";\n\nimport { faCaretDown, faCaretRight, faTrash } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport {\n  TABLE_PREFIX,\n  getScale,\n  isPartnerPreview,\n  tableCSSVariables,\n} from \"../../associationsUtils\";\n\nconst TableElement = styled(\"main\")({\n  maxWidth: \"1800px\",\n  margin: \"0 auto\",\n});\n\nconst TableSpacer = styled(\"div\")({\n  marginBottom: 5,\n});\n\nconst getIndicatorLabel = (prefix) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return \"All\";\n    case TABLE_PREFIX.PINNING:\n      return \"Pinned\";\n    case TABLE_PREFIX.UPLOADED:\n      return \"Uploaded\";\n    default:\n      return \"\";\n  }\n};\n\nconst getIndicatorCount = (prefix, count, filteredCount) => {\n  switch (prefix) {\n    case TABLE_PREFIX.CORE:\n      return count;\n    default:\n      return `${filteredCount} of ${count}`;\n  }\n};\n\nconst TableIndicatorControl = ({\n  prefix = \"\",\n  open = true,\n  count = 0,\n  filteredCount = 0,\n  onClickToggle,\n  onClickDelete,\n}) => {\n  const label = getIndicatorLabel(prefix);\n  const countLabel = getIndicatorCount(prefix, count, filteredCount);\n  return (\n    <Box sx={{ display: \"flex\", my: 1, gap: 1, alignItems: \"center\" }}>\n      {prefix !== TABLE_PREFIX.CORE && (\n        <Box onClick={onClickDelete} sx={{ color: grey[600], cursor: \"pointer\" }}>\n          <FontAwesomeIcon size=\"sm\" icon={faTrash} />\n        </Box>\n      )}\n      <Box\n        onClick={onClickToggle}\n        sx={{\n          ml: prefix === TABLE_PREFIX.CORE ? \"20px\" : 0,\n          cursor: \"pointer\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n          background: grey[300],\n          width: \"150px\",\n          px: \"6px\",\n          borderRadius: \"2px\",\n        }}\n      >\n        <Typography variant=\"caption\" sx={{ fontWeight: 600 }}>\n          {`${label} (${countLabel})`}\n        </Typography>\n        <Box ml={1}>\n          {open ? <FontAwesomeIcon icon={faCaretDown} /> : <FontAwesomeIcon icon={faCaretRight} />}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nconst columnHelper = createColumnHelper();\n\nconst evidenceViewColumns = getDatasources({\n  displayedTable: \"associations\",\n  colorScale: getScale(true),\n});\nconst prioritisationViewColumns = getDatasources({\n  displayedTable: \"prioritisations\",\n  colorScale: getScale(false),\n});\n\n/* Build table columns bases on displayed table */\nfunction getDatasources({ displayedTable, colorScale }) {\n  const isAssociations = displayedTable === \"associations\";\n  const baseCols = isAssociations ? dataSourcesCols : prioritizationCols;\n  const dataProp = isAssociations ? \"dataSources\" : \"prioritisations\";\n  const datasources = [];\n  baseCols.forEach(({ id, label, sectionId, description, aggregation, isPrivate, docsLink }) => {\n    if (isPrivate && isPrivate !== isPartnerPreview) return;\n    const column = columnHelper.accessor((row) => row[dataProp][id], {\n      id,\n      sectionId,\n      enableSorting: isAssociations,\n      aggregation,\n      isPrivate,\n      docsLink,\n      header: isAssociations ? (\n        <Typography variant=\"assoc_header\">{label}</Typography>\n      ) : (\n        <AggregationsTooltip title={description} placement=\"right\">\n          <div className=\"cursor-help\">\n            <Typography variant=\"assoc_header\">{label}</Typography>\n          </div>\n        </AggregationsTooltip>\n      ),\n      cell: (cell) => (\n        <TableCell cell={cell} colorScale={colorScale} displayedTable={displayedTable} />\n      ),\n    });\n    datasources.push(column);\n  });\n  return datasources;\n}\n\nfunction TableAssociations() {\n  const {\n    entity,\n    entityToGet,\n    data,\n    count,\n    loading: associationsLoading,\n    pagination,\n    handlePaginationChange,\n    displayedTable,\n    sorting,\n    handleSortingChange,\n    pinnedData,\n    pinnedLoading,\n    uploadedData,\n    uploadedLoading,\n    pinnedEntries,\n    uploadedEntries,\n    setUploadedEntries,\n    setPinnedEntries,\n  } = useAotfContext();\n\n  const rowNameEntity = entity === \"target\" ? \"name\" : \"approvedSymbol\";\n  const isAssociations = displayedTable === \"associations\";\n  const associationsColorScale = getScale(true);\n  const [coreOpen, setCoreOpen] = useState(true);\n  const [pinningOpen, setPinningOpen] = useState(true);\n  const [uploadedOpen, setUploadedOpen] = useState(true);\n\n  const columns = useMemo(\n    () => [\n      columnHelper.group({\n        header: \"header\",\n        id: \"naiming-cols\",\n        columns: [\n          columnHelper.accessor((row) => row[entityToGet][rowNameEntity], {\n            id: \"name\",\n            enableSorting: false,\n            cell: (cell) => {\n              return <CellName cell={cell} colorScale={associationsColorScale} />;\n            },\n            header: () => {\n              const label = entityToGet === \"target\" ? \"Target\" : \"Disease\";\n              return <Typography variant=\"assoc_header\">{label}</Typography>;\n            },\n          }),\n          columnHelper.accessor((row) => row.score, {\n            id: \"score\",\n            header: <Typography variant=\"assoc_header\">Association Score</Typography>,\n            cell: (cell) => (\n              <Box sx={{ marginRight: \"10px\" }}>\n                <TableCell\n                  scoreValue={cell.getValue()}\n                  globalScore\n                  shape=\"rectangular\"\n                  colorScale={associationsColorScale}\n                  cell={cell}\n                />\n              </Box>\n            ),\n          }),\n        ],\n      }),\n      columnHelper.group({\n        header: \"entities\",\n        id: \"entity-cols\",\n        columns: isAssociations ? evidenceViewColumns : prioritisationViewColumns,\n      }),\n    ],\n    [displayedTable, entityToGet, rowNameEntity]\n  );\n\n  /**\n   * TABLE HOOK\n   * @description tanstack/react-table\n   */\n  const coreAssociationsTable = useReactTable({\n    data,\n    columns,\n    state: {\n      pagination,\n      sorting,\n      prefix: TABLE_PREFIX.CORE,\n      loading: associationsLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const corePinnedTable = useReactTable({\n    data: pinnedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.PINNING,\n      loading: pinnedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  const coreUploadedTable = useReactTable({\n    data: uploadedData,\n    columns,\n    state: {\n      pagination: {\n        pageIndex: 0,\n        pageSize: 150,\n      },\n      sorting,\n      prefix: TABLE_PREFIX.UPLOADED,\n      loading: uploadedLoading,\n    },\n    pageCount: count,\n    onPaginationChange: handlePaginationChange,\n    onSortingChange: handleSortingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getRowId: (row) => row[entityToGet].id,\n    manualPagination: true,\n    manualSorting: true,\n  });\n\n  useEffect(() => {\n    if (uploadedEntries.length > 0) {\n      setCoreOpen(false);\n      setUploadedOpen(true);\n    }\n    if (uploadedEntries.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [uploadedEntries]);\n\n  useEffect(() => {\n    if (pinnedData.length === 0 && uploadedData.length === 0) {\n      setCoreOpen(true);\n    }\n  }, [pinnedData, uploadedData]);\n\n  const onClickPinnedIndicator = () => {\n    setPinningOpen(!pinningOpen);\n  };\n  const onClickUploadedIndicator = () => {\n    setUploadedOpen(!uploadedOpen);\n  };\n  const onClickCoreIndicator = () => {\n    setCoreOpen(!coreOpen);\n  };\n\n  const onClickPinnedDeleteAll = () => {\n    setPinnedEntries([]);\n  };\n  const onClickUploadedDeleteAll = () => {\n    setUploadedEntries([]);\n  };\n\n  const entitesHeaders = coreAssociationsTable.getHeaderGroups()[0].headers[1].subHeaders;\n  return (\n    <div className=\"TAssociations\" style={tableCSSVariables}>\n      <TableElement>\n        {/* HEADER */}\n        <TableHeader table={coreAssociationsTable} cols={entitesHeaders} />\n\n        {/* Weights controlls */}\n        <HeaderControls cols={entitesHeaders} />\n\n        <TableSpacer />\n\n        {/* Pinning */}\n        {pinnedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.PINNING}\n            count={pinnedEntries.length}\n            filteredCount={corePinnedTable.getRowCount()}\n            open={pinningOpen}\n            onClickToggle={onClickPinnedIndicator}\n            onClickDelete={onClickPinnedDeleteAll}\n          />\n        )}\n        {pinnedData.length > 0 && pinnedEntries.length > 0 && (\n          <Collapse in={pinningOpen}>\n            <TableBody core={corePinnedTable} prefix={TABLE_PREFIX.PINNING} cols={entitesHeaders} />\n          </Collapse>\n        )}\n        {/* Upload */}\n        {uploadedEntries.length > 0 && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.UPLOADED}\n            count={uploadedEntries.length}\n            filteredCount={coreUploadedTable.getRowCount()}\n            open={uploadedOpen}\n            onClickToggle={onClickUploadedIndicator}\n            onClickDelete={onClickUploadedDeleteAll}\n          />\n        )}\n        {coreUploadedTable.getRowCount() > 0 && uploadedEntries.length > 0 && (\n          <Collapse in={uploadedOpen}>\n            <TableBody\n              core={coreUploadedTable}\n              prefix={TABLE_PREFIX.UPLOADED}\n              cols={entitesHeaders}\n            />\n          </Collapse>\n        )}\n        {/* Core */}\n        {(uploadedEntries.length > 0 || pinnedEntries.length > 0) && (\n          <TableIndicatorControl\n            prefix={TABLE_PREFIX.CORE}\n            count={count}\n            open={coreOpen}\n            onClickToggle={onClickCoreIndicator}\n          />\n        )}\n\n        {coreOpen && (\n          <TableBody\n            core={coreAssociationsTable}\n            prefix={TABLE_PREFIX.CORE}\n            cols={entitesHeaders}\n          />\n        )}\n\n        {/* FOOTER */}\n        <TableFooter table={coreAssociationsTable} coreOpen={coreOpen} />\n      </TableElement>\n    </div>\n  );\n}\n\nexport default TableAssociations;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noUnreachable",
      "severity": "error",
      "description": "This code is unreachable",
      "message": [{ "elements": [], "content": "This code will never be reached ..." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "... because this statement will throw an exception beforehand"
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4718, 4759],
              "sourceCode": "import type { DocumentNode } from \"graphql\";\nimport { isEqual } from \"lodash\";\nimport {\n  DEFAULT_TABLE_PAGINATION_STATE,\n  DEFAULT_TABLE_SORTING_STATE,\n  defaulDatasourcesWeigths,\n} from \"../associationsUtils\";\nimport { type Action, ActionType, ENTITY, type State, TABLE_VIEW } from \"../types\";\n\n/*****************\n * INITIAL STATE *\n *****************/\n\nexport const initialState: State = {\n  pagination: DEFAULT_TABLE_PAGINATION_STATE,\n  loading: false,\n  query: null,\n  parentId: \"\",\n  enableIndirect: false,\n  sorting: DEFAULT_TABLE_SORTING_STATE,\n  parentEntity: null, // TODO: review initial state\n  rowEntity: null,\n  tableView: TABLE_VIEW.MAIN,\n  isMainView: true,\n  searchFilter: \"\",\n  advanceOptionsOpen: false,\n  pinnedEntities: [],\n  bodyData: [],\n  pinnedData: [],\n  interactors: new Map(),\n  dataSourceControls: defaulDatasourcesWeigths,\n  modifiedSourcesDataControls: false,\n  facetFilters: [],\n  facetFiltersIds: [],\n  entitySearch: \"\",\n};\n\ntype InitialStateParams = {\n  parentEntity: ENTITY;\n  parentId: string;\n  query: DocumentNode;\n};\n\nexport function createInitialState({ parentEntity, parentId, query }: InitialStateParams): State {\n  const rowEntity = parentEntity === ENTITY.TARGET ? ENTITY.DISEASE : ENTITY.TARGET;\n  const state = { ...initialState, query, parentId, parentEntity, rowEntity };\n  return state;\n}\n\nexport function aotfReducer(state: State, action: Action): State {\n  if (typeof state === \"undefined\") {\n    throw Error(\"State provied to aotfReducer is undefined\");\n  }\n  switch (action.type) {\n    case ActionType.PAGINATE: {\n      return {\n        ...state,\n        pagination: action.pagination,\n      };\n    }\n    case ActionType.RESET_PAGINATION: {\n      return {\n        ...state,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.SORTING: {\n      return {\n        ...state,\n        sorting: action.sorting,\n      };\n    }\n    case ActionType.SET_INTERACTORS: {\n      const currentInteractors = state.interactors;\n      if (typeof currentInteractors === \"undefined\" || !currentInteractors) return { ...state };\n      const payloadInteractor = action.payload;\n\n      // Todo: review\n      if (currentInteractors.has(payloadInteractor.id)) {\n        const row = currentInteractors.get(payloadInteractor.id);\n        row?.push(payloadInteractor.source);\n        currentInteractors.set(payloadInteractor.id, row);\n      }\n\n      currentInteractors.set(payloadInteractor.id, [payloadInteractor.source]);\n\n      return {\n        ...state,\n        interactors: currentInteractors,\n      };\n    }\n    case ActionType.DATA_SOURCE_CONTROL: {\n      const colUpdatedControls = { ...action.payload };\n      const dataSourceControls = state.dataSourceControls.map((col) => {\n        if (col.id === colUpdatedControls.id) return colUpdatedControls;\n        return col;\n      });\n      const modifiedSourcesDataControls = !isEqual(defaulDatasourcesWeigths, dataSourceControls);\n      return {\n        ...state,\n        dataSourceControls,\n        modifiedSourcesDataControls,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.RESET_DATA_SOURCE_CONTROL: {\n      return {\n        ...state,\n        dataSourceControls: defaulDatasourcesWeigths,\n        modifiedSourcesDataControls: false,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.HANDLE_AGGREGATION_CLICK: {\n      const aggregation = action.aggregation;\n\n      const isAllActive = state.dataSourceControls\n        .filter((el) => el.aggregation === aggregation)\n        .every((el) => el.required);\n      const isAnyOtherActive = state.dataSourceControls\n        .filter((el) => el.aggregation !== aggregation)\n        .some((el) => el.required);\n      const dataSourceControls = state.dataSourceControls.map((col) => {\n        if (col.aggregation === aggregation) {\n          return {\n            ...col,\n            required: !isAllActive,\n          };\n        }\n        return col;\n      });\n      return {\n        ...state,\n        dataSourceControls,\n        modifiedSourcesDataControls: !isAllActive || isAnyOtherActive,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.FACETS_SEARCH: {\n      return {\n        ...state,\n        facetFilters: action.facetFilters,\n        facetFiltersIds: action.facetFiltersIds,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n\n    case ActionType.ENTITY_SEARCH: {\n      return {\n        ...state,\n        entitySearch: action.entitySearch,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.SET_INITIAL_STATE: {\n      return {\n        ...initialState,\n      };\n    }\n    default: {\n      throw Error(`Unknown action: ${action}`);\n      return state;\n    }\n  }\n}\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/aotfReducer.ts"
        },
        "span": [4766, 4779],
        "sourceCode": "import type { DocumentNode } from \"graphql\";\nimport { isEqual } from \"lodash\";\nimport {\n  DEFAULT_TABLE_PAGINATION_STATE,\n  DEFAULT_TABLE_SORTING_STATE,\n  defaulDatasourcesWeigths,\n} from \"../associationsUtils\";\nimport { type Action, ActionType, ENTITY, type State, TABLE_VIEW } from \"../types\";\n\n/*****************\n * INITIAL STATE *\n *****************/\n\nexport const initialState: State = {\n  pagination: DEFAULT_TABLE_PAGINATION_STATE,\n  loading: false,\n  query: null,\n  parentId: \"\",\n  enableIndirect: false,\n  sorting: DEFAULT_TABLE_SORTING_STATE,\n  parentEntity: null, // TODO: review initial state\n  rowEntity: null,\n  tableView: TABLE_VIEW.MAIN,\n  isMainView: true,\n  searchFilter: \"\",\n  advanceOptionsOpen: false,\n  pinnedEntities: [],\n  bodyData: [],\n  pinnedData: [],\n  interactors: new Map(),\n  dataSourceControls: defaulDatasourcesWeigths,\n  modifiedSourcesDataControls: false,\n  facetFilters: [],\n  facetFiltersIds: [],\n  entitySearch: \"\",\n};\n\ntype InitialStateParams = {\n  parentEntity: ENTITY;\n  parentId: string;\n  query: DocumentNode;\n};\n\nexport function createInitialState({ parentEntity, parentId, query }: InitialStateParams): State {\n  const rowEntity = parentEntity === ENTITY.TARGET ? ENTITY.DISEASE : ENTITY.TARGET;\n  const state = { ...initialState, query, parentId, parentEntity, rowEntity };\n  return state;\n}\n\nexport function aotfReducer(state: State, action: Action): State {\n  if (typeof state === \"undefined\") {\n    throw Error(\"State provied to aotfReducer is undefined\");\n  }\n  switch (action.type) {\n    case ActionType.PAGINATE: {\n      return {\n        ...state,\n        pagination: action.pagination,\n      };\n    }\n    case ActionType.RESET_PAGINATION: {\n      return {\n        ...state,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.SORTING: {\n      return {\n        ...state,\n        sorting: action.sorting,\n      };\n    }\n    case ActionType.SET_INTERACTORS: {\n      const currentInteractors = state.interactors;\n      if (typeof currentInteractors === \"undefined\" || !currentInteractors) return { ...state };\n      const payloadInteractor = action.payload;\n\n      // Todo: review\n      if (currentInteractors.has(payloadInteractor.id)) {\n        const row = currentInteractors.get(payloadInteractor.id);\n        row?.push(payloadInteractor.source);\n        currentInteractors.set(payloadInteractor.id, row);\n      }\n\n      currentInteractors.set(payloadInteractor.id, [payloadInteractor.source]);\n\n      return {\n        ...state,\n        interactors: currentInteractors,\n      };\n    }\n    case ActionType.DATA_SOURCE_CONTROL: {\n      const colUpdatedControls = { ...action.payload };\n      const dataSourceControls = state.dataSourceControls.map((col) => {\n        if (col.id === colUpdatedControls.id) return colUpdatedControls;\n        return col;\n      });\n      const modifiedSourcesDataControls = !isEqual(defaulDatasourcesWeigths, dataSourceControls);\n      return {\n        ...state,\n        dataSourceControls,\n        modifiedSourcesDataControls,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.RESET_DATA_SOURCE_CONTROL: {\n      return {\n        ...state,\n        dataSourceControls: defaulDatasourcesWeigths,\n        modifiedSourcesDataControls: false,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.HANDLE_AGGREGATION_CLICK: {\n      const aggregation = action.aggregation;\n\n      const isAllActive = state.dataSourceControls\n        .filter((el) => el.aggregation === aggregation)\n        .every((el) => el.required);\n      const isAnyOtherActive = state.dataSourceControls\n        .filter((el) => el.aggregation !== aggregation)\n        .some((el) => el.required);\n      const dataSourceControls = state.dataSourceControls.map((col) => {\n        if (col.aggregation === aggregation) {\n          return {\n            ...col,\n            required: !isAllActive,\n          };\n        }\n        return col;\n      });\n      return {\n        ...state,\n        dataSourceControls,\n        modifiedSourcesDataControls: !isAllActive || isAnyOtherActive,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.FACETS_SEARCH: {\n      return {\n        ...state,\n        facetFilters: action.facetFilters,\n        facetFiltersIds: action.facetFiltersIds,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n\n    case ActionType.ENTITY_SEARCH: {\n      return {\n        ...state,\n        entitySearch: action.entitySearch,\n        pagination: DEFAULT_TABLE_PAGINATION_STATE,\n      };\n    }\n    case ActionType.SET_INITIAL_STATE: {\n      return {\n        ...initialState,\n      };\n    }\n    default: {\n      throw Error(`Unknown action: ${action}`);\n      return state;\n    }\n  }\n}\n"
      },
      "tags": ["unnecessaryCode"],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/hooks/useAssociationsData.js"
        },
        "span": [1693, 1710],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client.query",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: client.query"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [933, 945],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/hooks/useAssociationsData.js"
        },
        "span": [757, 766],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: rowsFilter",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: rowsFilter"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1294, 1304],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/hooks/useAssociationsData.js"
        },
        "span": [757, 766],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: filter",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: filter" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1041, 1047],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/hooks/useAssociationsData.js"
        },
        "span": [757, 766],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: state",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: state" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [865, 870],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/hooks/useAssociationsData.js"
        },
        "span": [757, 766],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noConstantCondition",
      "severity": "error",
      "description": "Unexpected constant condition.",
      "message": [{ "elements": [], "content": "Unexpected constant condition." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/hooks/useAssociationsData.js"
        },
        "span": [1656, 1660],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { getAllDataCount, getAssociationsData, getInitialLoadingData } from \"../associationsUtils\";\n\nconst INITIAL_ROW_COUNT = 25;\n\nconst getInitialState = (rowCount) => ({\n  loading: true,\n  error: false,\n  data: getInitialLoadingData(rowCount),\n  initialLoading: true,\n  count: 0,\n});\n\n/********\n * HOOK *\n ********/\nfunction useAssociationsData({\n  client,\n  query,\n  options: {\n    id = \"\",\n    index = 0,\n    size = 50,\n    filter = \"\",\n    sortBy = \"score\",\n    enableIndirect = false,\n    datasources = [],\n    rowsFilter = [],\n    entity,\n    facetFilters = [],\n    entitySearch = \"\",\n    laodingCount = INITIAL_ROW_COUNT,\n  },\n}) {\n  const [state, setState] = useState(getInitialState(laodingCount));\n  useEffect(() => {\n    let isCurrent = true;\n    const fetchData = async () => {\n      setState({\n        ...state,\n        loading: true,\n      });\n      const resData = await client.query({\n        query,\n        variables: {\n          id,\n          index,\n          size,\n          filter,\n          sortBy,\n          enableIndirect,\n          datasources: datasources.map((el) => ({\n            id: el.id,\n            weight: el.weight,\n            propagate: el.propagate,\n            required: el.required,\n          })),\n          rowsFilter,\n          facetFilters,\n          entitySearch,\n        },\n      });\n      const parsedData = getAssociationsData(entity, resData.data);\n      const dataCount = getAllDataCount(entity, resData.data);\n\n      setState({\n        count: dataCount,\n        data: parsedData,\n        loading: false,\n        initialLoading: false,\n      });\n    };\n    if (true) fetchData();\n    return () => (isCurrent = false);\n  }, [\n    id,\n    index,\n    size,\n    sortBy,\n    enableIndirect,\n    datasources,\n    query,\n    entity,\n    facetFilters,\n    entitySearch,\n  ]);\n\n  return state;\n}\n\nexport default useAssociationsData;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: id",
      "message": [
        { "elements": [], "content": "This hook specifies more dependencies than necessary: id" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Outer scope values aren't valid dependencies because mutating them doesn't re-render the component."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3563, 3565],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [3409, 3418],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: setSorting",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: setSorting"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3963, 3973],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [3892, 3903],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: facetFilterSelect",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: facetFilterSelect"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5574, 5591],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [4725, 4732],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: resetDatasourceControls",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: resetDatasourceControls"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5341, 5364],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [4725, 4732],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: dispatch",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: dispatch"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5806, 5814],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [4725, 4732],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: updateDataSourceControls",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: updateDataSourceControls"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5542, 5566],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [4725, 4732],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: handleAggregationClick",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: handleAggregationClick"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5512, 5534],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [4725, 4732],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: resetToInitialPagination",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: resetToInitialPagination"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5285, 5309],
              "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsStateContext.jsx"
        },
        "span": [4725, 4732],
        "sourceCode": "import {\n  createContext,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\nimport { useApolloClient, useStateParams } from \"ui\";\nimport { DEFAULT_TABLE_SORTING_STATE, DISPLAY_MODE, ENTITIES } from \"../associationsUtils\";\n\nimport useAssociationsData from \"../hooks/useAssociationsData\";\nimport {\n  aggregationClick,\n  facetFilterSelectAction,\n  onPaginationChange,\n  resetDataSourceControl,\n  resetPagination,\n  resetToInitialState,\n  setDataSourceControl,\n} from \"./aotfActions\";\nimport { aotfReducer, createInitialState } from \"./aotfReducer\";\n\nconst AssociationsStateContext = createContext();\n\nconst initialIndirect = (entity) => entity !== ENTITIES.TARGET;\nconst rowEntity = { [ENTITIES.TARGET]: ENTITIES.DISEASE, [ENTITIES.DISEASE]: ENTITIES.TARGET };\n\n/**\n * Associations on the fly state Provider\n */\nfunction AssociationsStateProvider({ children, entity, id, query }) {\n  const [state, dispatch] = useReducer(\n    aotfReducer,\n    { query, parentEntity: entity, parentId: id },\n    createInitialState\n  );\n\n  const hasComponentBeenRender = useRef(false);\n\n  const client = useApolloClient();\n\n  // Data controls\n  const [enableIndirect, setEnableIndirect] = useState(initialIndirect(entity));\n  const [sorting, setSorting] = useState(DEFAULT_TABLE_SORTING_STATE);\n\n  // Data controls UI\n  const [activeHeadersControlls, setActiveHeadersControlls] = useState(false);\n\n  // only two posible (associations || prioritisations)\n  const [displayedTable, setDisplayedTable] = useStateParams(\n    DISPLAY_MODE.ASSOCIATIONS,\n    \"table\",\n    (arr) => arr,\n    (str) => str\n  );\n\n  const [pinnedEntries, setPinnedEntries] = useStateParams(\n    [],\n    \"pinned\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const [uploadedEntries, setUploadedEntries] = useStateParams(\n    [],\n    \"uploaded\",\n    (arr) => arr.join(\",\"),\n    (str) => str.split(\",\")\n  );\n\n  const entityToGet = rowEntity[entity];\n\n  const { data, initialLoading, loading, error, count } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      index: state.pagination.pageIndex,\n      size: state.pagination.pageSize,\n      sortBy: sorting[0].id,\n      enableIndirect,\n      datasources: state.dataSourceControls,\n      entity,\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n    },\n  });\n\n  const {\n    data: pinnedData,\n    loading: pinnedLoading,\n    error: pinnedError,\n    count: pinnedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: pinnedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: pinnedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: pinnedEntries.length,\n    },\n  });\n\n  const {\n    data: uploadedData,\n    loading: uploadedLoading,\n    error: uploadedError,\n    count: uploadedCount,\n  } = useAssociationsData({\n    client,\n    query,\n    options: {\n      id,\n      enableIndirect,\n      entity,\n      size: uploadedEntries.length,\n      sortBy: sorting[0].id,\n      datasources: state.dataSourceControls,\n      rowsFilter: uploadedEntries.toSorted(),\n      facetFilters: state.facetFiltersIds,\n      entitySearch: state.entitySearch,\n      laodingCount: uploadedEntries.length,\n    },\n  });\n\n  useEffect(() => {\n    if (hasComponentBeenRender.current) {\n      dispatch(resetToInitialState());\n    }\n    hasComponentBeenRender.current = true;\n  }, [id]);\n\n  const handleAggregationClick = (aggregation) => {\n    dispatch(aggregationClick(aggregation));\n  };\n\n  const handlePaginationChange = useCallback(\n    (updater) => {\n      const newPagination = updater(state.pagination);\n      dispatch(onPaginationChange(newPagination));\n    },\n    [state]\n  );\n\n  const resetSorting = useCallback(() => {\n    setSorting(DEFAULT_TABLE_SORTING_STATE);\n  }, [setSorting]);\n\n  const handleSortingChange = useCallback(\n    (newSortingFunc) => {\n      const newSorting = newSortingFunc();\n      if (newSorting[0].id === sorting[0].id) {\n        setSorting(DEFAULT_TABLE_SORTING_STATE);\n        return;\n      }\n      setSorting(newSorting);\n    },\n    [sorting]\n  );\n\n  const resetDatasourceControls = () => {\n    dispatch(resetDataSourceControl());\n  };\n\n  const resetToInitialPagination = () => {\n    dispatch(resetPagination());\n  };\n\n  const updateDataSourceControls = (id, weight, required, aggregation) => {\n    dispatch(setDataSourceControl(id, weight, required, aggregation));\n  };\n\n  const facetFilterSelect = (facetFilters) => {\n    dispatch(facetFilterSelectAction(facetFilters));\n  };\n\n  const contextVariables = useMemo(\n    () => ({\n      dispatch,\n      query,\n      id,\n      entity,\n      entityToGet,\n      count,\n      data,\n      loading,\n      initialLoading,\n      pagination: state.pagination,\n      activeHeadersControlls,\n      enableIndirect,\n      error,\n      dataSourcesWeights: state.dataSourceControls,\n      displayedTable,\n      pinnedData,\n      sorting,\n      modifiedSourcesDataControls: state.modifiedSourcesDataControls,\n      entitySearch: state.entitySearch,\n      pinnedLoading,\n      pinnedError,\n      pinnedCount,\n      pinnedEntries,\n      resetToInitialPagination,\n      setPinnedEntries,\n      resetDatasourceControls,\n      handleSortingChange,\n      setDisplayedTable,\n      handlePaginationChange,\n      setEnableIndirect,\n      setActiveHeadersControlls,\n      handleAggregationClick,\n      updateDataSourceControls,\n      facetFilterSelect,\n      state,\n      setUploadedEntries,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    }),\n    [\n      setUploadedEntries,\n      dispatch,\n      activeHeadersControlls,\n      count,\n      data,\n      displayedTable,\n      enableIndirect,\n      entity,\n      entityToGet,\n      error,\n      handleSortingChange,\n      id,\n      initialLoading,\n      loading,\n      state,\n      pinnedCount,\n      pinnedData,\n      pinnedEntries,\n      pinnedError,\n      pinnedLoading,\n      query,\n      setDisplayedTable,\n      setPinnedEntries,\n      sorting,\n      handlePaginationChange,\n      uploadedData,\n      uploadedLoading,\n      uploadedError,\n      uploadedCount,\n      uploadedEntries,\n      resetSorting,\n    ]\n  );\n\n  return (\n    <AssociationsStateContext.Provider value={contextVariables}>\n      {children}\n    </AssociationsStateContext.Provider>\n  );\n}\n\nexport default AssociationsStateContext;\nexport { AssociationsStateProvider };\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsFocusContext.tsx"
        },
        "span": [3410, 3893],
        "sourceCode": "import {\n  type Dispatch,\n  type ReactElement,\n  createContext,\n  useContext,\n  useEffect,\n  useReducer,\n} from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  INTERACTORS_SOURCE_THRESHOLD,\n  type InteractorsSource,\n  TABLE_PREFIX,\n} from \"../associationsUtils\";\nimport useAotfContext from \"../hooks/useAotfContext\";\n\nexport type FocusElementTable = \"core\" | \"pinned\" | \"upload\";\n\nexport type FocusElement = {\n  table: FocusElementTable;\n  row: string;\n  interactorsRow: string | null;\n  interactorsSource: InteractorsSource | null;\n  interactors: boolean;\n  section: null | [string, string];\n  interactorsSection: null | [string, string];\n  interactorsThreshold: number | null;\n};\n\nexport type FocusState = FocusElement[];\n\nexport enum FocusActionType {\n  RESET = \"RESET\",\n  SET_INTERACTORS_ON = \"SET_INTERACTORS_ON\",\n  SET_INTERACTORS_OFF = \"SET_INTERACTORS_OFF\",\n  SET_INTERACTORS_SECTION = \"SET_INTERACTORS_SECTION\",\n  SET_INTERACTORS_THRESHOLD = \"SET_INTERACTORS_THRESHOLD\",\n  CLEAR_INTERACTORS_SECTION = \"CLEAR_INTERACTORS_SECTION\",\n  SET_FOCUS_SECTION = \"SET_FOCUS_SECTION\",\n  CLEAR_FOCUS_CONTEXT_MENU = \"CLEAR_FOCUS_CONTEXT_MENU\",\n  SET_FOCUS_CONTEXT_MENU = \"SET_FOCUS_CONTEXT_MENU\",\n  SET_INTERACTORS_SOURCE = \"SET_INTERACTORS_SOURCE\",\n}\n\nexport type FocusAction =\n  | { type: FocusActionType.RESET }\n  | {\n      type: FocusActionType.SET_FOCUS_CONTEXT_MENU;\n      focus: { row: string; table: FocusElementTable };\n    }\n  | {\n      type: FocusActionType.CLEAR_FOCUS_CONTEXT_MENU;\n      focus: { row: string; table: FocusElementTable };\n    }\n  | {\n      type: FocusActionType.SET_FOCUS_SECTION;\n      focus: { row: string; table: FocusElementTable; section: [string, string] };\n    }\n  | { type: FocusActionType.SET_INTERACTORS_ON; focus: { row: string; table: FocusElementTable } }\n  | { type: FocusActionType.SET_INTERACTORS_OFF; focus: { row: string; table: FocusElementTable } }\n  | {\n      type: FocusActionType.SET_INTERACTORS_SOURCE;\n      focus: { row: string; table: FocusElementTable; source: InteractorsSource };\n    }\n  | {\n      type: FocusActionType.SET_INTERACTORS_SECTION;\n      focus: {\n        row: string;\n        table: FocusElementTable;\n        section: [string, string];\n        interactorsRow: string;\n      };\n    }\n  | {\n      type: FocusActionType.SET_INTERACTORS_THRESHOLD;\n      focus: {\n        row: string;\n        table: FocusElementTable;\n        interactorsThreshold: number;\n      };\n    };\n\nconst defaultFocusElement: FocusElement = {\n  table: TABLE_PREFIX.CORE,\n  row: \"\",\n  section: null,\n  interactors: false,\n  interactorsRow: null,\n  interactorsSection: null,\n  interactorsSource: INTERACTORS_SOURCES.INTACT,\n  interactorsThreshold: INTERACTORS_SOURCE_THRESHOLD[INTERACTORS_SOURCES.INTACT],\n};\n\nconst AssociationsFocusContext = createContext<FocusState>([]);\n\nconst AssociationsFocusDispatchContext = createContext<Dispatch<FocusAction>>((_) => _);\n\ntype FocusElementParams = Partial<FocusElement>;\n\nfunction createFocusElement(params: FocusElementParams = {}): FocusElement {\n  return {\n    ...defaultFocusElement,\n    ...params,\n  };\n}\n\nconst getFocusElementState = (\n  state: FocusState,\n  {\n    table,\n    row,\n    section,\n  }: { table: FocusElementTable; row: string; section: [string, string] | null }\n) => {\n  let sectionActive = false;\n  let rowActive = false;\n  let tableActive = false;\n  let interactorsActive = false;\n  let hasSectionActive = false;\n  state.forEach((el: FocusElement) => {\n    if (!tableActive && el.table === table) {\n      tableActive = true;\n    }\n    if (el.row === row && el.table === table) {\n      rowActive = true;\n      interactorsActive = el.interactors;\n      hasSectionActive = Array.isArray(el.section);\n      if (el.section?.join(\"-\") === section?.join(\"-\")) {\n        sectionActive = true;\n        return { sectionActive, rowActive, tableActive, interactorsActive, hasSectionActive };\n      }\n    }\n  });\n\n  return { sectionActive, rowActive, tableActive, interactorsActive, hasSectionActive };\n};\n\nfunction focusReducer(focusState: FocusState, action: FocusAction): FocusState {\n  switch (action.type) {\n    case FocusActionType.SET_FOCUS_SECTION: {\n      return handleSetFocusSection(focusState, action);\n    }\n\n    case FocusActionType.SET_FOCUS_CONTEXT_MENU: {\n      const { rowActive } = getFocusElementState(focusState, {\n        table: action.focus.table,\n        row: action.focus.row,\n        section: null,\n      });\n\n      if (rowActive) {\n        return focusState;\n      }\n\n      const newElement = createFocusElement({\n        row: action.focus.row,\n        table: action.focus.table,\n      });\n\n      return [...focusState, newElement];\n    }\n\n    case FocusActionType.CLEAR_FOCUS_CONTEXT_MENU: {\n      const { rowActive, hasSectionActive, interactorsActive } = getFocusElementState(focusState, {\n        table: action.focus.table,\n        row: action.focus.row,\n        section: null,\n      });\n      if (rowActive && (hasSectionActive || interactorsActive)) {\n        return focusState;\n      }\n      return focusState.filter(\n        (focusElement) =>\n          focusElement.row !== action.focus.row || focusElement.table !== action.focus.table\n      );\n    }\n\n    case FocusActionType.SET_INTERACTORS_ON: {\n      return handleSetInteractorsOn(focusState, action);\n    }\n\n    case FocusActionType.SET_INTERACTORS_OFF: {\n      const relevantElements = focusState.filter(\n        (element) =>\n          !(\n            element.table === action.focus.table &&\n            element.row === action.focus.row &&\n            element.section === null\n          )\n      );\n\n      return relevantElements.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactors: false,\n            interactorsSection: null,\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.SET_INTERACTORS_SECTION: {\n      return handleSetInteractorsSection(focusState, action);\n    }\n\n    case FocusActionType.SET_INTERACTORS_SOURCE: {\n      return focusState.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactorsSection: null,\n            interactorsSource: action.focus.source,\n            interactorsThreshold: INTERACTORS_SOURCE_THRESHOLD[action.focus.source],\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.SET_INTERACTORS_THRESHOLD: {\n      return focusState.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactorsThreshold: action.focus.interactorsThreshold,\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.RESET: {\n      return [];\n    }\n\n    default: {\n      throw Error(`Unknown action: ${action.type}`);\n    }\n  }\n}\n\n// Helper functions for complex operations\nfunction handleSetFocusSection(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row, section } = action.focus;\n\n  const matchingIndex = focusState.findIndex(\n    (element) => element.table === table && element.row === row\n  );\n\n  const elementExists = matchingIndex !== -1;\n  let updatedElements: FocusState = [];\n\n  if (elementExists) {\n    const element = focusState[matchingIndex];\n\n    // Check if section is the same and interactors are active\n    if (\n      element.section !== null &&\n      element.section.join(\"\") === section.join(\"\") &&\n      element.interactors\n    ) {\n      // Close section\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        { ...element, section: null },\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n    // Remove element if same section and interactors off\n    else if (\n      element.section !== null &&\n      element.section.join(\"\") === section.join(\"\") &&\n      !element.interactors\n    ) {\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n    // Update section for same row\n    else {\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        {\n          ...element,\n          interactorsRow: null,\n          interactorsSection: null,\n          section: section,\n        },\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n  } else {\n    // Create new element if it doesn't exist\n    const newElement = createFocusElement({\n      row,\n      table,\n      section,\n    });\n    updatedElements = [...focusState, newElement];\n  }\n\n  // Process other elements in the same table\n  return updatedElements.flatMap((element) => {\n    // Skip the element we just processed\n    if (element.table === table && element.row === row) {\n      return [element];\n    }\n\n    // Handle other elements in the same table\n    if (element.table === table) {\n      // Keep with reset states if it has interactors\n      if (element.interactors) {\n        return [\n          {\n            ...element,\n            section: null,\n            interactorsSection: null,\n            interactorsRow: null,\n          },\n        ];\n      }\n      // Remove if in same table with interactors off\n      return [];\n    }\n\n    // Keep elements from different tables unchanged\n    return [];\n  });\n}\n\nfunction handleSetInteractorsOn(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row } = action.focus;\n\n  // Check if element exists\n  const elementExists = focusState.some(\n    (element) => element.table === table && element.row === row\n  );\n\n  // Process existing elements\n  const updatedElements = focusState.map((element) => {\n    if (element.table === table && element.row === row) {\n      // Update existing element\n      return {\n        ...element,\n        interactors: true,\n      };\n    }\n    if (element.table === table && element.section) {\n      // Update other elements in same table with sections\n      return {\n        ...element,\n        interactors: false,\n      };\n    }\n    // Keep other elements unchanged\n    return element;\n  });\n\n  // Add new element if it doesn't exist\n  if (!elementExists) {\n    const newElement = createFocusElement({\n      row,\n      table,\n      interactors: true,\n    });\n    return [...updatedElements, newElement];\n  }\n\n  return updatedElements;\n}\n\nfunction handleSetInteractorsSection(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row, interactorsRow, section } = action.focus;\n\n  return focusState.flatMap((element) => {\n    // Active row\n    if (element.table === table && element.row === row) {\n      // Toggle off if section already active\n      if (\n        element.interactorsRow === interactorsRow &&\n        element.interactorsSection?.join(\"-\") === section?.join(\"-\")\n      ) {\n        return [\n          {\n            ...element,\n            interactorsRow: null,\n            interactorsSection: null,\n          },\n        ];\n      }\n      // Set section on element\n      return [\n        {\n          ...element,\n          interactorsRow,\n          interactorsSection: section,\n          section: null,\n        },\n      ];\n    }\n\n    // Reset other elements in same table with interactors\n    if (element.table === table && element.interactors) {\n      return [\n        {\n          ...element,\n          interactorsRow: null,\n          interactorsSection: null,\n        },\n      ];\n    }\n\n    // Keep other elements from different tables\n    return [element];\n  });\n}\n\nexport function AssociationsFocusProvider({ children }: { children: ReactElement }): ReactElement {\n  const [focusState, dispatch] = useReducer(focusReducer, []);\n  const { id } = useAotfContext();\n\n  useEffect(() => {\n    dispatch({ type: FocusActionType.RESET });\n  }, [id]);\n\n  return (\n    <AssociationsFocusContext.Provider value={focusState}>\n      <AssociationsFocusDispatchContext.Provider value={dispatch}>\n        {children}\n      </AssociationsFocusDispatchContext.Provider>\n    </AssociationsFocusContext.Provider>\n  );\n}\n\nexport function useAssociationsFocus(): FocusState {\n  return useContext(AssociationsFocusContext);\n}\n\nexport function useAssociationsFocusDispatch(): Dispatch<FocusAction> {\n  return useContext(AssociationsFocusDispatchContext);\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: id",
      "message": [
        { "elements": [], "content": "This hook specifies more dependencies than necessary: id" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [11868, 11870],
              "sourceCode": "import {\n  type Dispatch,\n  type ReactElement,\n  createContext,\n  useContext,\n  useEffect,\n  useReducer,\n} from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  INTERACTORS_SOURCE_THRESHOLD,\n  type InteractorsSource,\n  TABLE_PREFIX,\n} from \"../associationsUtils\";\nimport useAotfContext from \"../hooks/useAotfContext\";\n\nexport type FocusElementTable = \"core\" | \"pinned\" | \"upload\";\n\nexport type FocusElement = {\n  table: FocusElementTable;\n  row: string;\n  interactorsRow: string | null;\n  interactorsSource: InteractorsSource | null;\n  interactors: boolean;\n  section: null | [string, string];\n  interactorsSection: null | [string, string];\n  interactorsThreshold: number | null;\n};\n\nexport type FocusState = FocusElement[];\n\nexport enum FocusActionType {\n  RESET = \"RESET\",\n  SET_INTERACTORS_ON = \"SET_INTERACTORS_ON\",\n  SET_INTERACTORS_OFF = \"SET_INTERACTORS_OFF\",\n  SET_INTERACTORS_SECTION = \"SET_INTERACTORS_SECTION\",\n  SET_INTERACTORS_THRESHOLD = \"SET_INTERACTORS_THRESHOLD\",\n  CLEAR_INTERACTORS_SECTION = \"CLEAR_INTERACTORS_SECTION\",\n  SET_FOCUS_SECTION = \"SET_FOCUS_SECTION\",\n  CLEAR_FOCUS_CONTEXT_MENU = \"CLEAR_FOCUS_CONTEXT_MENU\",\n  SET_FOCUS_CONTEXT_MENU = \"SET_FOCUS_CONTEXT_MENU\",\n  SET_INTERACTORS_SOURCE = \"SET_INTERACTORS_SOURCE\",\n}\n\nexport type FocusAction =\n  | { type: FocusActionType.RESET }\n  | {\n      type: FocusActionType.SET_FOCUS_CONTEXT_MENU;\n      focus: { row: string; table: FocusElementTable };\n    }\n  | {\n      type: FocusActionType.CLEAR_FOCUS_CONTEXT_MENU;\n      focus: { row: string; table: FocusElementTable };\n    }\n  | {\n      type: FocusActionType.SET_FOCUS_SECTION;\n      focus: { row: string; table: FocusElementTable; section: [string, string] };\n    }\n  | { type: FocusActionType.SET_INTERACTORS_ON; focus: { row: string; table: FocusElementTable } }\n  | { type: FocusActionType.SET_INTERACTORS_OFF; focus: { row: string; table: FocusElementTable } }\n  | {\n      type: FocusActionType.SET_INTERACTORS_SOURCE;\n      focus: { row: string; table: FocusElementTable; source: InteractorsSource };\n    }\n  | {\n      type: FocusActionType.SET_INTERACTORS_SECTION;\n      focus: {\n        row: string;\n        table: FocusElementTable;\n        section: [string, string];\n        interactorsRow: string;\n      };\n    }\n  | {\n      type: FocusActionType.SET_INTERACTORS_THRESHOLD;\n      focus: {\n        row: string;\n        table: FocusElementTable;\n        interactorsThreshold: number;\n      };\n    };\n\nconst defaultFocusElement: FocusElement = {\n  table: TABLE_PREFIX.CORE,\n  row: \"\",\n  section: null,\n  interactors: false,\n  interactorsRow: null,\n  interactorsSection: null,\n  interactorsSource: INTERACTORS_SOURCES.INTACT,\n  interactorsThreshold: INTERACTORS_SOURCE_THRESHOLD[INTERACTORS_SOURCES.INTACT],\n};\n\nconst AssociationsFocusContext = createContext<FocusState>([]);\n\nconst AssociationsFocusDispatchContext = createContext<Dispatch<FocusAction>>((_) => _);\n\ntype FocusElementParams = Partial<FocusElement>;\n\nfunction createFocusElement(params: FocusElementParams = {}): FocusElement {\n  return {\n    ...defaultFocusElement,\n    ...params,\n  };\n}\n\nconst getFocusElementState = (\n  state: FocusState,\n  {\n    table,\n    row,\n    section,\n  }: { table: FocusElementTable; row: string; section: [string, string] | null }\n) => {\n  let sectionActive = false;\n  let rowActive = false;\n  let tableActive = false;\n  let interactorsActive = false;\n  let hasSectionActive = false;\n  state.forEach((el: FocusElement) => {\n    if (!tableActive && el.table === table) {\n      tableActive = true;\n    }\n    if (el.row === row && el.table === table) {\n      rowActive = true;\n      interactorsActive = el.interactors;\n      hasSectionActive = Array.isArray(el.section);\n      if (el.section?.join(\"-\") === section?.join(\"-\")) {\n        sectionActive = true;\n        return { sectionActive, rowActive, tableActive, interactorsActive, hasSectionActive };\n      }\n    }\n  });\n\n  return { sectionActive, rowActive, tableActive, interactorsActive, hasSectionActive };\n};\n\nfunction focusReducer(focusState: FocusState, action: FocusAction): FocusState {\n  switch (action.type) {\n    case FocusActionType.SET_FOCUS_SECTION: {\n      return handleSetFocusSection(focusState, action);\n    }\n\n    case FocusActionType.SET_FOCUS_CONTEXT_MENU: {\n      const { rowActive } = getFocusElementState(focusState, {\n        table: action.focus.table,\n        row: action.focus.row,\n        section: null,\n      });\n\n      if (rowActive) {\n        return focusState;\n      }\n\n      const newElement = createFocusElement({\n        row: action.focus.row,\n        table: action.focus.table,\n      });\n\n      return [...focusState, newElement];\n    }\n\n    case FocusActionType.CLEAR_FOCUS_CONTEXT_MENU: {\n      const { rowActive, hasSectionActive, interactorsActive } = getFocusElementState(focusState, {\n        table: action.focus.table,\n        row: action.focus.row,\n        section: null,\n      });\n      if (rowActive && (hasSectionActive || interactorsActive)) {\n        return focusState;\n      }\n      return focusState.filter(\n        (focusElement) =>\n          focusElement.row !== action.focus.row || focusElement.table !== action.focus.table\n      );\n    }\n\n    case FocusActionType.SET_INTERACTORS_ON: {\n      return handleSetInteractorsOn(focusState, action);\n    }\n\n    case FocusActionType.SET_INTERACTORS_OFF: {\n      const relevantElements = focusState.filter(\n        (element) =>\n          !(\n            element.table === action.focus.table &&\n            element.row === action.focus.row &&\n            element.section === null\n          )\n      );\n\n      return relevantElements.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactors: false,\n            interactorsSection: null,\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.SET_INTERACTORS_SECTION: {\n      return handleSetInteractorsSection(focusState, action);\n    }\n\n    case FocusActionType.SET_INTERACTORS_SOURCE: {\n      return focusState.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactorsSection: null,\n            interactorsSource: action.focus.source,\n            interactorsThreshold: INTERACTORS_SOURCE_THRESHOLD[action.focus.source],\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.SET_INTERACTORS_THRESHOLD: {\n      return focusState.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactorsThreshold: action.focus.interactorsThreshold,\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.RESET: {\n      return [];\n    }\n\n    default: {\n      throw Error(`Unknown action: ${action.type}`);\n    }\n  }\n}\n\n// Helper functions for complex operations\nfunction handleSetFocusSection(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row, section } = action.focus;\n\n  const matchingIndex = focusState.findIndex(\n    (element) => element.table === table && element.row === row\n  );\n\n  const elementExists = matchingIndex !== -1;\n  let updatedElements: FocusState = [];\n\n  if (elementExists) {\n    const element = focusState[matchingIndex];\n\n    // Check if section is the same and interactors are active\n    if (\n      element.section !== null &&\n      element.section.join(\"\") === section.join(\"\") &&\n      element.interactors\n    ) {\n      // Close section\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        { ...element, section: null },\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n    // Remove element if same section and interactors off\n    else if (\n      element.section !== null &&\n      element.section.join(\"\") === section.join(\"\") &&\n      !element.interactors\n    ) {\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n    // Update section for same row\n    else {\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        {\n          ...element,\n          interactorsRow: null,\n          interactorsSection: null,\n          section: section,\n        },\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n  } else {\n    // Create new element if it doesn't exist\n    const newElement = createFocusElement({\n      row,\n      table,\n      section,\n    });\n    updatedElements = [...focusState, newElement];\n  }\n\n  // Process other elements in the same table\n  return updatedElements.flatMap((element) => {\n    // Skip the element we just processed\n    if (element.table === table && element.row === row) {\n      return [element];\n    }\n\n    // Handle other elements in the same table\n    if (element.table === table) {\n      // Keep with reset states if it has interactors\n      if (element.interactors) {\n        return [\n          {\n            ...element,\n            section: null,\n            interactorsSection: null,\n            interactorsRow: null,\n          },\n        ];\n      }\n      // Remove if in same table with interactors off\n      return [];\n    }\n\n    // Keep elements from different tables unchanged\n    return [];\n  });\n}\n\nfunction handleSetInteractorsOn(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row } = action.focus;\n\n  // Check if element exists\n  const elementExists = focusState.some(\n    (element) => element.table === table && element.row === row\n  );\n\n  // Process existing elements\n  const updatedElements = focusState.map((element) => {\n    if (element.table === table && element.row === row) {\n      // Update existing element\n      return {\n        ...element,\n        interactors: true,\n      };\n    }\n    if (element.table === table && element.section) {\n      // Update other elements in same table with sections\n      return {\n        ...element,\n        interactors: false,\n      };\n    }\n    // Keep other elements unchanged\n    return element;\n  });\n\n  // Add new element if it doesn't exist\n  if (!elementExists) {\n    const newElement = createFocusElement({\n      row,\n      table,\n      interactors: true,\n    });\n    return [...updatedElements, newElement];\n  }\n\n  return updatedElements;\n}\n\nfunction handleSetInteractorsSection(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row, interactorsRow, section } = action.focus;\n\n  return focusState.flatMap((element) => {\n    // Active row\n    if (element.table === table && element.row === row) {\n      // Toggle off if section already active\n      if (\n        element.interactorsRow === interactorsRow &&\n        element.interactorsSection?.join(\"-\") === section?.join(\"-\")\n      ) {\n        return [\n          {\n            ...element,\n            interactorsRow: null,\n            interactorsSection: null,\n          },\n        ];\n      }\n      // Set section on element\n      return [\n        {\n          ...element,\n          interactorsRow,\n          interactorsSection: section,\n          section: null,\n        },\n      ];\n    }\n\n    // Reset other elements in same table with interactors\n    if (element.table === table && element.interactors) {\n      return [\n        {\n          ...element,\n          interactorsRow: null,\n          interactorsSection: null,\n        },\n      ];\n    }\n\n    // Keep other elements from different tables\n    return [element];\n  });\n}\n\nexport function AssociationsFocusProvider({ children }: { children: ReactElement }): ReactElement {\n  const [focusState, dispatch] = useReducer(focusReducer, []);\n  const { id } = useAotfContext();\n\n  useEffect(() => {\n    dispatch({ type: FocusActionType.RESET });\n  }, [id]);\n\n  return (\n    <AssociationsFocusContext.Provider value={focusState}>\n      <AssociationsFocusDispatchContext.Provider value={dispatch}>\n        {children}\n      </AssociationsFocusDispatchContext.Provider>\n    </AssociationsFocusContext.Provider>\n  );\n}\n\nexport function useAssociationsFocus(): FocusState {\n  return useContext(AssociationsFocusContext);\n}\n\nexport function useAssociationsFocusDispatch(): Dispatch<FocusAction> {\n  return useContext(AssociationsFocusDispatchContext);\n}\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./apps/platform/src/components/AssociationsToolkit/context/AssociationsFocusContext.tsx"
        },
        "span": [11797, 11806],
        "sourceCode": "import {\n  type Dispatch,\n  type ReactElement,\n  createContext,\n  useContext,\n  useEffect,\n  useReducer,\n} from \"react\";\nimport {\n  INTERACTORS_SOURCES,\n  INTERACTORS_SOURCE_THRESHOLD,\n  type InteractorsSource,\n  TABLE_PREFIX,\n} from \"../associationsUtils\";\nimport useAotfContext from \"../hooks/useAotfContext\";\n\nexport type FocusElementTable = \"core\" | \"pinned\" | \"upload\";\n\nexport type FocusElement = {\n  table: FocusElementTable;\n  row: string;\n  interactorsRow: string | null;\n  interactorsSource: InteractorsSource | null;\n  interactors: boolean;\n  section: null | [string, string];\n  interactorsSection: null | [string, string];\n  interactorsThreshold: number | null;\n};\n\nexport type FocusState = FocusElement[];\n\nexport enum FocusActionType {\n  RESET = \"RESET\",\n  SET_INTERACTORS_ON = \"SET_INTERACTORS_ON\",\n  SET_INTERACTORS_OFF = \"SET_INTERACTORS_OFF\",\n  SET_INTERACTORS_SECTION = \"SET_INTERACTORS_SECTION\",\n  SET_INTERACTORS_THRESHOLD = \"SET_INTERACTORS_THRESHOLD\",\n  CLEAR_INTERACTORS_SECTION = \"CLEAR_INTERACTORS_SECTION\",\n  SET_FOCUS_SECTION = \"SET_FOCUS_SECTION\",\n  CLEAR_FOCUS_CONTEXT_MENU = \"CLEAR_FOCUS_CONTEXT_MENU\",\n  SET_FOCUS_CONTEXT_MENU = \"SET_FOCUS_CONTEXT_MENU\",\n  SET_INTERACTORS_SOURCE = \"SET_INTERACTORS_SOURCE\",\n}\n\nexport type FocusAction =\n  | { type: FocusActionType.RESET }\n  | {\n      type: FocusActionType.SET_FOCUS_CONTEXT_MENU;\n      focus: { row: string; table: FocusElementTable };\n    }\n  | {\n      type: FocusActionType.CLEAR_FOCUS_CONTEXT_MENU;\n      focus: { row: string; table: FocusElementTable };\n    }\n  | {\n      type: FocusActionType.SET_FOCUS_SECTION;\n      focus: { row: string; table: FocusElementTable; section: [string, string] };\n    }\n  | { type: FocusActionType.SET_INTERACTORS_ON; focus: { row: string; table: FocusElementTable } }\n  | { type: FocusActionType.SET_INTERACTORS_OFF; focus: { row: string; table: FocusElementTable } }\n  | {\n      type: FocusActionType.SET_INTERACTORS_SOURCE;\n      focus: { row: string; table: FocusElementTable; source: InteractorsSource };\n    }\n  | {\n      type: FocusActionType.SET_INTERACTORS_SECTION;\n      focus: {\n        row: string;\n        table: FocusElementTable;\n        section: [string, string];\n        interactorsRow: string;\n      };\n    }\n  | {\n      type: FocusActionType.SET_INTERACTORS_THRESHOLD;\n      focus: {\n        row: string;\n        table: FocusElementTable;\n        interactorsThreshold: number;\n      };\n    };\n\nconst defaultFocusElement: FocusElement = {\n  table: TABLE_PREFIX.CORE,\n  row: \"\",\n  section: null,\n  interactors: false,\n  interactorsRow: null,\n  interactorsSection: null,\n  interactorsSource: INTERACTORS_SOURCES.INTACT,\n  interactorsThreshold: INTERACTORS_SOURCE_THRESHOLD[INTERACTORS_SOURCES.INTACT],\n};\n\nconst AssociationsFocusContext = createContext<FocusState>([]);\n\nconst AssociationsFocusDispatchContext = createContext<Dispatch<FocusAction>>((_) => _);\n\ntype FocusElementParams = Partial<FocusElement>;\n\nfunction createFocusElement(params: FocusElementParams = {}): FocusElement {\n  return {\n    ...defaultFocusElement,\n    ...params,\n  };\n}\n\nconst getFocusElementState = (\n  state: FocusState,\n  {\n    table,\n    row,\n    section,\n  }: { table: FocusElementTable; row: string; section: [string, string] | null }\n) => {\n  let sectionActive = false;\n  let rowActive = false;\n  let tableActive = false;\n  let interactorsActive = false;\n  let hasSectionActive = false;\n  state.forEach((el: FocusElement) => {\n    if (!tableActive && el.table === table) {\n      tableActive = true;\n    }\n    if (el.row === row && el.table === table) {\n      rowActive = true;\n      interactorsActive = el.interactors;\n      hasSectionActive = Array.isArray(el.section);\n      if (el.section?.join(\"-\") === section?.join(\"-\")) {\n        sectionActive = true;\n        return { sectionActive, rowActive, tableActive, interactorsActive, hasSectionActive };\n      }\n    }\n  });\n\n  return { sectionActive, rowActive, tableActive, interactorsActive, hasSectionActive };\n};\n\nfunction focusReducer(focusState: FocusState, action: FocusAction): FocusState {\n  switch (action.type) {\n    case FocusActionType.SET_FOCUS_SECTION: {\n      return handleSetFocusSection(focusState, action);\n    }\n\n    case FocusActionType.SET_FOCUS_CONTEXT_MENU: {\n      const { rowActive } = getFocusElementState(focusState, {\n        table: action.focus.table,\n        row: action.focus.row,\n        section: null,\n      });\n\n      if (rowActive) {\n        return focusState;\n      }\n\n      const newElement = createFocusElement({\n        row: action.focus.row,\n        table: action.focus.table,\n      });\n\n      return [...focusState, newElement];\n    }\n\n    case FocusActionType.CLEAR_FOCUS_CONTEXT_MENU: {\n      const { rowActive, hasSectionActive, interactorsActive } = getFocusElementState(focusState, {\n        table: action.focus.table,\n        row: action.focus.row,\n        section: null,\n      });\n      if (rowActive && (hasSectionActive || interactorsActive)) {\n        return focusState;\n      }\n      return focusState.filter(\n        (focusElement) =>\n          focusElement.row !== action.focus.row || focusElement.table !== action.focus.table\n      );\n    }\n\n    case FocusActionType.SET_INTERACTORS_ON: {\n      return handleSetInteractorsOn(focusState, action);\n    }\n\n    case FocusActionType.SET_INTERACTORS_OFF: {\n      const relevantElements = focusState.filter(\n        (element) =>\n          !(\n            element.table === action.focus.table &&\n            element.row === action.focus.row &&\n            element.section === null\n          )\n      );\n\n      return relevantElements.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactors: false,\n            interactorsSection: null,\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.SET_INTERACTORS_SECTION: {\n      return handleSetInteractorsSection(focusState, action);\n    }\n\n    case FocusActionType.SET_INTERACTORS_SOURCE: {\n      return focusState.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactorsSection: null,\n            interactorsSource: action.focus.source,\n            interactorsThreshold: INTERACTORS_SOURCE_THRESHOLD[action.focus.source],\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.SET_INTERACTORS_THRESHOLD: {\n      return focusState.map((element) => {\n        if (element.table === action.focus.table && element.row === action.focus.row) {\n          return {\n            ...element,\n            interactorsThreshold: action.focus.interactorsThreshold,\n          };\n        }\n        return element;\n      });\n    }\n\n    case FocusActionType.RESET: {\n      return [];\n    }\n\n    default: {\n      throw Error(`Unknown action: ${action.type}`);\n    }\n  }\n}\n\n// Helper functions for complex operations\nfunction handleSetFocusSection(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row, section } = action.focus;\n\n  const matchingIndex = focusState.findIndex(\n    (element) => element.table === table && element.row === row\n  );\n\n  const elementExists = matchingIndex !== -1;\n  let updatedElements: FocusState = [];\n\n  if (elementExists) {\n    const element = focusState[matchingIndex];\n\n    // Check if section is the same and interactors are active\n    if (\n      element.section !== null &&\n      element.section.join(\"\") === section.join(\"\") &&\n      element.interactors\n    ) {\n      // Close section\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        { ...element, section: null },\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n    // Remove element if same section and interactors off\n    else if (\n      element.section !== null &&\n      element.section.join(\"\") === section.join(\"\") &&\n      !element.interactors\n    ) {\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n    // Update section for same row\n    else {\n      updatedElements = [\n        ...focusState.slice(0, matchingIndex),\n        {\n          ...element,\n          interactorsRow: null,\n          interactorsSection: null,\n          section: section,\n        },\n        ...focusState.slice(matchingIndex + 1),\n      ];\n    }\n  } else {\n    // Create new element if it doesn't exist\n    const newElement = createFocusElement({\n      row,\n      table,\n      section,\n    });\n    updatedElements = [...focusState, newElement];\n  }\n\n  // Process other elements in the same table\n  return updatedElements.flatMap((element) => {\n    // Skip the element we just processed\n    if (element.table === table && element.row === row) {\n      return [element];\n    }\n\n    // Handle other elements in the same table\n    if (element.table === table) {\n      // Keep with reset states if it has interactors\n      if (element.interactors) {\n        return [\n          {\n            ...element,\n            section: null,\n            interactorsSection: null,\n            interactorsRow: null,\n          },\n        ];\n      }\n      // Remove if in same table with interactors off\n      return [];\n    }\n\n    // Keep elements from different tables unchanged\n    return [];\n  });\n}\n\nfunction handleSetInteractorsOn(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row } = action.focus;\n\n  // Check if element exists\n  const elementExists = focusState.some(\n    (element) => element.table === table && element.row === row\n  );\n\n  // Process existing elements\n  const updatedElements = focusState.map((element) => {\n    if (element.table === table && element.row === row) {\n      // Update existing element\n      return {\n        ...element,\n        interactors: true,\n      };\n    }\n    if (element.table === table && element.section) {\n      // Update other elements in same table with sections\n      return {\n        ...element,\n        interactors: false,\n      };\n    }\n    // Keep other elements unchanged\n    return element;\n  });\n\n  // Add new element if it doesn't exist\n  if (!elementExists) {\n    const newElement = createFocusElement({\n      row,\n      table,\n      interactors: true,\n    });\n    return [...updatedElements, newElement];\n  }\n\n  return updatedElements;\n}\n\nfunction handleSetInteractorsSection(focusState: FocusState, action: FocusAction): FocusState {\n  const { table, row, interactorsRow, section } = action.focus;\n\n  return focusState.flatMap((element) => {\n    // Active row\n    if (element.table === table && element.row === row) {\n      // Toggle off if section already active\n      if (\n        element.interactorsRow === interactorsRow &&\n        element.interactorsSection?.join(\"-\") === section?.join(\"-\")\n      ) {\n        return [\n          {\n            ...element,\n            interactorsRow: null,\n            interactorsSection: null,\n          },\n        ];\n      }\n      // Set section on element\n      return [\n        {\n          ...element,\n          interactorsRow,\n          interactorsSection: section,\n          section: null,\n        },\n      ];\n    }\n\n    // Reset other elements in same table with interactors\n    if (element.table === table && element.interactors) {\n      return [\n        {\n          ...element,\n          interactorsRow: null,\n          interactorsSection: null,\n        },\n      ];\n    }\n\n    // Keep other elements from different tables\n    return [element];\n  });\n}\n\nexport function AssociationsFocusProvider({ children }: { children: ReactElement }): ReactElement {\n  const [focusState, dispatch] = useReducer(focusReducer, []);\n  const { id } = useAotfContext();\n\n  useEffect(() => {\n    dispatch({ type: FocusActionType.RESET });\n  }, [id]);\n\n  return (\n    <AssociationsFocusContext.Provider value={focusState}>\n      <AssociationsFocusDispatchContext.Provider value={dispatch}>\n        {children}\n      </AssociationsFocusDispatchContext.Provider>\n    </AssociationsFocusContext.Provider>\n  );\n}\n\nexport function useAssociationsFocus(): FocusState {\n  return useContext(AssociationsFocusContext);\n}\n\nexport function useAssociationsFocusDispatch(): Dispatch<FocusAction> {\n  return useContext(AssociationsFocusDispatchContext);\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: deserialize",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: deserialize"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [676, 687],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nfunction useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const search = new URLSearchParams(location.search);\n\n  const existingValue = search.get(paramsName);\n  const [state, setState] = useState<T>(existingValue ? deserialize(existingValue) : initialState);\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(deserialize(existingValue));\n    } else if (!existingValue) setState(initialState);\n  }, [existingValue]);\n\n  const onChange = (s: T) => {\n    setState(s);\n    const searchParams = new URLSearchParams(location.search);\n    searchParams.set(paramsName, serialize(s));\n    const { pathname } = location;\n    navigate({ pathname, search: searchParams.toString() });\n  };\n\n  return [state, onChange];\n}\n\nexport default useStateParams;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [731, 742],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nfunction useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const search = new URLSearchParams(location.search);\n\n  const existingValue = search.get(paramsName);\n  const [state, setState] = useState<T>(existingValue ? deserialize(existingValue) : initialState);\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(deserialize(existingValue));\n    } else if (!existingValue) setState(initialState);\n  }, [existingValue]);\n\n  const onChange = (s: T) => {\n    setState(s);\n    const searchParams = new URLSearchParams(location.search);\n    searchParams.set(paramsName, serialize(s));\n    const { pathname } = location;\n    navigate({ pathname, search: searchParams.toString() });\n  };\n\n  return [state, onChange];\n}\n\nexport default useStateParams;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useStateParams.ts" },
        "span": [551, 560],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nfunction useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const search = new URLSearchParams(location.search);\n\n  const existingValue = search.get(paramsName);\n  const [state, setState] = useState<T>(existingValue ? deserialize(existingValue) : initialState);\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(deserialize(existingValue));\n    } else if (!existingValue) setState(initialState);\n  }, [existingValue]);\n\n  const onChange = (s: T) => {\n    setState(s);\n    const searchParams = new URLSearchParams(location.search);\n    searchParams.set(paramsName, serialize(s));\n    const { pathname } = location;\n    navigate({ pathname, search: searchParams.toString() });\n  };\n\n  return [state, onChange];\n}\n\nexport default useStateParams;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: initialState",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: initialState"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [800, 812],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nfunction useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const search = new URLSearchParams(location.search);\n\n  const existingValue = search.get(paramsName);\n  const [state, setState] = useState<T>(existingValue ? deserialize(existingValue) : initialState);\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(deserialize(existingValue));\n    } else if (!existingValue) setState(initialState);\n  }, [existingValue]);\n\n  const onChange = (s: T) => {\n    setState(s);\n    const searchParams = new URLSearchParams(location.search);\n    searchParams.set(paramsName, serialize(s));\n    const { pathname } = location;\n    navigate({ pathname, search: searchParams.toString() });\n  };\n\n  return [state, onChange];\n}\n\nexport default useStateParams;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useStateParams.ts" },
        "span": [551, 560],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nfunction useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const search = new URLSearchParams(location.search);\n\n  const existingValue = search.get(paramsName);\n  const [state, setState] = useState<T>(existingValue ? deserialize(existingValue) : initialState);\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(deserialize(existingValue));\n    } else if (!existingValue) setState(initialState);\n  }, [existingValue]);\n\n  const onChange = (s: T) => {\n    setState(s);\n    const searchParams = new URLSearchParams(location.search);\n    searchParams.set(paramsName, serialize(s));\n    const { pathname } = location;\n    navigate({ pathname, search: searchParams.toString() });\n  };\n\n  return [state, onChange];\n}\n\nexport default useStateParams;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: state",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: state" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [707, 712],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nfunction useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const search = new URLSearchParams(location.search);\n\n  const existingValue = search.get(paramsName);\n  const [state, setState] = useState<T>(existingValue ? deserialize(existingValue) : initialState);\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(deserialize(existingValue));\n    } else if (!existingValue) setState(initialState);\n  }, [existingValue]);\n\n  const onChange = (s: T) => {\n    setState(s);\n    const searchParams = new URLSearchParams(location.search);\n    searchParams.set(paramsName, serialize(s));\n    const { pathname } = location;\n    navigate({ pathname, search: searchParams.toString() });\n  };\n\n  return [state, onChange];\n}\n\nexport default useStateParams;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useStateParams.ts" },
        "span": [551, 560],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\n\nfunction useStateParams<T>(\n  initialState: T,\n  paramsName: string,\n  serialize: (state: T) => string,\n  deserialize: (state: string) => T\n): [T, (state: T) => void] {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const search = new URLSearchParams(location.search);\n\n  const existingValue = search.get(paramsName);\n  const [state, setState] = useState<T>(existingValue ? deserialize(existingValue) : initialState);\n\n  useEffect(() => {\n    // Updates state when user navigates backwards or forwards in browser history\n    if (existingValue && deserialize(existingValue) !== state) {\n      setState(deserialize(existingValue));\n    } else if (!existingValue) setState(initialState);\n  }, [existingValue]);\n\n  const onChange = (s: T) => {\n    setState(s);\n    const searchParams = new URLSearchParams(location.search);\n    searchParams.set(paramsName, serialize(s));\n    const { pathname } = location;\n    navigate({ pathname, search: searchParams.toString() });\n  };\n\n  return [state, onChange];\n}\n\nexport default useStateParams;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noUnreachable",
      "severity": "error",
      "description": "This code is unreachable",
      "message": [{ "elements": [], "content": "This code will never be reached ..." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "... because this statement will throw an exception beforehand"
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2059, 2100],
              "sourceCode": "import {\n  ALL_CATEGORY,\n  type Action,\n  ActionType,\n  DISEASE_CATEGORIES,\n  ENTITY,\n  type FacetState,\n  TARGET_CATEGORIES,\n} from \"./facetsTypes\";\n\nexport const initialFacetState: FacetState = {\n  dataOptions: [],\n  loading: false,\n  availableCategories: {},\n  categoryFilterValue: \"\",\n  selectedFacets: [],\n  suggestionOptions: [],\n};\n\nexport function createInitialState(entityToGet: string): FacetState {\n  const availableCategories =\n    entityToGet === ENTITY.DISEASE ? DISEASE_CATEGORIES : TARGET_CATEGORIES;\n  const categoryFilterValue = availableCategories[ALL_CATEGORY];\n  const state = { ...initialFacetState, availableCategories, categoryFilterValue };\n  return state;\n}\n\nexport function facetsReducer(state: FacetState, action: Action): FacetState {\n  if (typeof state === \"undefined\") {\n    throw Error(\"State provided to facetsReducer is undefined\");\n  }\n  switch (action.type) {\n    case ActionType.RESET_FACETS: {\n      const initialStateWithCategory = createInitialState(action.entityToGet);\n      return {\n        ...initialStateWithCategory,\n        selectedFacets: [],\n        dataOptions: [],\n      };\n    }\n    case ActionType.SEARCH_FACETS: {\n      return {\n        ...state,\n        dataOptions: action.payload,\n        loading: false,\n      };\n    }\n    case ActionType.SET_LOADING: {\n      return {\n        ...state,\n        loading: action.loading,\n      };\n    }\n    case ActionType.SEARCH_CATEGORY: {\n      return {\n        ...state,\n        availableCategories: action.categories,\n        categoryFilterValue: action.categories[ALL_CATEGORY],\n      };\n    }\n    case ActionType.SET_CATEGORY: {\n      return {\n        ...state,\n        loading: false,\n        categoryFilterValue: action.payload.category,\n        dataOptions: action.payload.suggestionOptions,\n        suggestionOptions: action.payload.suggestionOptions,\n      };\n    }\n    case ActionType.SELECT_FACET: {\n      return {\n        ...state,\n        selectedFacets: action.payload,\n        dataOptions: state.suggestionOptions,\n      };\n    }\n    default: {\n      throw Error(`Unknown action: ${action}`);\n      return state;\n    }\n  }\n}\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/Facets/facetsReducer.ts" },
        "span": [2107, 2120],
        "sourceCode": "import {\n  ALL_CATEGORY,\n  type Action,\n  ActionType,\n  DISEASE_CATEGORIES,\n  ENTITY,\n  type FacetState,\n  TARGET_CATEGORIES,\n} from \"./facetsTypes\";\n\nexport const initialFacetState: FacetState = {\n  dataOptions: [],\n  loading: false,\n  availableCategories: {},\n  categoryFilterValue: \"\",\n  selectedFacets: [],\n  suggestionOptions: [],\n};\n\nexport function createInitialState(entityToGet: string): FacetState {\n  const availableCategories =\n    entityToGet === ENTITY.DISEASE ? DISEASE_CATEGORIES : TARGET_CATEGORIES;\n  const categoryFilterValue = availableCategories[ALL_CATEGORY];\n  const state = { ...initialFacetState, availableCategories, categoryFilterValue };\n  return state;\n}\n\nexport function facetsReducer(state: FacetState, action: Action): FacetState {\n  if (typeof state === \"undefined\") {\n    throw Error(\"State provided to facetsReducer is undefined\");\n  }\n  switch (action.type) {\n    case ActionType.RESET_FACETS: {\n      const initialStateWithCategory = createInitialState(action.entityToGet);\n      return {\n        ...initialStateWithCategory,\n        selectedFacets: [],\n        dataOptions: [],\n      };\n    }\n    case ActionType.SEARCH_FACETS: {\n      return {\n        ...state,\n        dataOptions: action.payload,\n        loading: false,\n      };\n    }\n    case ActionType.SET_LOADING: {\n      return {\n        ...state,\n        loading: action.loading,\n      };\n    }\n    case ActionType.SEARCH_CATEGORY: {\n      return {\n        ...state,\n        availableCategories: action.categories,\n        categoryFilterValue: action.categories[ALL_CATEGORY],\n      };\n    }\n    case ActionType.SET_CATEGORY: {\n      return {\n        ...state,\n        loading: false,\n        categoryFilterValue: action.payload.category,\n        dataOptions: action.payload.suggestionOptions,\n        suggestionOptions: action.payload.suggestionOptions,\n      };\n    }\n    case ActionType.SELECT_FACET: {\n      return {\n        ...state,\n        selectedFacets: action.payload,\n        dataOptions: state.suggestionOptions,\n      };\n    }\n    default: {\n      throw Error(`Unknown action: ${action}`);\n      return state;\n    }\n  }\n}\n"
      },
      "tags": ["unnecessaryCode"],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: getFacetsQueryData",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: getFacetsQueryData"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2941, 2959],
              "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/Facets/FacetsSearch.tsx" },
        "span": [2903, 2912],
        "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: inputValue",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: inputValue"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2929, 2939],
              "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/Facets/FacetsSearch.tsx" },
        "span": [2903, 2912],
        "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: debouncedInputValue",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: debouncedInputValue"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3007, 3026],
              "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/Facets/FacetsSearch.tsx" },
        "span": [2903, 2912],
        "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: entityToGet",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: entityToGet"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3076, 3087],
              "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/Facets/FacetsSearch.tsx" },
        "span": [3033, 3042],
        "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: id",
      "message": [
        { "elements": [], "content": "This hook specifies more dependencies than necessary: id" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3097, 3099],
              "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/Facets/FacetsSearch.tsx" },
        "span": [3033, 3042],
        "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/security/noDangerouslySetInnerHtml",
      "severity": "error",
      "description": "Avoid passing content using the dangerouslySetInnerHTML prop.",
      "message": [
        { "elements": [], "content": "Avoid passing content using the " },
        { "elements": ["Emphasis"], "content": "dangerouslySetInnerHTML" },
        { "elements": [], "content": " prop." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "warn",
              [
                {
                  "elements": [],
                  "content": "Setting content using code can expose users to cross-site scripting (XSS) attacks"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/Facets/FacetsSearch.tsx" },
        "span": [5832, 5855],
        "sourceCode": "import {\n  Box,\n  Button,\n  Chip,\n  Divider,\n  MenuItem,\n  Popover,\n  type SelectChangeEvent,\n  TextField,\n  Typography,\n  styled,\n} from \"@mui/material\";\nimport { type MouseEvent, type ReactElement, useEffect, useReducer, useState } from \"react\";\nimport { Tooltip, useApolloClient, useDebounce } from \"ui\";\n\nimport { faCaretDown, faCaretUp, faCircleXmark, faFilter } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { v1 } from \"uuid\";\nimport { DataUploader } from \"../AssociationsToolkit\";\nimport useAotfContext from \"../AssociationsToolkit/hooks/useAotfContext\";\nimport FacetsSuggestion from \"./FacetsSuggestion\";\nimport { resetFacets, selectFacet, setCategory, setFacetsData, setLoading } from \"./facetsActions\";\nimport {\n  FacetListItemCategory,\n  FacetListItemContainer,\n  FacetListItemLabel,\n  FacetsAutocomplete,\n  FacetsPopper,\n  FacetsSelect,\n} from \"./facetsLayout\";\nimport { createInitialState, facetsReducer } from \"./facetsReducer\";\nimport type { Facet } from \"./facetsTypes\";\nimport { getFacetsData } from \"./service/facetsService\";\n\nconst FilterButton = styled(Button)({\n  border: \"none\",\n  \"& .MuiButton-startIcon\": {\n    fontSize: \"14px !important\",\n  },\n});\n\nfunction removeFacet(items: Facet[], idToRemove: string): Facet[] {\n  return items.filter((item) => item.id !== idToRemove);\n}\n\nfunction FacetsSearch(): ReactElement {\n  const {\n    entityToGet,\n    facetFilterSelect,\n    id,\n    state: { facetFilters },\n  } = useAotfContext();\n  const [inputValue, setInputValue] = useState(\"\");\n  const [value, setValue] = useState(null);\n  const [optionsOpen, setOptionsOpen] = useState(false);\n  const debouncedInputValue = useDebounce(inputValue, 200);\n  const [state, dispatch] = useReducer(facetsReducer, entityToGet, createInitialState);\n\n  const client = useApolloClient();\n\n  function setFacetsCategory(category: string) {\n    dispatch(setLoading(true));\n    if (category === \"All\") {\n      return dispatch(setCategory(category, []));\n    }\n    const facetData = getFacetsData(\"*\", entityToGet, category, client);\n    facetData.then((data) => {\n      dispatch(setCategory(category, data));\n    });\n  }\n\n  function getFacetsQueryData() {\n    dispatch(setLoading(true));\n    const facetData = getFacetsData(inputValue, entityToGet, state.categoryFilterValue, client);\n    facetData.then((data) => {\n      dispatch(setFacetsData(data));\n    });\n  }\n\n  const [anchorEl, setAnchorEl] = useState<HTMLButtonElement | null>(null);\n\n  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const onDelete = (id: string) => {\n    const newState = removeFacet(facetFilters, id);\n    facetFilterSelect(newState);\n  };\n\n  const open = Boolean(anchorEl);\n  const popoverId = open ? \"simple-popover\" : undefined;\n\n  useEffect(() => {\n    if (inputValue) getFacetsQueryData();\n    else dispatch(setFacetsData([]));\n  }, [debouncedInputValue]);\n\n  useEffect(() => {\n    dispatch(resetFacets(entityToGet));\n  }, [id]);\n\n  const handleOptionSelect = (_event, newValue) => {\n    if (newValue) {\n      // Check if the option is already selected to prevent duplicates\n      if (!facetFilters.some((option) => option.id === newValue.id)) {\n        dispatch(selectFacet([newValue, ...facetFilters]));\n        facetFilterSelect([newValue, ...facetFilters]);\n      }\n      // Clear both the value and\n      setValue(null);\n      setInputValue(\"\");\n      // Force-close the dropdown after selection\n      setOptionsOpen(false);\n    }\n  };\n\n  return (\n    <Box>\n      <FilterButton\n        aria-describedby={popoverId}\n        variant=\"text\"\n        onClick={handleClick}\n        sx={{ height: 1 }}\n      >\n        <Box component=\"span\" sx={{ mr: 1 }}>\n          <FontAwesomeIcon icon={faFilter} />\n        </Box>\n        Advanced filters\n        <Box component=\"span\" sx={{ ml: 1 }}>\n          {open ? <FontAwesomeIcon icon={faCaretUp} /> : <FontAwesomeIcon icon={faCaretDown} />}\n        </Box>\n      </FilterButton>\n      <Popover\n        id={popoverId}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        disableScrollLock\n        elevation={1}\n      >\n        <Box sx={{ width: \"450px\", display: \"flex\", p: 3, flexDirection: \"column\", gap: 2 }}>\n          <DataUploader parentAction={handleClose} />\n\n          <Divider flexItem sx={{ my: 1 }} />\n          <Box sx={{ display: \"flex\" }}>\n            <FacetsAutocomplete\n              id=\"facets-search-input\"\n              size=\"small\"\n              noOptionsText=\"Type to search...\"\n              value={value}\n              open={optionsOpen}\n              inputValue={inputValue}\n              loading={state.loading}\n              options={state.dataOptions}\n              filterOptions={(x) => x}\n              getOptionLabel={(option) => option?.label}\n              isOptionEqualToValue={(option, value) => option.id === value?.id}\n              onOpen={() => setOptionsOpen(true)}\n              onClose={() => setOptionsOpen(false)}\n              onChange={handleOptionSelect}\n              onInputChange={(_event, newInputValue) => {\n                setInputValue(newInputValue);\n              }}\n              PopperComponent={FacetsPopper}\n              renderInput={(params) => (\n                <TextField {...params} label={`Search ${entityToGet} filter`} fullWidth />\n              )}\n              renderOption={(props, option) => (\n                <li {...props} key={v1()}>\n                  <FacetListItemContainer>\n                    <FacetListItemLabel>\n                      <Typography\n                        variant=\"body2\"\n                        dangerouslySetInnerHTML={{ __html: option.highlights[0] || option.label }}\n                      />\n                    </FacetListItemLabel>\n                    <FacetListItemCategory>\n                      <Typography variant=\"caption\">in {option.category}</Typography>\n                    </FacetListItemCategory>\n                  </FacetListItemContainer>\n                </li>\n              )}\n            />\n            <FacetsSelect\n              aria-label=\"Facet filter\"\n              value={state.categoryFilterValue}\n              size=\"small\"\n              onChange={(event: SelectChangeEvent) => {\n                setFacetsCategory(event.target.value);\n              }}\n            >\n              {Object.entries(state.availableCategories).map(([key, value]) => (\n                <MenuItem key={key} value={value}>\n                  {key}\n                </MenuItem>\n              ))}\n            </FacetsSelect>\n          </Box>\n          <FacetsSuggestion />\n          <Box sx={{ display: \"flex\", flexWrap: \"wrap\", gap: 1 }}>\n            {facetFilters.map((facet: Facet) => (\n              <Tooltip title={facet.label} key={facet.id} style=\"\" placement=\"bottom\">\n                <Box sx={{ maxWidth: \"150px\" }} key={facet.id}>\n                  <Chip\n                    sx={{\n                      borderRadius: 2,\n                      \"& .MuiChip-label\": {\n                        mr: 1,\n                      },\n                      \"& .MuiChip-deleteIcon\": {\n                        fontSize: \"14px\",\n                      },\n                    }}\n                    clickable\n                    deleteIcon={<FontAwesomeIcon icon={faCircleXmark} size=\"xs\" />}\n                    onDelete={() => {\n                      onDelete(facet.id);\n                    }}\n                    size=\"small\"\n                    label={facet.label}\n                    key={facet.id}\n                  />\n                </Box>\n              </Tooltip>\n            ))}\n          </Box>\n        </Box>\n      </Popover>\n    </Box>\n  );\n}\nexport default FacetsSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: checkPPPaccess",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: checkPPPaccess"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2942, 2956],
              "sourceCode": "import {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  Snackbar,\n  styled,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst PPP_API_URL = \"https://api.partner-platform.opentargets.org/api/v4/graphql\";\nconst PPP_WEB_URL = \"https://partner-platform.opentargets.org\";\nconst FOURTEEN = 14;\n\nconst useStyles = makeStyles((_theme) => ({\n  paper: {\n    padding: \"1em 1em 2em\",\n    borderRadius: \"12px\",\n  },\n  actions: {\n    \"@media (max-width: 767px)\": {\n      flexDirection: \"column\",\n    },\n  },\n  button: {\n    \"@media (max-width: 767px)\": {\n      minHeight: \"auto\",\n      height: \"100%\",\n      width: \"100%\",\n      margin: \"0 !important\",\n      marginTop: \"0.3em !important\",\n    },\n  },\n}));\n\nconst PrimaryButton = styled(Button)`\n  border: none;\n  color: white;\n`;\n\nfunction ShouldAccessPPP() {\n  const location = useLocation();\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n  const classes = useStyles();\n\n  const isOnPublic = () => {\n    const windowLocation = window.location.href;\n    // escape validation on dev mode\n    if (import.meta.env.DEV) return false;\n    return !windowLocation.includes(\"partner\");\n  };\n\n  const shouldShowPopupAfterFixedDays = (DAYS: number) => {\n    const currentDate = new Date();\n    const oldDateObject = JSON.parse(localStorage.getItem(\"ppp-reminder-closed-on\") || \"{}\");\n    if (!oldDateObject.date) return true;\n    const oldDate = new Date(oldDateObject.date);\n    const diffInTime = Math.abs(currentDate.getTime() - oldDate.getTime());\n    const diffInDays = Math.floor(diffInTime / (1000 * 3600 * 24));\n    if (diffInDays >= DAYS) return true;\n    return false;\n  };\n\n  const handleOpenDialog = () => {\n    setDialogOpen(true);\n  };\n\n  const handleCloseDialog = () => {\n    setDialogOpen(false);\n  };\n\n  const handleCloseSnackbar = () => {\n    setSnackbarOpen(false);\n  };\n\n  const remindMeLater = () => {\n    handleCloseDialog();\n    localStorage.setItem(\"ppp-reminder-closed-on\", JSON.stringify({ date: new Date() }));\n    setSnackbarOpen(true);\n  };\n\n  const checkPPPaccess = () => {\n    fetch(PPP_API_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        operationName: \"DataVersion\",\n        variables: {},\n        query: `query DataVersion {\n        meta {\n          dataVersion {\n            month\n            year\n            __typename\n          }\n          __typename\n\t\n      }\n    }`,\n      }),\n    })\n      .then((response) => {\n        if (response.status === 200) handleOpenDialog();\n      })\n      .catch(() => {\n        console.log(\"Does not have access to Partner Preview Platform\");\n      });\n  };\n\n  useEffect(() => {\n    if (isOnPublic() && shouldShowPopupAfterFixedDays(FOURTEEN)) checkPPPaccess();\n  }, []);\n\n  const goToPPP = () => {\n    window.location.href = `${PPP_WEB_URL}${location.pathname}`;\n  };\n\n  return (\n    <>\n      <Dialog\n        onClose={handleCloseDialog}\n        aria-labelledby=\"ppp-reminder\"\n        open={dialogOpen}\n        classes={{\n          paper: classes.paper,\n        }}\n      >\n        <DialogTitle>Looks like you are part of the Open Targets Consortium!</DialogTitle>\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n            We are pleased to inform you that you have access to our exclusive Partner Preview\n            Platform &#40;PPP&#41;. This will have pre-publication data from OTAR projects in\n            addition to all the publicly available data, providing early access to the latest\n            features, updates, and innovations before they are made available to the public.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions className={classes.actions}>\n          <Button className={classes.button} onClick={remindMeLater} variant=\"outlined\">\n            Remind me later\n          </Button>\n          <PrimaryButton\n            className={classes.button}\n            onClick={goToPPP}\n            variant=\"contained\"\n            color=\"primary\"\n          >\n            Continue on Partner Preview Platform\n          </PrimaryButton>\n        </DialogActions>\n      </Dialog>\n\n      <Snackbar\n        open={snackbarOpen}\n        onClose={handleCloseSnackbar}\n        message=\"We will remind you in a couple of weeks\"\n        autoHideDuration={3000}\n      />\n    </>\n  );\n}\n\nexport default ShouldAccessPPP;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/ShouldAccessPPP.tsx" },
        "span": [2859, 2868],
        "sourceCode": "import {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  Snackbar,\n  styled,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst PPP_API_URL = \"https://api.partner-platform.opentargets.org/api/v4/graphql\";\nconst PPP_WEB_URL = \"https://partner-platform.opentargets.org\";\nconst FOURTEEN = 14;\n\nconst useStyles = makeStyles((_theme) => ({\n  paper: {\n    padding: \"1em 1em 2em\",\n    borderRadius: \"12px\",\n  },\n  actions: {\n    \"@media (max-width: 767px)\": {\n      flexDirection: \"column\",\n    },\n  },\n  button: {\n    \"@media (max-width: 767px)\": {\n      minHeight: \"auto\",\n      height: \"100%\",\n      width: \"100%\",\n      margin: \"0 !important\",\n      marginTop: \"0.3em !important\",\n    },\n  },\n}));\n\nconst PrimaryButton = styled(Button)`\n  border: none;\n  color: white;\n`;\n\nfunction ShouldAccessPPP() {\n  const location = useLocation();\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n  const classes = useStyles();\n\n  const isOnPublic = () => {\n    const windowLocation = window.location.href;\n    // escape validation on dev mode\n    if (import.meta.env.DEV) return false;\n    return !windowLocation.includes(\"partner\");\n  };\n\n  const shouldShowPopupAfterFixedDays = (DAYS: number) => {\n    const currentDate = new Date();\n    const oldDateObject = JSON.parse(localStorage.getItem(\"ppp-reminder-closed-on\") || \"{}\");\n    if (!oldDateObject.date) return true;\n    const oldDate = new Date(oldDateObject.date);\n    const diffInTime = Math.abs(currentDate.getTime() - oldDate.getTime());\n    const diffInDays = Math.floor(diffInTime / (1000 * 3600 * 24));\n    if (diffInDays >= DAYS) return true;\n    return false;\n  };\n\n  const handleOpenDialog = () => {\n    setDialogOpen(true);\n  };\n\n  const handleCloseDialog = () => {\n    setDialogOpen(false);\n  };\n\n  const handleCloseSnackbar = () => {\n    setSnackbarOpen(false);\n  };\n\n  const remindMeLater = () => {\n    handleCloseDialog();\n    localStorage.setItem(\"ppp-reminder-closed-on\", JSON.stringify({ date: new Date() }));\n    setSnackbarOpen(true);\n  };\n\n  const checkPPPaccess = () => {\n    fetch(PPP_API_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        operationName: \"DataVersion\",\n        variables: {},\n        query: `query DataVersion {\n        meta {\n          dataVersion {\n            month\n            year\n            __typename\n          }\n          __typename\n\t\n      }\n    }`,\n      }),\n    })\n      .then((response) => {\n        if (response.status === 200) handleOpenDialog();\n      })\n      .catch(() => {\n        console.log(\"Does not have access to Partner Preview Platform\");\n      });\n  };\n\n  useEffect(() => {\n    if (isOnPublic() && shouldShowPopupAfterFixedDays(FOURTEEN)) checkPPPaccess();\n  }, []);\n\n  const goToPPP = () => {\n    window.location.href = `${PPP_WEB_URL}${location.pathname}`;\n  };\n\n  return (\n    <>\n      <Dialog\n        onClose={handleCloseDialog}\n        aria-labelledby=\"ppp-reminder\"\n        open={dialogOpen}\n        classes={{\n          paper: classes.paper,\n        }}\n      >\n        <DialogTitle>Looks like you are part of the Open Targets Consortium!</DialogTitle>\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n            We are pleased to inform you that you have access to our exclusive Partner Preview\n            Platform &#40;PPP&#41;. This will have pre-publication data from OTAR projects in\n            addition to all the publicly available data, providing early access to the latest\n            features, updates, and innovations before they are made available to the public.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions className={classes.actions}>\n          <Button className={classes.button} onClick={remindMeLater} variant=\"outlined\">\n            Remind me later\n          </Button>\n          <PrimaryButton\n            className={classes.button}\n            onClick={goToPPP}\n            variant=\"contained\"\n            color=\"primary\"\n          >\n            Continue on Partner Preview Platform\n          </PrimaryButton>\n        </DialogActions>\n      </Dialog>\n\n      <Snackbar\n        open={snackbarOpen}\n        onClose={handleCloseSnackbar}\n        message=\"We will remind you in a couple of weeks\"\n        autoHideDuration={3000}\n      />\n    </>\n  );\n}\n\nexport default ShouldAccessPPP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: isOnPublic",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: isOnPublic"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2885, 2895],
              "sourceCode": "import {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  Snackbar,\n  styled,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst PPP_API_URL = \"https://api.partner-platform.opentargets.org/api/v4/graphql\";\nconst PPP_WEB_URL = \"https://partner-platform.opentargets.org\";\nconst FOURTEEN = 14;\n\nconst useStyles = makeStyles((_theme) => ({\n  paper: {\n    padding: \"1em 1em 2em\",\n    borderRadius: \"12px\",\n  },\n  actions: {\n    \"@media (max-width: 767px)\": {\n      flexDirection: \"column\",\n    },\n  },\n  button: {\n    \"@media (max-width: 767px)\": {\n      minHeight: \"auto\",\n      height: \"100%\",\n      width: \"100%\",\n      margin: \"0 !important\",\n      marginTop: \"0.3em !important\",\n    },\n  },\n}));\n\nconst PrimaryButton = styled(Button)`\n  border: none;\n  color: white;\n`;\n\nfunction ShouldAccessPPP() {\n  const location = useLocation();\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n  const classes = useStyles();\n\n  const isOnPublic = () => {\n    const windowLocation = window.location.href;\n    // escape validation on dev mode\n    if (import.meta.env.DEV) return false;\n    return !windowLocation.includes(\"partner\");\n  };\n\n  const shouldShowPopupAfterFixedDays = (DAYS: number) => {\n    const currentDate = new Date();\n    const oldDateObject = JSON.parse(localStorage.getItem(\"ppp-reminder-closed-on\") || \"{}\");\n    if (!oldDateObject.date) return true;\n    const oldDate = new Date(oldDateObject.date);\n    const diffInTime = Math.abs(currentDate.getTime() - oldDate.getTime());\n    const diffInDays = Math.floor(diffInTime / (1000 * 3600 * 24));\n    if (diffInDays >= DAYS) return true;\n    return false;\n  };\n\n  const handleOpenDialog = () => {\n    setDialogOpen(true);\n  };\n\n  const handleCloseDialog = () => {\n    setDialogOpen(false);\n  };\n\n  const handleCloseSnackbar = () => {\n    setSnackbarOpen(false);\n  };\n\n  const remindMeLater = () => {\n    handleCloseDialog();\n    localStorage.setItem(\"ppp-reminder-closed-on\", JSON.stringify({ date: new Date() }));\n    setSnackbarOpen(true);\n  };\n\n  const checkPPPaccess = () => {\n    fetch(PPP_API_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        operationName: \"DataVersion\",\n        variables: {},\n        query: `query DataVersion {\n        meta {\n          dataVersion {\n            month\n            year\n            __typename\n          }\n          __typename\n\t\n      }\n    }`,\n      }),\n    })\n      .then((response) => {\n        if (response.status === 200) handleOpenDialog();\n      })\n      .catch(() => {\n        console.log(\"Does not have access to Partner Preview Platform\");\n      });\n  };\n\n  useEffect(() => {\n    if (isOnPublic() && shouldShowPopupAfterFixedDays(FOURTEEN)) checkPPPaccess();\n  }, []);\n\n  const goToPPP = () => {\n    window.location.href = `${PPP_WEB_URL}${location.pathname}`;\n  };\n\n  return (\n    <>\n      <Dialog\n        onClose={handleCloseDialog}\n        aria-labelledby=\"ppp-reminder\"\n        open={dialogOpen}\n        classes={{\n          paper: classes.paper,\n        }}\n      >\n        <DialogTitle>Looks like you are part of the Open Targets Consortium!</DialogTitle>\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n            We are pleased to inform you that you have access to our exclusive Partner Preview\n            Platform &#40;PPP&#41;. This will have pre-publication data from OTAR projects in\n            addition to all the publicly available data, providing early access to the latest\n            features, updates, and innovations before they are made available to the public.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions className={classes.actions}>\n          <Button className={classes.button} onClick={remindMeLater} variant=\"outlined\">\n            Remind me later\n          </Button>\n          <PrimaryButton\n            className={classes.button}\n            onClick={goToPPP}\n            variant=\"contained\"\n            color=\"primary\"\n          >\n            Continue on Partner Preview Platform\n          </PrimaryButton>\n        </DialogActions>\n      </Dialog>\n\n      <Snackbar\n        open={snackbarOpen}\n        onClose={handleCloseSnackbar}\n        message=\"We will remind you in a couple of weeks\"\n        autoHideDuration={3000}\n      />\n    </>\n  );\n}\n\nexport default ShouldAccessPPP;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/ShouldAccessPPP.tsx" },
        "span": [2859, 2868],
        "sourceCode": "import {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  Snackbar,\n  styled,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst PPP_API_URL = \"https://api.partner-platform.opentargets.org/api/v4/graphql\";\nconst PPP_WEB_URL = \"https://partner-platform.opentargets.org\";\nconst FOURTEEN = 14;\n\nconst useStyles = makeStyles((_theme) => ({\n  paper: {\n    padding: \"1em 1em 2em\",\n    borderRadius: \"12px\",\n  },\n  actions: {\n    \"@media (max-width: 767px)\": {\n      flexDirection: \"column\",\n    },\n  },\n  button: {\n    \"@media (max-width: 767px)\": {\n      minHeight: \"auto\",\n      height: \"100%\",\n      width: \"100%\",\n      margin: \"0 !important\",\n      marginTop: \"0.3em !important\",\n    },\n  },\n}));\n\nconst PrimaryButton = styled(Button)`\n  border: none;\n  color: white;\n`;\n\nfunction ShouldAccessPPP() {\n  const location = useLocation();\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n  const classes = useStyles();\n\n  const isOnPublic = () => {\n    const windowLocation = window.location.href;\n    // escape validation on dev mode\n    if (import.meta.env.DEV) return false;\n    return !windowLocation.includes(\"partner\");\n  };\n\n  const shouldShowPopupAfterFixedDays = (DAYS: number) => {\n    const currentDate = new Date();\n    const oldDateObject = JSON.parse(localStorage.getItem(\"ppp-reminder-closed-on\") || \"{}\");\n    if (!oldDateObject.date) return true;\n    const oldDate = new Date(oldDateObject.date);\n    const diffInTime = Math.abs(currentDate.getTime() - oldDate.getTime());\n    const diffInDays = Math.floor(diffInTime / (1000 * 3600 * 24));\n    if (diffInDays >= DAYS) return true;\n    return false;\n  };\n\n  const handleOpenDialog = () => {\n    setDialogOpen(true);\n  };\n\n  const handleCloseDialog = () => {\n    setDialogOpen(false);\n  };\n\n  const handleCloseSnackbar = () => {\n    setSnackbarOpen(false);\n  };\n\n  const remindMeLater = () => {\n    handleCloseDialog();\n    localStorage.setItem(\"ppp-reminder-closed-on\", JSON.stringify({ date: new Date() }));\n    setSnackbarOpen(true);\n  };\n\n  const checkPPPaccess = () => {\n    fetch(PPP_API_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        operationName: \"DataVersion\",\n        variables: {},\n        query: `query DataVersion {\n        meta {\n          dataVersion {\n            month\n            year\n            __typename\n          }\n          __typename\n\t\n      }\n    }`,\n      }),\n    })\n      .then((response) => {\n        if (response.status === 200) handleOpenDialog();\n      })\n      .catch(() => {\n        console.log(\"Does not have access to Partner Preview Platform\");\n      });\n  };\n\n  useEffect(() => {\n    if (isOnPublic() && shouldShowPopupAfterFixedDays(FOURTEEN)) checkPPPaccess();\n  }, []);\n\n  const goToPPP = () => {\n    window.location.href = `${PPP_WEB_URL}${location.pathname}`;\n  };\n\n  return (\n    <>\n      <Dialog\n        onClose={handleCloseDialog}\n        aria-labelledby=\"ppp-reminder\"\n        open={dialogOpen}\n        classes={{\n          paper: classes.paper,\n        }}\n      >\n        <DialogTitle>Looks like you are part of the Open Targets Consortium!</DialogTitle>\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n            We are pleased to inform you that you have access to our exclusive Partner Preview\n            Platform &#40;PPP&#41;. This will have pre-publication data from OTAR projects in\n            addition to all the publicly available data, providing early access to the latest\n            features, updates, and innovations before they are made available to the public.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions className={classes.actions}>\n          <Button className={classes.button} onClick={remindMeLater} variant=\"outlined\">\n            Remind me later\n          </Button>\n          <PrimaryButton\n            className={classes.button}\n            onClick={goToPPP}\n            variant=\"contained\"\n            color=\"primary\"\n          >\n            Continue on Partner Preview Platform\n          </PrimaryButton>\n        </DialogActions>\n      </Dialog>\n\n      <Snackbar\n        open={snackbarOpen}\n        onClose={handleCloseSnackbar}\n        message=\"We will remind you in a couple of weeks\"\n        autoHideDuration={3000}\n      />\n    </>\n  );\n}\n\nexport default ShouldAccessPPP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: shouldShowPopupAfterFixedDays",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: shouldShowPopupAfterFixedDays"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2901, 2930],
              "sourceCode": "import {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  Snackbar,\n  styled,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst PPP_API_URL = \"https://api.partner-platform.opentargets.org/api/v4/graphql\";\nconst PPP_WEB_URL = \"https://partner-platform.opentargets.org\";\nconst FOURTEEN = 14;\n\nconst useStyles = makeStyles((_theme) => ({\n  paper: {\n    padding: \"1em 1em 2em\",\n    borderRadius: \"12px\",\n  },\n  actions: {\n    \"@media (max-width: 767px)\": {\n      flexDirection: \"column\",\n    },\n  },\n  button: {\n    \"@media (max-width: 767px)\": {\n      minHeight: \"auto\",\n      height: \"100%\",\n      width: \"100%\",\n      margin: \"0 !important\",\n      marginTop: \"0.3em !important\",\n    },\n  },\n}));\n\nconst PrimaryButton = styled(Button)`\n  border: none;\n  color: white;\n`;\n\nfunction ShouldAccessPPP() {\n  const location = useLocation();\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n  const classes = useStyles();\n\n  const isOnPublic = () => {\n    const windowLocation = window.location.href;\n    // escape validation on dev mode\n    if (import.meta.env.DEV) return false;\n    return !windowLocation.includes(\"partner\");\n  };\n\n  const shouldShowPopupAfterFixedDays = (DAYS: number) => {\n    const currentDate = new Date();\n    const oldDateObject = JSON.parse(localStorage.getItem(\"ppp-reminder-closed-on\") || \"{}\");\n    if (!oldDateObject.date) return true;\n    const oldDate = new Date(oldDateObject.date);\n    const diffInTime = Math.abs(currentDate.getTime() - oldDate.getTime());\n    const diffInDays = Math.floor(diffInTime / (1000 * 3600 * 24));\n    if (diffInDays >= DAYS) return true;\n    return false;\n  };\n\n  const handleOpenDialog = () => {\n    setDialogOpen(true);\n  };\n\n  const handleCloseDialog = () => {\n    setDialogOpen(false);\n  };\n\n  const handleCloseSnackbar = () => {\n    setSnackbarOpen(false);\n  };\n\n  const remindMeLater = () => {\n    handleCloseDialog();\n    localStorage.setItem(\"ppp-reminder-closed-on\", JSON.stringify({ date: new Date() }));\n    setSnackbarOpen(true);\n  };\n\n  const checkPPPaccess = () => {\n    fetch(PPP_API_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        operationName: \"DataVersion\",\n        variables: {},\n        query: `query DataVersion {\n        meta {\n          dataVersion {\n            month\n            year\n            __typename\n          }\n          __typename\n\t\n      }\n    }`,\n      }),\n    })\n      .then((response) => {\n        if (response.status === 200) handleOpenDialog();\n      })\n      .catch(() => {\n        console.log(\"Does not have access to Partner Preview Platform\");\n      });\n  };\n\n  useEffect(() => {\n    if (isOnPublic() && shouldShowPopupAfterFixedDays(FOURTEEN)) checkPPPaccess();\n  }, []);\n\n  const goToPPP = () => {\n    window.location.href = `${PPP_WEB_URL}${location.pathname}`;\n  };\n\n  return (\n    <>\n      <Dialog\n        onClose={handleCloseDialog}\n        aria-labelledby=\"ppp-reminder\"\n        open={dialogOpen}\n        classes={{\n          paper: classes.paper,\n        }}\n      >\n        <DialogTitle>Looks like you are part of the Open Targets Consortium!</DialogTitle>\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n            We are pleased to inform you that you have access to our exclusive Partner Preview\n            Platform &#40;PPP&#41;. This will have pre-publication data from OTAR projects in\n            addition to all the publicly available data, providing early access to the latest\n            features, updates, and innovations before they are made available to the public.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions className={classes.actions}>\n          <Button className={classes.button} onClick={remindMeLater} variant=\"outlined\">\n            Remind me later\n          </Button>\n          <PrimaryButton\n            className={classes.button}\n            onClick={goToPPP}\n            variant=\"contained\"\n            color=\"primary\"\n          >\n            Continue on Partner Preview Platform\n          </PrimaryButton>\n        </DialogActions>\n      </Dialog>\n\n      <Snackbar\n        open={snackbarOpen}\n        onClose={handleCloseSnackbar}\n        message=\"We will remind you in a couple of weeks\"\n        autoHideDuration={3000}\n      />\n    </>\n  );\n}\n\nexport default ShouldAccessPPP;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/components/ShouldAccessPPP.tsx" },
        "span": [2859, 2868],
        "sourceCode": "import {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  Snackbar,\n  styled,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst PPP_API_URL = \"https://api.partner-platform.opentargets.org/api/v4/graphql\";\nconst PPP_WEB_URL = \"https://partner-platform.opentargets.org\";\nconst FOURTEEN = 14;\n\nconst useStyles = makeStyles((_theme) => ({\n  paper: {\n    padding: \"1em 1em 2em\",\n    borderRadius: \"12px\",\n  },\n  actions: {\n    \"@media (max-width: 767px)\": {\n      flexDirection: \"column\",\n    },\n  },\n  button: {\n    \"@media (max-width: 767px)\": {\n      minHeight: \"auto\",\n      height: \"100%\",\n      width: \"100%\",\n      margin: \"0 !important\",\n      marginTop: \"0.3em !important\",\n    },\n  },\n}));\n\nconst PrimaryButton = styled(Button)`\n  border: none;\n  color: white;\n`;\n\nfunction ShouldAccessPPP() {\n  const location = useLocation();\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n  const classes = useStyles();\n\n  const isOnPublic = () => {\n    const windowLocation = window.location.href;\n    // escape validation on dev mode\n    if (import.meta.env.DEV) return false;\n    return !windowLocation.includes(\"partner\");\n  };\n\n  const shouldShowPopupAfterFixedDays = (DAYS: number) => {\n    const currentDate = new Date();\n    const oldDateObject = JSON.parse(localStorage.getItem(\"ppp-reminder-closed-on\") || \"{}\");\n    if (!oldDateObject.date) return true;\n    const oldDate = new Date(oldDateObject.date);\n    const diffInTime = Math.abs(currentDate.getTime() - oldDate.getTime());\n    const diffInDays = Math.floor(diffInTime / (1000 * 3600 * 24));\n    if (diffInDays >= DAYS) return true;\n    return false;\n  };\n\n  const handleOpenDialog = () => {\n    setDialogOpen(true);\n  };\n\n  const handleCloseDialog = () => {\n    setDialogOpen(false);\n  };\n\n  const handleCloseSnackbar = () => {\n    setSnackbarOpen(false);\n  };\n\n  const remindMeLater = () => {\n    handleCloseDialog();\n    localStorage.setItem(\"ppp-reminder-closed-on\", JSON.stringify({ date: new Date() }));\n    setSnackbarOpen(true);\n  };\n\n  const checkPPPaccess = () => {\n    fetch(PPP_API_URL, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        operationName: \"DataVersion\",\n        variables: {},\n        query: `query DataVersion {\n        meta {\n          dataVersion {\n            month\n            year\n            __typename\n          }\n          __typename\n\t\n      }\n    }`,\n      }),\n    })\n      .then((response) => {\n        if (response.status === 200) handleOpenDialog();\n      })\n      .catch(() => {\n        console.log(\"Does not have access to Partner Preview Platform\");\n      });\n  };\n\n  useEffect(() => {\n    if (isOnPublic() && shouldShowPopupAfterFixedDays(FOURTEEN)) checkPPPaccess();\n  }, []);\n\n  const goToPPP = () => {\n    window.location.href = `${PPP_WEB_URL}${location.pathname}`;\n  };\n\n  return (\n    <>\n      <Dialog\n        onClose={handleCloseDialog}\n        aria-labelledby=\"ppp-reminder\"\n        open={dialogOpen}\n        classes={{\n          paper: classes.paper,\n        }}\n      >\n        <DialogTitle>Looks like you are part of the Open Targets Consortium!</DialogTitle>\n        <DialogContent>\n          <DialogContentText id=\"alert-dialog-description\">\n            We are pleased to inform you that you have access to our exclusive Partner Preview\n            Platform &#40;PPP&#41;. This will have pre-publication data from OTAR projects in\n            addition to all the publicly available data, providing early access to the latest\n            features, updates, and innovations before they are made available to the public.\n          </DialogContentText>\n        </DialogContent>\n        <DialogActions className={classes.actions}>\n          <Button className={classes.button} onClick={remindMeLater} variant=\"outlined\">\n            Remind me later\n          </Button>\n          <PrimaryButton\n            className={classes.button}\n            onClick={goToPPP}\n            variant=\"contained\"\n            color=\"primary\"\n          >\n            Continue on Partner Preview Platform\n          </PrimaryButton>\n        </DialogActions>\n      </Dialog>\n\n      <Snackbar\n        open={snackbarOpen}\n        onClose={handleCloseSnackbar}\n        message=\"We will remind you in a couple of weeks\"\n        autoHideDuration={3000}\n      />\n    </>\n  );\n}\n\nexport default ShouldAccessPPP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/DiseasePage/ProfileHeader.jsx" },
        "span": [404, 859],
        "sourceCode": "import { usePlatformApi } from \"ui\";\nimport { ProfileHeader as BaseProfileHeader, ProfileChipList, ProfileDescription } from \"ui\";\n\nimport DISEASE_PROFILE_HEADER_FRAGMENT from \"./ProfileHeader.gql\";\n\n/**\n * Disease synonyms are organized by \"relation\", each with a list of \"terms\".\n * The same term can appear under different relations.\n */\nconst parseSynonyms = (diseaseSynonyms) => {\n  const t = [];\n  diseaseSynonyms.forEach((s) => {\n    s.terms.forEach((syn) => {\n      const thisSyn = t.find((tItem) => tItem.label === syn);\n      if (!thisSyn) {\n        // if the synonyms is not already in the list, we add it\n        t.push({ label: syn, tooltip: [s.relation] });\n      } else {\n        // if it already exist, just add the relation to it\n        // (i.e. it will have multiple relations)\n        thisSyn.tooltip.push(s.relation);\n      }\n    });\n  });\n  // convert the tooltip array to a string for display in the Tooltip component\n  t.map((tItem) => {\n    const syn = tItem;\n    syn.tooltip = tItem.tooltip.join(\", \");\n    return syn;\n  });\n  return t;\n};\n\nfunction ProfileHeader() {\n  const { loading, error, data } = usePlatformApi();\n  const diseaseSynonyms = parseSynonyms(data?.disease.synonyms || []);\n\n  // TODO: Errors!\n  if (error) return null;\n\n  return (\n    <BaseProfileHeader>\n      <ProfileDescription loading={loading}>{data?.disease.description}</ProfileDescription>\n      {diseaseSynonyms.length > 0 ? (\n        <ProfileChipList title=\"Synonyms\" loading={loading}>\n          {diseaseSynonyms}\n        </ProfileChipList>\n      ) : null}\n    </BaseProfileHeader>\n  );\n}\n\nProfileHeader.fragments = {\n  profileHeader: DISEASE_PROFILE_HEADER_FRAGMENT,\n};\n\nexport default ProfileHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/DiseasePage/ProfileHeader.jsx" },
        "span": [441, 853],
        "sourceCode": "import { usePlatformApi } from \"ui\";\nimport { ProfileHeader as BaseProfileHeader, ProfileChipList, ProfileDescription } from \"ui\";\n\nimport DISEASE_PROFILE_HEADER_FRAGMENT from \"./ProfileHeader.gql\";\n\n/**\n * Disease synonyms are organized by \"relation\", each with a list of \"terms\".\n * The same term can appear under different relations.\n */\nconst parseSynonyms = (diseaseSynonyms) => {\n  const t = [];\n  diseaseSynonyms.forEach((s) => {\n    s.terms.forEach((syn) => {\n      const thisSyn = t.find((tItem) => tItem.label === syn);\n      if (!thisSyn) {\n        // if the synonyms is not already in the list, we add it\n        t.push({ label: syn, tooltip: [s.relation] });\n      } else {\n        // if it already exist, just add the relation to it\n        // (i.e. it will have multiple relations)\n        thisSyn.tooltip.push(s.relation);\n      }\n    });\n  });\n  // convert the tooltip array to a string for display in the Tooltip component\n  t.map((tItem) => {\n    const syn = tItem;\n    syn.tooltip = tItem.tooltip.join(\", \");\n    return syn;\n  });\n  return t;\n};\n\nfunction ProfileHeader() {\n  const { loading, error, data } = usePlatformApi();\n  const diseaseSynonyms = parseSynonyms(data?.disease.synonyms || []);\n\n  // TODO: Errors!\n  if (error) return null;\n\n  return (\n    <BaseProfileHeader>\n      <ProfileDescription loading={loading}>{data?.disease.description}</ProfileDescription>\n      {diseaseSynonyms.length > 0 ? (\n        <ProfileChipList title=\"Synonyms\" loading={loading}>\n          {diseaseSynonyms}\n        </ProfileChipList>\n      ) : null}\n    </BaseProfileHeader>\n  );\n}\n\nProfileHeader.fragments = {\n  profileHeader: DISEASE_PROFILE_HEADER_FRAGMENT,\n};\n\nexport default ProfileHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/useKeyWithClickEvents",
      "severity": "error",
      "description": "Enforce to have the onClick mouse event with the onKeyUp, the onKeyDown, or the onKeyPress keyboard event.",
      "message": [
        { "elements": [], "content": "Enforce to have the " },
        { "elements": ["Emphasis"], "content": "onClick" },
        { "elements": [], "content": " mouse event with the " },
        { "elements": ["Emphasis"], "content": "onKeyUp" },
        { "elements": [], "content": ", the " },
        { "elements": ["Emphasis"], "content": "onKeyDown" },
        { "elements": [], "content": ", or the " },
        { "elements": ["Emphasis"], "content": "onKeyPress" },
        { "elements": [], "content": " keyboard event." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/DownloadsPage/ContainedInDrawer.tsx" },
        "span": [1840, 1875],
        "sourceCode": "import { faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Drawer, IconButton, Paper, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { type ReactNode, useState } from \"react\";\n\nconst useStyles = makeStyles((theme) => ({\n  backdrop: {\n    \"& .MuiBackdrop-root\": {\n      opacity: \"0 !important\",\n    },\n  },\n  container: {\n    backgroundColor: theme.palette.grey[300],\n  },\n  title: {\n    display: \"flex\",\n    justifyContent: \"space-between\",\n    backgroundColor: \"white\",\n    borderBottom: \"1px solid #ccc\",\n    fontSize: \"1.2rem\",\n    fontWeight: \"bold\",\n    padding: \"1rem\",\n  },\n  paper: {\n    width: \"420px\",\n    margin: \"1.5rem\",\n    padding: \"1rem\",\n  },\n  resourceURL: {\n    marginBottom: \"8px\",\n    padding: \"10px\",\n    wordBreak: \"break-all\",\n    backgroundColor: theme.palette.grey[800],\n    color: \"white\",\n  },\n  ftpURL: {\n    color: \"white\",\n    textDecoration: \"none\",\n  },\n}));\n\nconst FORMAT_MAPPING = {\n  \"application/x-parquet\": \"parquet\",\n};\n\ntype ContainedInDrawerProps = {\n  title: string;\n  link: string;\n  location: \"gcp-location\" | \"ftp-location\";\n  format: string;\n  version: \"string\";\n  path: \"string\";\n  children: ReactNode;\n};\n\nfunction ContainedInDrawer({\n  title,\n  link,\n  children,\n  location,\n  format,\n  version,\n  path,\n}: ContainedInDrawerProps) {\n  const classes = useStyles();\n  const [open, setOpen] = useState(false);\n\n  function toggleOpen() {\n    setOpen(!open);\n  }\n\n  function close() {\n    setOpen(false);\n  }\n\n  function getCommands() {\n    if (location === \"ftp-location\")\n      return <FtpLocation link={link} version={version} path={path} />;\n    if (location === \"gcp-location\") return <GcpLocation link={link} />;\n    return <>Invalid path</>;\n  }\n\n  return (\n    <span>\n      <span onClick={() => toggleOpen()}>{children}</span>\n      <Drawer\n        classes={{ root: classes.backdrop, paper: classes.container }}\n        open={open}\n        onClose={() => close()}\n        anchor=\"right\"\n      >\n        <Typography className={classes.title}>\n          {title}\n          <IconButton onClick={() => close()}>\n            <FontAwesomeIcon icon={faXmark} />\n          </IconButton>\n        </Typography>\n\n        <Paper className={classes.paper} variant=\"outlined\">\n          <Typography sx={{ textTransform: \"capitalize\" }} variant=\"h6\" gutterBottom>\n            {FORMAT_MAPPING[format]} Data Format\n          </Typography>\n          {getCommands()}\n        </Paper>\n      </Drawer>\n    </span>\n  );\n}\n\nfunction FtpLocation({ link, version, path }) {\n  const classes = useStyles();\n\n  return (\n    <>\n      <Typography variant=\"subtitle2\" gutterBottom>\n        FTP location (link)\n      </Typography>\n      <div className={classes.resourceURL}>\n        <a className={classes.ftpURL} href={link}>\n          {link}\n        </a>\n      </div>\n\n      <Typography>rsync</Typography>\n      <div className={classes.resourceURL}>\n        rsync -rpltvz --delete rsync.ebi.ac.uk::pub/databases/opentargets/platform/{version}/output/\n        {path} .\n      </div>\n      <Typography variant=\"subtitle2\" gutterBottom>\n        Wget\n      </Typography>\n      <div className={classes.resourceURL}>\n        wget --recursive --no-parent --no-host-directories --cut-dirs 6\n        ftp://ftp.ebi.ac.uk/pub/databases/opentargets/platform/{version}/output/{path} .\n      </div>\n    </>\n  );\n}\n\nfunction GcpLocation({ link }) {\n  const classes = useStyles();\n\n  return (\n    <>\n      <Typography variant=\"subtitle2\" gutterBottom>\n        Google Cloud\n      </Typography>\n      <div className={classes.resourceURL}>gsutil -m cp -r {link}/</div>\n    </>\n  );\n}\n\nexport default ContainedInDrawer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useBatchQuery.ts" },
        "span": [3226, 3385],
        "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: variables",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: variables"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1920, 1929],
              "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useBatchQuery.ts" },
        "span": [1900, 1907],
        "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: JSON.stringify(variables)",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: JSON.stringify(variables)"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1935, 1960],
              "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useBatchQuery.ts" },
        "span": [1900, 1907],
        "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies a dependency more specific that its captures: variables.variantId",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies a dependency more specific that its captures: variables.variantId"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This capture is more generic than..." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [4134, 4143],
              "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
            }
          },
          { "log": ["info", [{ "elements": [], "content": "...this dependency." }]] },
          {
            "frame": {
              "path": null,
              "span": [4381, 4400],
              "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useBatchQuery.ts" },
        "span": [4096, 4105],
        "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: variables",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: variables"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4134, 4143],
              "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useBatchQuery.ts" },
        "span": [4096, 4105],
        "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: id",
      "message": [
        { "elements": [], "content": "This hook specifies more dependencies than necessary: id" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Outer scope values aren't valid dependencies because mutating them doesn't re-render the component."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4368, 4370],
              "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useBatchQuery.ts" },
        "span": [4096, 4105],
        "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { tableChunkSize } from \"@ot/constants\";\nimport _ from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\ntype BatchQueryState<T = unknown> = {\n  loading: boolean;\n  error: Error | null;\n  data: T | null;\n};\n\ntype UseBatchQueryProps = {\n  query: DocumentNode;\n  variables: Record<string, unknown>;\n  dataPath: string;\n  size?: number;\n  rowField?: string;\n  countField?: string;\n  id?: string;\n  enabled?: boolean;\n};\n\n/**\n * Provides functionality to asynchronously batch-download a complete dataset\n * from the backend, handling pagination automatically.\n *\n * @param {DocumentNode} query - GraphQL query to run\n * @param {Record<string, unknown>} variables - Variables for the query\n * @param {string} dataPath - Path where data is located in the response\n * @param {number} [size=tableChunkSize] - Size of each chunk to fetch\n * @param {string} [rowField=rows] - Field containing the rows in dataPath\n * @param {string} [countField=count] - Field containing the row count in dataPath\n * @param {string} [id] - Unique identifier to trigger refetches\n * @param {boolean} [enabled=true] - Whether to enable the query\n *\n * @returns {BatchQueryState<T>} Current state of the batch query\n */\nfunction useBatchQuery<T = any>({\n  query,\n  variables,\n  dataPath,\n  size = tableChunkSize,\n  rowField = \"rows\",\n  countField = \"count\",\n  id,\n  enabled = true,\n}: UseBatchQueryProps): BatchQueryState<T> {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const [state, setState] = useState<BatchQueryState<T>>({\n    loading: true,\n    error: null,\n    data: null,\n  });\n\n  // Memoize variables to prevent unnecessary re-renders\n  const memoizedVariables = useMemo(() => ({ ...variables }), [JSON.stringify(variables)]);\n\n  // Function to get a single data chunk\n  const getDataChunk = useCallback(\n    (index: number) => {\n      return client.query({\n        query,\n        variables: { ...memoizedVariables, index, size },\n      });\n    },\n    [client, query, memoizedVariables, size]\n  );\n\n  // Function to retrieve the entire dataset\n  const fetchWholeDataset = useCallback(async () => {\n    setState((prev) => ({ ...prev, loading: true }));\n\n    try {\n      // Fetch first chunk to get total count\n      const firstChunk = await getDataChunk(0);\n\n      if (!firstChunk.data) {\n        throw new Error(\"No data returned from first chunk\");\n      }\n\n      // Get data from first chunk\n      let allRows = [...getRows<T>(firstChunk.data, rowPath)];\n\n      // Calculate how many chunks we need based on count\n      const totalCount = _.get(firstChunk.data, countPath, 0);\n      const totalChunks = Math.ceil(totalCount / size);\n\n      if (totalChunks > 1) {\n        // Prepare promises for remaining chunks\n        const chunkPromises = Array.from({ length: totalChunks - 1 }, (_, i) =>\n          getDataChunk(i + 1)\n        );\n\n        // Fetch all remaining chunks in parallel\n        const remainingChunks = await Promise.all(chunkPromises);\n\n        // Combine all data\n        remainingChunks.forEach((chunk) => {\n          if (chunk.data) {\n            allRows = [...allRows, ...getRows<T>(chunk.data, rowPath)];\n          }\n        });\n      }\n\n      // Create a deep clone of the first chunk's complete response\n      const completeResponse = _.cloneDeep(firstChunk.data);\n\n      // Update the row data at the specified path\n      _.set(completeResponse, rowPath, allRows);\n\n      // Update state with the complete response\n      setState({\n        loading: false,\n        error: null,\n        data: completeResponse,\n      });\n\n      return completeResponse;\n    } catch (error) {\n      setState({\n        loading: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        data: null,\n      });\n      throw error;\n    }\n  }, [getDataChunk, rowPath, countPath, size]);\n\n  // Fetch data when dependencies change\n  useEffect(() => {\n    if (!enabled || variables === null) {\n      setState((prev) => ({ ...prev, loading: false }));\n      return;\n    }\n\n    fetchWholeDataset().catch((error) => {\n      console.error(\"Error fetching batch data:\", error);\n    });\n  }, [fetchWholeDataset, id, enabled, variables.variantId]);\n\n  return state;\n}\n\n// Helper function to get rows from data\nfunction getRows<T>(data: any, dataPath: string): T[] {\n  return _.get(data, dataPath, []);\n}\n\nexport default useBatchQuery;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/EvidencePage/ProfileHeader.jsx" },
        "span": [754, 1209],
        "sourceCode": "import { faDna, faStethoscope } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Card, CardContent, CardHeader, Skeleton, Typography } from \"@mui/material\";\nimport {\n  ProfileHeader as BaseProfileHeader,\n  Link,\n  ProfileChipList,\n  ProfileDescription,\n  usePlatformApi,\n} from \"ui\";\n\nimport { makeStyles } from \"@mui/styles\";\n\nconst useStyles = makeStyles((theme) => ({\n  card: { height: \"100%\" },\n  cardContent: {\n    borderTop: `1px solid ${theme.palette.grey[300]}`,\n  },\n}));\n\n/**\n * Disease synonyms are organized by \"relation\", each with a list of \"terms\".\n * The same term can appear under different relations.\n */\nconst parseSynonyms = (diseaseSynonyms) => {\n  const t = [];\n  diseaseSynonyms.forEach((s) => {\n    s.terms.forEach((syn) => {\n      const thisSyn = t.find((tItem) => tItem.label === syn);\n      if (!thisSyn) {\n        // if the synonyms is not already in the list, we add it\n        t.push({ label: syn, tooltip: [s.relation] });\n      } else {\n        // if it already exist, just add the relation to it\n        // (i.e. it will have multiple relations)\n        thisSyn.tooltip.push(s.relation);\n      }\n    });\n  });\n  // convert the tooltip array to a string for display in the Tooltip component\n  t.map((tItem) => {\n    const syn = tItem;\n    syn.tooltip = tItem.tooltip.join(\", \");\n    return syn;\n  });\n  return t;\n};\n\nfunction ProfileHeader() {\n  const classes = useStyles();\n  const { loading, error, data } = usePlatformApi();\n\n  // TODO: Errors!\n  if (error) return null;\n\n  const { id: efoId, name, description: diseaseDescription } = data?.disease || {};\n  const targetDescription = data?.target.functionDescriptions?.[0];\n\n  const diseaseSynonyms = parseSynonyms(data?.disease.synonyms || []);\n\n  const { id: ensgId, approvedSymbol } = data?.target || {};\n\n  const targetSynonyms = data?.target?.synonyms?.reduce((accumulator, synonymous) => {\n    if (accumulator.find((x) => x.label === synonymous.label)) {\n      return accumulator;\n    }\n    accumulator.push({\n      ...synonymous,\n      tooltip: synonymous.label,\n    });\n    return accumulator;\n  }, []);\n\n  return (\n    <BaseProfileHeader>\n      {loading ? (\n        <Skeleton variant=\"rect\" height=\"15rem\" />\n      ) : (\n        <Card className={classes.card} elevation={0}>\n          <CardHeader\n            title={\n              <Typography variant=\"h5\">\n                <Link to={`/target/${ensgId}`}>\n                  <FontAwesomeIcon icon={faDna} /> {approvedSymbol}\n                </Link>\n              </Typography>\n            }\n          />\n          <CardContent className={classes.cardContent}>\n            <ProfileDescription>{targetDescription}</ProfileDescription>\n            <ProfileChipList title=\"Synonyms\">{targetSynonyms}</ProfileChipList>\n          </CardContent>\n        </Card>\n      )}\n      {loading ? (\n        <Skeleton variant=\"rect\" height=\"15rem\" />\n      ) : (\n        <Card className={classes.card} elevation={0}>\n          <CardHeader\n            title={\n              <Typography variant=\"h5\">\n                <Link to={`/disease/${efoId}`}>\n                  <FontAwesomeIcon icon={faStethoscope} /> {name}\n                </Link>\n              </Typography>\n            }\n          />\n          <CardContent className={classes.cardContent}>\n            <ProfileDescription>{diseaseDescription}</ProfileDescription>\n            {diseaseSynonyms.length > 0 ? (\n              <ProfileChipList title=\"Synonyms\">{diseaseSynonyms}</ProfileChipList>\n            ) : null}\n          </CardContent>\n        </Card>\n      )}\n    </BaseProfileHeader>\n  );\n}\n\nexport default ProfileHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/EvidencePage/ProfileHeader.jsx" },
        "span": [791, 1203],
        "sourceCode": "import { faDna, faStethoscope } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Card, CardContent, CardHeader, Skeleton, Typography } from \"@mui/material\";\nimport {\n  ProfileHeader as BaseProfileHeader,\n  Link,\n  ProfileChipList,\n  ProfileDescription,\n  usePlatformApi,\n} from \"ui\";\n\nimport { makeStyles } from \"@mui/styles\";\n\nconst useStyles = makeStyles((theme) => ({\n  card: { height: \"100%\" },\n  cardContent: {\n    borderTop: `1px solid ${theme.palette.grey[300]}`,\n  },\n}));\n\n/**\n * Disease synonyms are organized by \"relation\", each with a list of \"terms\".\n * The same term can appear under different relations.\n */\nconst parseSynonyms = (diseaseSynonyms) => {\n  const t = [];\n  diseaseSynonyms.forEach((s) => {\n    s.terms.forEach((syn) => {\n      const thisSyn = t.find((tItem) => tItem.label === syn);\n      if (!thisSyn) {\n        // if the synonyms is not already in the list, we add it\n        t.push({ label: syn, tooltip: [s.relation] });\n      } else {\n        // if it already exist, just add the relation to it\n        // (i.e. it will have multiple relations)\n        thisSyn.tooltip.push(s.relation);\n      }\n    });\n  });\n  // convert the tooltip array to a string for display in the Tooltip component\n  t.map((tItem) => {\n    const syn = tItem;\n    syn.tooltip = tItem.tooltip.join(\", \");\n    return syn;\n  });\n  return t;\n};\n\nfunction ProfileHeader() {\n  const classes = useStyles();\n  const { loading, error, data } = usePlatformApi();\n\n  // TODO: Errors!\n  if (error) return null;\n\n  const { id: efoId, name, description: diseaseDescription } = data?.disease || {};\n  const targetDescription = data?.target.functionDescriptions?.[0];\n\n  const diseaseSynonyms = parseSynonyms(data?.disease.synonyms || []);\n\n  const { id: ensgId, approvedSymbol } = data?.target || {};\n\n  const targetSynonyms = data?.target?.synonyms?.reduce((accumulator, synonymous) => {\n    if (accumulator.find((x) => x.label === synonymous.label)) {\n      return accumulator;\n    }\n    accumulator.push({\n      ...synonymous,\n      tooltip: synonymous.label,\n    });\n    return accumulator;\n  }, []);\n\n  return (\n    <BaseProfileHeader>\n      {loading ? (\n        <Skeleton variant=\"rect\" height=\"15rem\" />\n      ) : (\n        <Card className={classes.card} elevation={0}>\n          <CardHeader\n            title={\n              <Typography variant=\"h5\">\n                <Link to={`/target/${ensgId}`}>\n                  <FontAwesomeIcon icon={faDna} /> {approvedSymbol}\n                </Link>\n              </Typography>\n            }\n          />\n          <CardContent className={classes.cardContent}>\n            <ProfileDescription>{targetDescription}</ProfileDescription>\n            <ProfileChipList title=\"Synonyms\">{targetSynonyms}</ProfileChipList>\n          </CardContent>\n        </Card>\n      )}\n      {loading ? (\n        <Skeleton variant=\"rect\" height=\"15rem\" />\n      ) : (\n        <Card className={classes.card} elevation={0}>\n          <CardHeader\n            title={\n              <Typography variant=\"h5\">\n                <Link to={`/disease/${efoId}`}>\n                  <FontAwesomeIcon icon={faStethoscope} /> {name}\n                </Link>\n              </Typography>\n            }\n          />\n          <CardContent className={classes.cardContent}>\n            <ProfileDescription>{diseaseDescription}</ProfileDescription>\n            {diseaseSynonyms.length > 0 ? (\n              <ProfileChipList title=\"Synonyms\">{diseaseSynonyms}</ProfileChipList>\n            ) : null}\n          </CardContent>\n        </Card>\n      )}\n    </BaseProfileHeader>\n  );\n}\n\nexport default ProfileHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/hooks/useBatchDownloader.js" },
        "span": [1906, 2001],
        "sourceCode": "import _ from \"lodash\";\n\nimport { downloaderChunkSize } from \"@ot/constants\";\nimport { useApolloClient } from \"../providers/OTApolloProvider/OTApolloProvider\";\n\nconst getRows = (data, dataPath) => _.get(data, dataPath, []);\n\n/**\n * Provides a function to asynchronously batch-download a whole dataset from\n * the backend.\n *\n * The function uses the parameter downloaderChunkSize from the configuration.js\n * file to determine the size of the chunks to fetch.\n *\n * @param {import('graphql').DocumentNode} query Query to run to fetch the data.\n * @param {import('apollo-client').QueryOptions} variables Variables object for the query.\n * @param {string} dataPath Path where the data array, row count and cursor are inside the query's result.\n * @param {string} [rowField=rows] field in dataPath containing the rows. Default: 'rows'.\n * @param {string} [countField=count] field in dataPath containing the row count. Default: 'count'.\n *\n * @returns {Function} Function that will fetch the whole dataset.\n */\nfunction useBatchDownloader(\n  query,\n  variables,\n  dataPath,\n  rowField = \"rows\",\n  countField = \"count\",\n  chunkSize = downloaderChunkSize\n) {\n  const client = useApolloClient();\n  const rowPath = `${dataPath}.${rowField}`;\n  const countPath = `${dataPath}.${countField}`;\n\n  const getDataChunk = async (index, size) =>\n    client.query({\n      query,\n      variables: { index, size, ...variables },\n    });\n\n  return async function getWholeDataset() {\n    const chunkPromises = [];\n    let data = [];\n    let index = 0;\n\n    const firstChunk = await getDataChunk(index, chunkSize);\n    data = [...getRows(firstChunk, rowPath)];\n    index += 1;\n\n    const count = Math.ceil(_.get(firstChunk, countPath) / chunkSize);\n\n    while (index < count) {\n      chunkPromises.push(getDataChunk(index, chunkSize));\n      index += 1;\n    }\n\n    const remainingChunks = await Promise.all(chunkPromises);\n\n    remainingChunks.forEach((chunk) => {\n      data = [...data, ...getRows(chunk, rowPath)];\n    });\n\n    return data;\n  };\n}\n\nexport default useBatchDownloader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/ProjectsPage/ProjectsPage.jsx" },
        "span": [1757, 2246],
        "sourceCode": "import { faCircleCheck, faCircleNotch } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Chip, Paper, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { Link, OtTable } from \"ui\";\nimport projectsData from \"./projects-data.json\";\n\nconst useStyles = makeStyles((theme) => ({\n  icon: {\n    color: theme.palette.primary.main,\n  },\n  diseaseContainer: {\n    display: \"flex\",\n  },\n  disease: {\n    marginRight: \"0.2rem\",\n  },\n}));\n\nconst CURRENTLY_INTEGRATES_IN_PPP = {\n  Y: faCircleCheck,\n  N: faCircleNotch,\n};\n\nfunction ProjectPage() {\n  const classes = useStyles();\n  const columns = [\n    {\n      id: \"otar_code\",\n      label: \"Project Code\",\n      renderCell: ({ otar_code: otarCode }) =>\n        otarCode ? (\n          <Link to={`http://home.opentargets.org/${otarCode}`} external newTab>\n            {otarCode}\n          </Link>\n        ) : null,\n    },\n    { id: \"project_name\", label: \"Project Name\" },\n    { id: \"project_lead\", label: \"Project Lead\" },\n    { id: \"generates_data\", label: \"Generates Data\" },\n    {\n      id: \"currently_integrates_in_PPP\",\n      label: \"Currently integrates into PPP\",\n      renderCell: ({ currently_integrates_in_PPP }) => (\n        <FontAwesomeIcon\n          size=\"lg\"\n          icon={CURRENTLY_INTEGRATES_IN_PPP[currently_integrates_in_PPP]}\n          className={classes.icon}\n        />\n      ),\n    },\n    { id: \"project_status\", label: \"Project Status\" },\n    { id: \"open_targets_therapeutic_area\", label: \"Therapeutic Area\" },\n    {\n      id: \"disease_mapping\",\n      label: \"Disease Mapped in the PPP\",\n      renderCell: ({ disease_mapping: diseaseMapping }) => {\n        const ALL_AVATARS = [];\n        diseaseMapping.forEach((disease) => {\n          if (disease?.disease_id) {\n            ALL_AVATARS.push(\n              <Link to={`disease/${disease.disease_id}`} key={disease.disease_id}>\n                <Chip\n                  size=\"small\"\n                  label={disease.label || disease.disease_id}\n                  clickable\n                  color=\"primary\"\n                  className={classes.disease}\n                />\n              </Link>\n            );\n          }\n        });\n        return <div className={classes.diseaseContainer}>{ALL_AVATARS}</div>;\n      },\n    },\n  ];\n  return (\n    <>\n      <Typography variant=\"h4\" component=\"h1\" paragraph>\n        Open Targets Projects Table\n      </Typography>\n      <Typography paragraph>\n        The table below contains key information on the OTAR projects, their status and data\n        availability into the PPP.\n      </Typography>\n      <Typography paragraph>\n        For further information, please see{\" \"}\n        <Link to=\"http://home.opentargets.org/data-available\" external newTab>\n          here\n        </Link>{\" \"}\n        or contact us at{\" \"}\n        <Link to=\"mailto: datarequests@opentargets.org\" external>\n          datarequests@opentargets.org\n        </Link>\n        .\n      </Typography>\n      <Typography paragraph>\n        PPP specific documentation can be found{\" \"}\n        <Link to=\"http://home.opentargets.org/ppp-documentation\" external newTab>\n          here\n        </Link>\n      </Typography>\n\n      <Paper variant=\"outlined\" elevation={0}>\n        <Box m={2}>\n          <OtTable\n            showGlobalFilter\n            columns={columns}\n            rows={projectsData}\n            rowsPerPageOptions={[30]}\n          />\n        </Box>\n      </Paper>\n    </>\n  );\n}\n\nexport default ProjectPage;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/icons/BrokenSearchIcon.tsx" },
        "span": [441, 576],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport type { ReactNode } from \"react\";\n\nconst useStyles = makeStyles((_theme) => ({\n  mainIcon: {\n    width: \"1em\",\n    display: \"flex\",\n  },\n}));\n\nfunction BrokenSearchIcon({ color = \"#3489ca\" }): ReactNode {\n  const classes = useStyles();\n\n  const styles = {\n    fill: \"none\",\n    stroke: color,\n    strokeLinecap: \"round\",\n    strokeMiterlimit: 10,\n    strokeWidth: \"23px\",\n  };\n\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      id=\"Layer_2\"\n      viewBox=\"0 0 423.4 832\"\n      className={classes.mainIcon}\n    >\n      <defs>\n        <style>\n          {\n            \".cls-1{fill:none;stroke:#3489ca;stroke-linecap:round;stroke-miterlimit:10;stroke-width:23px}\"\n          }\n        </style>\n      </defs>\n      <g id=\"Layer_4\">\n        <path\n          d=\"M220.5 14.5c0 36-15 72-68 108-51.45 34.95-69 68-68 107 .59 23.01 3 62 68 110 55.18 40.75 69.22 80.01 70 109 1 37-16.35 67.58-70.5 112.5-64.5 53.5-69.5 82.5-67.5 118.5 2.54 45.65 28.75 74.39 69.5 103.5 17.5 12.5 25.5 17.5 43.5 35.5\"\n          style={styles}\n        />\n        <path\n          d=\"M109.5 820.5c16-15 12.08-11.88 44-37 25.21-19.84 39.05-33.24 51-54 9.03-15.69 23.08-40.1 15-63-8.45-23.93-36.7-33.83-60-42-53.1-18.62-88.77-14.69-101-35-8.2-13.62-4.97-33.16 3-44 18.37-24.97 66.03-13.49 81-9 30 9 38.87 18.02 81 27 20.57 4.39 47.21 10.06 75 1 43.54-14.2 64.5-56.29 71-71M82.5 11.5c1 43 18.99 68.32 24 76 15 23 32 31 46 35 10.96 3.13 18 5 36 5 11.05 0 30-4 30-4 18-3 30 6 30 20 0 18-9 29-24 36-24.04 11.22-37 9-57 8-44.89-2.24-71.32-18.78-99-34-20-11-37 0-45 12-6.78 10.17-7.83 17.99 7 56 16 41 14.2 35.51 22 55 8 20 13 47 1 57-5.7 4.75-26 13-42-20M34.35 165.21l47.07 42.17M184.85 191.11l18.02 87.77M36.77 224.64l43.58 22.79M67.99 302.74l31.76-6.82M72.55 559.46l36.05 24M113.04 539.09l19.12 30.36M221.3 573.33l-9.46 42.26M275.51 579.96l12.35 63.71M339.76 436.41l-58.15 28.81M323.25 565.44l42.97 45.62M52.92 417.82l55.63 28.86M357.57 383.62l54.33 31.25M358.89 524.86l26.19 4.69M288.81 329.57l24.35-10.74M242.66 170.5l70.51 66.68M247.09 127.94l81.93-19.43M90.53 32.02h123.14M106.9 72.02h87.3M85.23 658.3h120.54M93.53 695.02h123.14M109.9 735.02h87.3\"\n          style={styles}\n        />\n      </g>\n    </svg>\n  );\n}\n\nexport default BrokenSearchIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/useKeyWithClickEvents",
      "severity": "error",
      "description": "Enforce to have the onClick mouse event with the onKeyUp, the onKeyDown, or the onKeyPress keyboard event.",
      "message": [
        { "elements": [], "content": "Enforce to have the " },
        { "elements": ["Emphasis"], "content": "onClick" },
        { "elements": [], "content": " mouse event with the " },
        { "elements": ["Emphasis"], "content": "onKeyUp" },
        { "elements": [], "content": ", the " },
        { "elements": ["Emphasis"], "content": "onKeyDown" },
        { "elements": [], "content": ", or the " },
        { "elements": ["Emphasis"], "content": "onKeyPress" },
        { "elements": [], "content": " keyboard event." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/HomePage/HomePage.tsx" },
        "span": [9577, 9878],
        "sourceCode": "import { Box, Chip, Grid, type Theme, Typography } from \"@mui/material\";\nimport { makeStyles, styled, useTheme } from \"@mui/styles\";\nimport { Helmet } from \"react-helmet\";\nimport { Footer, GlobalSearch, Link, NavBar, usePermissions, useSearchState } from \"ui\";\n\nimport type { IconDefinition } from \"@fortawesome/fontawesome-svg-core\";\nimport {\n  faChartBar,\n  faChevronDown,\n  faCircle,\n  faCommentDots,\n  faDna,\n  faDownload,\n  faFileAlt,\n  faLaptopCode,\n  faMapPin,\n  faPrescriptionBottleMedical,\n  faQuestionCircle,\n  faSquare,\n  faStethoscope,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { grey } from \"@mui/material/colors\";\nimport { getConfig } from \"@ot/config\";\nimport {\n  appCanonicalUrl,\n  appDescription,\n  appTitle,\n  externalLinks,\n  mainMenuItems,\n} from \"@ot/constants\";\nimport HomeBox from \"./HomeBox\";\nimport Splash from \"./Splash\";\nimport Version from \"./Version\";\n\nconst config = getConfig();\n\nconst useStyles = makeStyles<Theme>(() => ({\n  links: {\n    marginTop: \"12px\",\n  },\n  api: {\n    marginTop: \"38px\",\n  },\n  dataPolicy: {\n    padding: \"10px\",\n    marginTop: \"30px\",\n    border: \"2px solid\",\n    borderColor: config.profile.primaryColor as string,\n  },\n}));\n\nconst StyledChip = styled(Chip)(({ theme }) => ({\n  border: 1,\n  fontSize: \"12px\",\n  fontWeight: \"bold\",\n  boxShadow: 0,\n  \"&:hover\": {\n    color: theme.palette.primary.dark,\n    background: grey[100],\n  },\n  \"&:hover .MuiChip-icon\": {\n    color: theme.palette.primary.dark,\n  },\n}));\n\nfunction AboutPPP(): JSX.Element {\n  return (\n    <>\n      <Typography paragraph>\n        The Open Targets Partner Preview Platform is an extension of the Open Targets Platform, a\n        comprehensive tool that supports systematic identification and prioritisation of potential\n        therapeutic drug targets.\n      </Typography>\n\n      <Typography paragraph>\n        Combining publicly available datasets with pre-publication data generated by the consortium,\n        the Partner Preview Platform builds and scores target-disease associations to assist in drug\n        target identification and prioritisation. It also integrates relevant annotation information\n        about targets, diseases, phenotypes, and drugs, as well as their most relevant\n        relationships.\n      </Typography>\n\n      <Typography paragraph>\n        The Partner Preview version of the Open Targets Platform is only available to members of the\n        Open Targets consortium. It is actively maintained with regular data updates. Data is\n        available through an intuitive user interface, and a partner-specific API which includes the\n        pre-publication data. The public data is available through data downloads, while\n        pre-publication data can be requested through the intranet (home.opentargets.org). The\n        pipeline and infrastructure codebases are open-source and the licence allows the creation of\n        self-hosted private instances of the Platform with custom data.\n      </Typography>\n    </>\n  );\n}\n\nfunction AboutPublic(): JSX.Element {\n  return (\n    <>\n      <Typography paragraph>\n        The Open Targets Platform is a comprehensive tool that supports systematic identification\n        and prioritisation of potential therapeutic drug targets.\n      </Typography>\n\n      <Typography paragraph>\n        By integrating publicly available datasets including data generated by the Open Targets\n        consortium, the Platform builds and scores target-disease associations to assist in drug\n        target identification and prioritisation. It also integrates relevant annotation information\n        about targets, diseases or phenotypes, variants, GWAS studies and drugs, as well as their\n        most relevant relationships.\n      </Typography>\n\n      <Typography paragraph>\n        The Platform is a freely available resource that is actively maintained with quarterly data\n        updates. Data is available through an intuitive user interface, an API, and data downloads.\n        The pipeline and infrastructure codebases are open-source and the licence allows the\n        creation of self-hosted private instances of the Platform with custom data.\n      </Typography>\n    </>\n  );\n}\n\ninterface HelpBoxPanelProps {\n  fai: IconDefinition;\n  url: string;\n  label: string;\n  external?: boolean;\n}\n\nfunction HelpBoxPanel({ fai, url, label, external = false }: HelpBoxPanelProps): JSX.Element {\n  const theme: Theme = useTheme();\n  return (\n    <Box\n      sx={{\n        maxWidth: { md: \"150px\", xs: \"200px\" },\n      }}\n    >\n      <Link to={url} external={external}>\n        <Box sx={{ gap: 1, display: \"flex\", flexDirection: \"column\", alignItems: \"center\" }}>\n          <div className=\"fa-layers fa-fw fa-6x\">\n            <FontAwesomeIcon icon={faSquare} color={theme.palette.primary.dark} />\n            <FontAwesomeIcon icon={fai} transform=\"shrink-8\" inverse />\n          </div>\n          <Typography align=\"center\" variant=\"subtitle1\" component=\"div\">\n            {label}\n          </Typography>\n        </Box>\n      </Link>\n    </Box>\n  );\n}\n\ninterface SearchSuggestion {\n  id: string;\n  name: string;\n}\n\nfunction HomePage(): JSX.Element {\n  const { searchSuggestions } = useSearchState() as { searchSuggestions: SearchSuggestion[] };\n  const { isPartnerPreview } = usePermissions();\n  const releaseNotesURL = isPartnerPreview\n    ? \"http://home.opentargets.org/ppp-release-notes\"\n    : \"https://platform-docs.opentargets.org/release-notes\";\n  const classes = useStyles();\n\n  const handleScrollDown = (): void => {\n    window.scrollTo({ top: window.innerHeight, left: 0, behavior: \"smooth\" });\n  };\n\n  return (\n    <>\n      <Helmet title={appTitle}>\n        <meta name=\"description\" content={appDescription} />\n        <link rel=\"canonical\" href={appCanonicalUrl} />\n      </Helmet>\n      <Grid container justifyContent=\"center\" alignItems=\"center\" className={classes.hpSection}>\n        <Splash />\n        <NavBar name=\"platform\" homepage items={mainMenuItems} placement=\"bottom-end\" />\n        <HomeBox>\n          <GlobalSearch isHomePage />\n          {/* Search examples */}\n          <Grid\n            className={classes.links}\n            container\n            justifyContent=\"center\"\n            gap={1.5}\n            sx={{ mt: 4 }}\n          >\n            <Link asyncTooltip to={`/target/${searchSuggestions[0].id}/associations`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faDna} />}\n                label={searchSuggestions[0].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/target/${searchSuggestions[1].id}/associations`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faDna} />}\n                label={searchSuggestions[1].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/disease/${searchSuggestions[2].id}/associations`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faStethoscope} />}\n                label={searchSuggestions[2].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/disease/${searchSuggestions[3].id}/associations`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faStethoscope} />}\n                label={searchSuggestions[3].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/drug/${searchSuggestions[4].id}`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faPrescriptionBottleMedical} />}\n                label={searchSuggestions[4].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/drug/${searchSuggestions[5].id}`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faPrescriptionBottleMedical} />}\n                label={searchSuggestions[5].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/variant/${searchSuggestions[6].id}`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faMapPin} />}\n                label={searchSuggestions[6].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/variant/${searchSuggestions[7].id}`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faMapPin} />}\n                label={searchSuggestions[7].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/study/${searchSuggestions[8].id}`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faChartBar} />}\n                label={searchSuggestions[8].name}\n              />\n            </Link>\n            <Link asyncTooltip to={`/study/${searchSuggestions[9].id}`}>\n              <StyledChip\n                sx={{ pl: 1, borderRadius: 2 }}\n                icon={<FontAwesomeIcon icon={faChartBar} />}\n                label={searchSuggestions[9].name}\n              />\n            </Link>\n          </Grid>\n          <div>\n            <Version releaseNotesURL={releaseNotesURL} />\n          </div>\n        </HomeBox>\n\n        {/* scroll down button */}\n        <Grid container justifyContent=\"center\">\n          <div\n            className=\"fa-layers fa-fw fa-3x\"\n            style={{\n              height: \"0px\",\n              marginTop: \"-1em\",\n              filter: \"drop-shadow( 1px 1px 2px rgba(0, 0, 0, .5))\",\n              cursor: \"pointer\",\n            }}\n            onClick={handleScrollDown}\n          >\n            <FontAwesomeIcon icon={faCircle} inverse />\n            <FontAwesomeIcon icon={faChevronDown} transform=\"shrink-4\" />\n          </div>\n        </Grid>\n      </Grid>\n\n      {/* About */}\n\n      <Grid container justifyContent=\"center\" sx={{ my: 10 }}>\n        <Grid item xs={10} md={8} sx={{ my: 2 }}>\n          <Typography variant=\"h4\" component=\"h1\" align=\"center\" paragraph mb={5}>\n            About the Open Targets Platform\n          </Typography>\n          {isPartnerPreview ? <AboutPPP /> : <AboutPublic />}\n        </Grid>\n      </Grid>\n\n      {/* Get started */}\n      <Grid container justifyContent=\"center\" sx={{ mb: 18 }}>\n        <Grid item xs={10} md={8}>\n          <Typography variant=\"h4\" component=\"h1\" align=\"center\" paragraph mb={5}>\n            Get started with the Platform\n          </Typography>\n\n          <Box\n            sx={{\n              display: \"flex\",\n              justifyContent: \"space-between\",\n              gap: { xs: 5, md: 1 },\n              alignItems: { xs: \"center\", md: \"flex-start\" },\n              flexDirection: {\n                xs: \"column\",\n                md: \"row\",\n              },\n            }}\n          >\n            <HelpBoxPanel\n              fai={faDownload}\n              url=\"/downloads\"\n              label=\"Download all of our open datasets\"\n            />\n\n            <HelpBoxPanel\n              fai={faLaptopCode}\n              url=\"/api\"\n              label=\"Access data with our GraphQL API\"\n              external\n            />\n\n            <HelpBoxPanel\n              fai={faQuestionCircle}\n              url=\"https://platform-docs.opentargets.org/\"\n              label=\"Check out our Platform documentation\"\n              external\n            />\n\n            <HelpBoxPanel\n              fai={faFileAlt}\n              url=\"https://platform-docs.opentargets.org/citation\"\n              label=\"Read our latest Platform publications\"\n              external\n            />\n\n            <HelpBoxPanel\n              fai={faCommentDots}\n              url=\"https://community.opentargets.org/\"\n              label=\"Join the Open Targets Community\"\n              external\n            />\n          </Box>\n        </Grid>\n      </Grid>\n\n      <Footer externalLinks={externalLinks} />\n    </>\n  );\n}\n\nexport default HomePage;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/icons/ArrowTurnDownLeft.tsx" },
        "span": [280, 419],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport type { ReactNode } from \"react\";\n\nconst useStyles = makeStyles((_theme) => ({\n  mainIcon: {\n    width: \"1em\",\n    display: \"flex\",\n  },\n}));\n\nfunction ArrowTurnDownLeft(): ReactNode {\n  const classes = useStyles();\n\n  return (\n    <svg\n      id=\"Layer_2\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 443.18 334.88\"\n      className={classes.mainIcon}\n    >\n      <defs>\n        <style>\n          {\n            \".cls-1{fill:none;stroke:#1f5279;stroke-linecap:round;stroke-miterlimit:10;stroke-width:43px;}\"\n          }\n        </style>\n      </defs>\n      <g id=\"Layer_2-2\">\n        <path className=\"cls-1\" d=\"m421.68,21.5v140.71c0,25.74-20.87,46.61-44.61,46.61H34.36\" />\n        <polyline className=\"cls-1\" points=\"135.85 101.72 30.41 207.67 136.62 313.38\" />\n      </g>\n    </svg>\n  );\n}\n\nexport default ArrowTurnDownLeft;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/SearchPage/SearchContainer.jsx" },
        "span": [981, 1056],
        "sourceCode": "import {\n  faChartBar,\n  faDna,\n  faMapPin,\n  faPrescriptionBottleAlt,\n  faStethoscope,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Card,\n  Checkbox,\n  FormControlLabel,\n  FormGroup,\n  Grid,\n  TablePagination,\n  Typography,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { BrokenSearchIcon, ErrorBoundary } from \"ui\";\n\nimport { grey } from \"@mui/material/colors\";\nimport DiseaseDetail from \"./DiseaseDetail\";\nimport DiseaseResult from \"./DiseaseResult\";\nimport DrugDetail from \"./DrugDetail\";\nimport DrugResult from \"./DrugResult\";\nimport StudyResult from \"./StudyResult\";\nimport TargetDetail from \"./TargetDetail\";\nimport TargetResult from \"./TargetResult\";\nimport VariantDetail from \"./VariantDetail\";\nimport VariantResult from \"./VariantResult\";\n\nconst getCounts = (entities) => {\n  const counts = {\n    target: 0,\n    disease: 0,\n    variant: 0,\n    drug: 0,\n  };\n\n  entities.forEach((entity) => {\n    counts[entity.name] = entity.total;\n  });\n\n  return counts;\n};\n\nconst useStyles = makeStyles((theme) => ({\n  label: {\n    marginLeft: \"-6px\",\n  },\n  labelIcon: {\n    color: theme.palette.primary.main,\n    marginRight: \"2px\",\n  },\n}));\n\nconst SearchFilters = ({ entities, entitiesCount, setEntity }) => {\n  const counts = getCounts(entitiesCount);\n  const classes = useStyles();\n\n  return (\n    <>\n      <FormControlLabel\n        className={classes.label}\n        control={<Checkbox checked={entities.includes(\"target\")} onChange={setEntity(\"target\")} />}\n        label={\n          <>\n            <FontAwesomeIcon icon={faDna} fixedWidth className={classes.labelIcon} />\n            <Typography variant=\"body2\" display=\"inline\">\n              Target ({counts.target})\n            </Typography>\n          </>\n        }\n      />\n      <FormControlLabel\n        className={classes.label}\n        control={\n          <Checkbox checked={entities.includes(\"variant\")} onChange={setEntity(\"variant\")} />\n        }\n        label={\n          <>\n            <FontAwesomeIcon icon={faMapPin} fixedWidth className={classes.labelIcon} />\n            <Typography variant=\"body2\" display=\"inline\">\n              Variant ({counts.variant})\n            </Typography>\n          </>\n        }\n      />\n      <FormControlLabel\n        className={classes.label}\n        control={<Checkbox checked={entities.includes(\"study\")} onChange={setEntity(\"study\")} />}\n        label={\n          <>\n            <FontAwesomeIcon icon={faChartBar} fixedWidth className={classes.labelIcon} />\n            <Typography variant=\"body2\" display=\"inline\">\n              Study ({counts.study})\n            </Typography>\n          </>\n        }\n      />\n      <FormControlLabel\n        className={classes.label}\n        control={\n          <Checkbox checked={entities.includes(\"disease\")} onChange={setEntity(\"disease\")} />\n        }\n        label={\n          <>\n            <FontAwesomeIcon icon={faStethoscope} fixedWidth className={classes.labelIcon} />\n            <Typography variant=\"body2\" display=\"inline\">\n              Disease or phenotype ({counts.disease})\n            </Typography>\n          </>\n        }\n      />\n      <FormControlLabel\n        className={classes.label}\n        control={<Checkbox checked={entities.includes(\"drug\")} onChange={setEntity(\"drug\")} />}\n        label={\n          <>\n            <FontAwesomeIcon\n              icon={faPrescriptionBottleAlt}\n              fixedWidth\n              className={classes.labelIcon}\n            />\n            <Typography variant=\"body2\" display=\"inline\">\n              Drug ({counts.drug})\n            </Typography>\n          </>\n        }\n      />\n    </>\n  );\n};\n\nfunction SearchResults({ results, page, onPageChange }) {\n  const TYPE_NAME = \"__typename\";\n  return (\n    <Box>\n      <TablePagination\n        component=\"div\"\n        rowsPerPageOptions={[]}\n        rowsPerPage={10}\n        count={results.total}\n        page={page - 1}\n        onPageChange={onPageChange}\n      />\n      {results.hits.map(({ highlights, object }) => {\n        if (object[TYPE_NAME] === \"Target\")\n          return <TargetResult key={object.id} data={object} highlights={highlights} />;\n        if (object[TYPE_NAME] === \"Disease\")\n          return <DiseaseResult key={object.id} data={object} highlights={highlights} />;\n        if (object[TYPE_NAME] === \"Variant\")\n          return <VariantResult key={object.id} data={object} highlights={highlights} />;\n        if (object[TYPE_NAME] === \"Study\")\n          return <StudyResult key={object.id} data={object} highlights={highlights} />;\n        return <DrugResult key={object.id} data={object} highlights={highlights} />;\n      })}\n\n      <TablePagination\n        component=\"div\"\n        rowsPerPageOptions={[]}\n        rowsPerPage={10}\n        count={results.total}\n        page={page - 1}\n        onPageChange={onPageChange}\n      />\n    </Box>\n  );\n}\n\nfunction TopHitDetail({ topHit }) {\n  let COMPONENT = null;\n  const TYPE_NAME = \"__typename\";\n  if (topHit[TYPE_NAME] === \"Target\") COMPONENT = <TargetDetail data={topHit} />;\n  else if (topHit[TYPE_NAME] === \"Disease\") COMPONENT = <DiseaseDetail data={topHit} />;\n  else if (topHit[TYPE_NAME] === \"Variant\") COMPONENT = <VariantDetail data={topHit} />;\n  else if (topHit[TYPE_NAME] === \"Drug\") COMPONENT = <DrugDetail data={topHit} />;\n  return (\n    <Card elevation={0}>\n      <ErrorBoundary>{COMPONENT}</ErrorBoundary>\n    </Card>\n  );\n}\nfunction NoResultsContainer({ q }) {\n  return (\n    <Box\n      sx={{\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        mb: 10,\n      }}\n    >\n      <Box sx={{ fontSize: \"10em\", mb: 5 }}>\n        <BrokenSearchIcon color={grey[400]} />\n      </Box>\n      <Box sx={{ typography: \"h6\", textAlign: \"center\" }}>\n        We could not find anything in the Platform database that matches{\" \"}\n        <strong> &quot;{q}&quot;</strong>.\n      </Box>\n    </Box>\n  );\n}\n\nfunction SearchContainer({ q, page, entities, data, onPageChange, onSetEntity }) {\n  const { entities: entitiesCount } = data.search.aggregations;\n  const topHit = data.topHit.hits[0]?.object;\n\n  return (\n    <>\n      <Typography variant=\"h5\" gutterBottom>\n        {data.search.total} results for &quot;<strong>{q}</strong>&quot;\n      </Typography>\n      <Grid container spacing={2} sx={{ display: \"flex\", height: \"100%\" }}>\n        <Grid item md={3}>\n          <Typography variant=\"body2\">Refine by:</Typography>\n          <FormGroup>\n            <SearchFilters\n              entities={entities}\n              entitiesCount={entitiesCount}\n              setEntity={onSetEntity}\n            />\n          </FormGroup>\n        </Grid>\n        <Grid\n          item\n          md={6}\n          sx={{\n            display: \"flex\",\n            justifyContent: \"center\",\n          }}\n        >\n          {data.search.hits.length > 0 ? (\n            <SearchResults page={page} results={data.search} onPageChange={onPageChange} />\n          ) : (\n            <NoResultsContainer q={q} />\n          )}\n        </Grid>\n\n        {topHit ? (\n          <Grid item md={3}>\n            {\" \"}\n            <TopHitDetail topHit={topHit} />{\" \"}\n          </Grid>\n        ) : null}\n      </Grid>\n    </>\n  );\n}\n\nexport default SearchContainer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client\n      .query",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: client\n      .query"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [977, 996],
              "sourceCode": "import queryString from \"query-string\";\nimport { Suspense, lazy, useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\nimport { BasePage, LoadingBackdrop, useApolloClient } from \"ui\";\n\nimport SEARCH_PAGE_QUERY from \"./SearchPageQuery.gql\";\n\nconst SearchContainer = lazy(() => import(\"./SearchContainer\"));\n\nconst QS_OPTIONS = {\n  sort: false,\n  arrayFormat: \"comma\",\n  skipNull: true,\n};\n\nconst parseQueryString = (qs) => {\n  const params = queryString.parse(qs, QS_OPTIONS);\n  if (!params.entities) {\n    params.entities = [];\n  } else if (typeof params.entities === \"string\") {\n    params.entities = [params.entities];\n  }\n  return params;\n};\n\nfunction SearchPage() {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const { q, page, entities } = parseQueryString(location.search);\n  const [data, setData] = useState(null);\n  const client = useApolloClient();\n\n  useEffect(() => {\n    let isCurrent = true;\n    client\n      .query({\n        query: SEARCH_PAGE_QUERY,\n        variables: {\n          queryString: q,\n          index: page - 1,\n          entityNames: entities,\n        },\n      })\n      .then((res) => {\n        if (isCurrent) {\n          setData(res.data);\n        }\n      });\n\n    return () => {\n      isCurrent = false;\n    };\n  }, [q, page, entities]);\n\n  const handleChangePage = (_event, pageChanged) => {\n    const params = { q, page: pageChanged + 1, entities };\n    const qs = queryString.stringify(params, QS_OPTIONS);\n    navigate(`/search?${qs}`);\n  };\n\n  const handleSetEntity = (entity) => (_event, checked) => {\n    const params = {\n      q,\n      page: 1, // reset to page 1\n      entities: checked ? [...entities, entity] : entities.filter((e) => e !== entity),\n    };\n    const qs = queryString.stringify(params, QS_OPTIONS);\n    navigate(`/search?${qs}`);\n  };\n\n  let SEARCH_CONTAINER = null;\n\n  if (data) {\n    SEARCH_CONTAINER = (\n      <SearchContainer\n        q={q}\n        page={page}\n        entities={entities}\n        onSetEntity={handleSetEntity}\n        onPageChange={handleChangePage}\n        data={data}\n      />\n    );\n  } else {\n    SEARCH_CONTAINER = null;\n  }\n\n  return (\n    <BasePage>\n      <Suspense fallback={<LoadingBackdrop />}>{SEARCH_CONTAINER}</Suspense>\n    </BasePage>\n  );\n}\n\nexport default SearchPage;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/SearchPage/SearchPage.jsx" },
        "span": [929, 938],
        "sourceCode": "import queryString from \"query-string\";\nimport { Suspense, lazy, useEffect, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\nimport { BasePage, LoadingBackdrop, useApolloClient } from \"ui\";\n\nimport SEARCH_PAGE_QUERY from \"./SearchPageQuery.gql\";\n\nconst SearchContainer = lazy(() => import(\"./SearchContainer\"));\n\nconst QS_OPTIONS = {\n  sort: false,\n  arrayFormat: \"comma\",\n  skipNull: true,\n};\n\nconst parseQueryString = (qs) => {\n  const params = queryString.parse(qs, QS_OPTIONS);\n  if (!params.entities) {\n    params.entities = [];\n  } else if (typeof params.entities === \"string\") {\n    params.entities = [params.entities];\n  }\n  return params;\n};\n\nfunction SearchPage() {\n  const location = useLocation();\n  const navigate = useNavigate();\n  const { q, page, entities } = parseQueryString(location.search);\n  const [data, setData] = useState(null);\n  const client = useApolloClient();\n\n  useEffect(() => {\n    let isCurrent = true;\n    client\n      .query({\n        query: SEARCH_PAGE_QUERY,\n        variables: {\n          queryString: q,\n          index: page - 1,\n          entityNames: entities,\n        },\n      })\n      .then((res) => {\n        if (isCurrent) {\n          setData(res.data);\n        }\n      });\n\n    return () => {\n      isCurrent = false;\n    };\n  }, [q, page, entities]);\n\n  const handleChangePage = (_event, pageChanged) => {\n    const params = { q, page: pageChanged + 1, entities };\n    const qs = queryString.stringify(params, QS_OPTIONS);\n    navigate(`/search?${qs}`);\n  };\n\n  const handleSetEntity = (entity) => (_event, checked) => {\n    const params = {\n      q,\n      page: 1, // reset to page 1\n      entities: checked ? [...entities, entity] : entities.filter((e) => e !== entity),\n    };\n    const qs = queryString.stringify(params, QS_OPTIONS);\n    navigate(`/search?${qs}`);\n  };\n\n  let SEARCH_CONTAINER = null;\n\n  if (data) {\n    SEARCH_CONTAINER = (\n      <SearchContainer\n        q={q}\n        page={page}\n        entities={entities}\n        onSetEntity={handleSetEntity}\n        onPageChange={handleChangePage}\n        data={data}\n      />\n    );\n  } else {\n    SEARCH_CONTAINER = null;\n  }\n\n  return (\n    <BasePage>\n      <Suspense fallback={<LoadingBackdrop />}>{SEARCH_CONTAINER}</Suspense>\n    </BasePage>\n  );\n}\n\nexport default SearchPage;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/StudyPage/Header.tsx" },
        "span": [481, 491],
        "sourceCode": "import { faChartBar } from \"@fortawesome/free-solid-svg-icons\";\nimport { ExternalLink, Header as HeaderBase, XRefLinks } from \"ui\";\n\ntype HeaderProps = {\n  loading: boolean;\n  studyId: string;\n  backgroundTraits: {\n    id: string;\n    name: string;\n  }[];\n  targetId: string;\n  diseases: {\n    id: string;\n    name: string;\n  }[];\n  studyCategory: string;\n};\n\nfunction Header({\n  loading,\n  studyId,\n  backgroundTraits,\n  targetId,\n  diseases,\n  projectId,\n}: HeaderProps) {\n  let traitLinks;\n  let sourceLink;\n  if (projectId === \"GCST\") {\n    if (diseases?.length) {\n      traitLinks = (\n        <XRefLinks\n          label=\"Disease or phenotype\"\n          urlStem=\"../disease/\"\n          ids={diseases.map((d) => d.id)}\n          names={diseases.map((d) => d.name)}\n        />\n      );\n    }\n    sourceLink = {\n      id: \"GWAS Catalog\",\n      url: `https://www.ebi.ac.uk/gwas/studies/${studyId}`,\n    };\n  } else if (projectId?.startsWith(\"FINNGEN\")) {\n    if (diseases?.length) {\n      traitLinks = (\n        <XRefLinks\n          label=\"Trait\"\n          urlStem=\"../disease/\"\n          ids={diseases.map((d) => d.id)}\n          names={diseases.map((d) => d.name)}\n        />\n      );\n    }\n    sourceLink = {\n      id: \"FinnGen\",\n      url: `https://r12.finngen.fi/pheno/${studyId.slice(12)}`, // remove FINNGEN_R12_ from start\n    };\n  } else if (projectId === \"UKB_PPP_EUR\") {\n    if (diseases?.length) {\n      traitLinks = (\n        <XRefLinks\n          label=\"Trait\"\n          urlStem=\"../disease/\"\n          ids={diseases.map((d) => d.id)}\n          names={diseases.map((d) => d.name)}\n        />\n      );\n    }\n    sourceLink = {\n      id: \"UKB-PPP\",\n      url: \"https://www.synapse.org/Synapse:syn51364943/wiki/622119\",\n    };\n  } else {\n    // QTL\n    if (targetId) {\n      traitLinks = (\n        <ExternalLink title=\"Affected gene\" id={targetId} url={`../target/${targetId}`} />\n      );\n    }\n    sourceLink = {\n      id: \"eQTL Catalog\",\n      url: \"https://www.ebi.ac.uk/eqtl/Studies/\",\n    };\n  }\n\n  return (\n    <HeaderBase\n      loading={loading}\n      title={studyId}\n      subtitle={null}\n      Icon={faChartBar}\n      externalLinks={\n        <>\n          {traitLinks}\n          {projectId === \"GWAS\" && backgroundTraits?.length > 0 && (\n            <XRefLinks\n              label=\"Background traits\"\n              urlStem=\"../disease/\"\n              ids={backgroundTraits.map((t) => t.id)}\n              names={backgroundTraits.map((t) => t.name)}\n            />\n          )}\n          <ExternalLink title=\"Source\" id={sourceLink.id} url={sourceLink.url} />\n        </>\n      }\n    />\n  );\n}\n\nexport default Header;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/StudyPage/Header.tsx" },
        "span": [499, 509],
        "sourceCode": "import { faChartBar } from \"@fortawesome/free-solid-svg-icons\";\nimport { ExternalLink, Header as HeaderBase, XRefLinks } from \"ui\";\n\ntype HeaderProps = {\n  loading: boolean;\n  studyId: string;\n  backgroundTraits: {\n    id: string;\n    name: string;\n  }[];\n  targetId: string;\n  diseases: {\n    id: string;\n    name: string;\n  }[];\n  studyCategory: string;\n};\n\nfunction Header({\n  loading,\n  studyId,\n  backgroundTraits,\n  targetId,\n  diseases,\n  projectId,\n}: HeaderProps) {\n  let traitLinks;\n  let sourceLink;\n  if (projectId === \"GCST\") {\n    if (diseases?.length) {\n      traitLinks = (\n        <XRefLinks\n          label=\"Disease or phenotype\"\n          urlStem=\"../disease/\"\n          ids={diseases.map((d) => d.id)}\n          names={diseases.map((d) => d.name)}\n        />\n      );\n    }\n    sourceLink = {\n      id: \"GWAS Catalog\",\n      url: `https://www.ebi.ac.uk/gwas/studies/${studyId}`,\n    };\n  } else if (projectId?.startsWith(\"FINNGEN\")) {\n    if (diseases?.length) {\n      traitLinks = (\n        <XRefLinks\n          label=\"Trait\"\n          urlStem=\"../disease/\"\n          ids={diseases.map((d) => d.id)}\n          names={diseases.map((d) => d.name)}\n        />\n      );\n    }\n    sourceLink = {\n      id: \"FinnGen\",\n      url: `https://r12.finngen.fi/pheno/${studyId.slice(12)}`, // remove FINNGEN_R12_ from start\n    };\n  } else if (projectId === \"UKB_PPP_EUR\") {\n    if (diseases?.length) {\n      traitLinks = (\n        <XRefLinks\n          label=\"Trait\"\n          urlStem=\"../disease/\"\n          ids={diseases.map((d) => d.id)}\n          names={diseases.map((d) => d.name)}\n        />\n      );\n    }\n    sourceLink = {\n      id: \"UKB-PPP\",\n      url: \"https://www.synapse.org/Synapse:syn51364943/wiki/622119\",\n    };\n  } else {\n    // QTL\n    if (targetId) {\n      traitLinks = (\n        <ExternalLink title=\"Affected gene\" id={targetId} url={`../target/${targetId}`} />\n      );\n    }\n    sourceLink = {\n      id: \"eQTL Catalog\",\n      url: \"https://www.ebi.ac.uk/eqtl/Studies/\",\n    };\n  }\n\n  return (\n    <HeaderBase\n      loading={loading}\n      title={studyId}\n      subtitle={null}\n      Icon={faChartBar}\n      externalLinks={\n        <>\n          {traitLinks}\n          {projectId === \"GWAS\" && backgroundTraits?.length > 0 && (\n            <XRefLinks\n              label=\"Background traits\"\n              urlStem=\"../disease/\"\n              ids={backgroundTraits.map((t) => t.id)}\n              names={backgroundTraits.map((t) => t.name)}\n            />\n          )}\n          <ExternalLink title=\"Source\" id={sourceLink.id} url={sourceLink.url} />\n        </>\n      }\n    />\n  );\n}\n\nexport default Header;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/TargetPage/ProfileHeader.jsx" },
        "span": [1182, 1566],
        "sourceCode": "import { useTheme } from \"@mui/styles\";\nimport {\n  ProfileHeader as BaseProfileHeader,\n  Field,\n  ProfileChipList,\n  Tooltip,\n  usePlatformApi,\n} from \"ui\";\nimport TargetDescription from \"./TargetDescription\";\n\nimport { clearDescriptionCodes } from \"@ot/utils\";\n\nimport { Box } from \"@mui/material\";\nimport { getGenomicLocation } from \"@ot/constants\";\nimport TARGET_PROFILE_HEADER_FRAGMENT from \"./TargetProfileHeader.gql\";\n\n/*\n * Target synonyms from the API have a \"label\" and a \"source\"\n * and can be lister more than once, with different sources.\n * Parse synonyms to a unique list (label) where terms can have\n * multiple sources in a tooltip\n */\nconst parseSynonyms = (synonyms) => {\n  const sources = {\n    HGNC: \"HGNC\",\n    uniprot: \"UniProt\",\n    NCBI_entrez: \"Entrez\",\n  };\n  // Synonyms needs to be sorted by source in specific order\n  // (order converted to a map for convenience when doing the sort)\n  const sortingOrder = [\"HGNC\", \"uniprot\", \"NCBI_entrez\"].reduce(\n    (acc, a, i) => ({ ...acc, [a]: i }),\n    {}\n  );\n  const sortedSynonyms = synonyms\n    .slice()\n    .sort((a, b) => sortingOrder[a.source] - sortingOrder[b.source]);\n\n  const parsedSynonyms = [];\n\n  sortedSynonyms.forEach((s) => {\n    const thisSyn = parsedSynonyms.find(\n      (parsedSynonym) => parsedSynonym.label.toLowerCase() === s.label.toLowerCase()\n    );\n    if (!thisSyn) {\n      parsedSynonyms.push({ label: s.label, tooltip: [s.source] });\n    } else {\n      // if synonym already in the list add the source to its tooltip\n      thisSyn.tooltip.push(s.source);\n    }\n  });\n\n  parsedSynonyms.forEach((syn) => {\n    syn.tooltip = `Source: ${syn.tooltip.map((s) => sources[s]).join(\", \")}`;\n  });\n\n  return parsedSynonyms;\n};\n\nfunction ProfileHeader() {\n  const { loading, error, data } = usePlatformApi();\n\n  const theme = useTheme();\n\n  // TODO: Errors!\n  if (error) return null;\n\n  const targetDescription = clearDescriptionCodes(\n    data?.target.functionDescriptions,\n    theme.palette.primary.main\n  );\n  const synonyms = parseSynonyms(data?.target.synonyms || []);\n\n  // geneInfo currently holds the details for the \"core essential\" chip,\n  // however in the future it will hold information to display other chips\n  const geneInfo = [\n    {\n      label: \"Core essential gene\",\n      tooltip: \"Source: Cancer DepMap\",\n      isVisible: data?.target.isEssential,\n    },\n  ];\n\n  return (\n    <BaseProfileHeader>\n      <>\n        <TargetDescription\n          loading={loading}\n          descriptions={targetDescription}\n          targetId={data?.target.id}\n        />\n        {data?.target.genomicLocation && (\n          <Box sx={{ mt: 1, typography: \"body2\" }} component=\"span\">\n            <Tooltip title=\"build | chromosome:start-end,strand\">\n              <Box\n                component=\"span\"\n                sx={{\n                  whiteSpace: \"nowrap\",\n                  background: (theme) => theme.palette.grey[600],\n                  border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                  p: \"1px 5px\",\n                  color: \"white\",\n                  borderRadius: \"5px 0 0 5px\",\n                }}\n              >\n                {/* TODO: check UI and add it to getGenomicLocation function */}\n                GRCh38\n              </Box>\n              <Box\n                component=\"span\"\n                sx={{\n                  whiteSpace: \"nowrap\",\n                  p: \"1px 5px\",\n                  color: (theme) => theme.palette.grey[600],\n                  border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                  borderRadius: \"0 5px 5px 0\",\n                }}\n              >\n                {getGenomicLocation(data?.target.genomicLocation)}\n              </Box>\n            </Tooltip>\n          </Box>\n        )}\n        {geneInfo\n          .filter((gi) => gi.isVisible)\n          .map((e) => (\n            <Box\n              key={e.label}\n              sx={{\n                whiteSpace: \"nowrap\",\n                p: \"1px 5px\",\n                color: (theme) => theme.palette.grey[600],\n                border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                borderRadius: \"5px\",\n                width: \"min-content\",\n                mt: 1,\n                typography: \"body2\",\n              }}\n            >\n              <Tooltip title={e.tooltip}>{e.label}</Tooltip>\n            </Box>\n          ))}\n      </>\n      <ProfileChipList title=\"Synonyms\" loading={loading}>\n        {synonyms}\n      </ProfileChipList>\n    </BaseProfileHeader>\n  );\n}\n\nProfileHeader.fragments = {\n  profileHeader: TARGET_PROFILE_HEADER_FRAGMENT,\n};\n\nexport default ProfileHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/TargetPage/ProfileHeader.jsx" },
        "span": [1571, 1687],
        "sourceCode": "import { useTheme } from \"@mui/styles\";\nimport {\n  ProfileHeader as BaseProfileHeader,\n  Field,\n  ProfileChipList,\n  Tooltip,\n  usePlatformApi,\n} from \"ui\";\nimport TargetDescription from \"./TargetDescription\";\n\nimport { clearDescriptionCodes } from \"@ot/utils\";\n\nimport { Box } from \"@mui/material\";\nimport { getGenomicLocation } from \"@ot/constants\";\nimport TARGET_PROFILE_HEADER_FRAGMENT from \"./TargetProfileHeader.gql\";\n\n/*\n * Target synonyms from the API have a \"label\" and a \"source\"\n * and can be lister more than once, with different sources.\n * Parse synonyms to a unique list (label) where terms can have\n * multiple sources in a tooltip\n */\nconst parseSynonyms = (synonyms) => {\n  const sources = {\n    HGNC: \"HGNC\",\n    uniprot: \"UniProt\",\n    NCBI_entrez: \"Entrez\",\n  };\n  // Synonyms needs to be sorted by source in specific order\n  // (order converted to a map for convenience when doing the sort)\n  const sortingOrder = [\"HGNC\", \"uniprot\", \"NCBI_entrez\"].reduce(\n    (acc, a, i) => ({ ...acc, [a]: i }),\n    {}\n  );\n  const sortedSynonyms = synonyms\n    .slice()\n    .sort((a, b) => sortingOrder[a.source] - sortingOrder[b.source]);\n\n  const parsedSynonyms = [];\n\n  sortedSynonyms.forEach((s) => {\n    const thisSyn = parsedSynonyms.find(\n      (parsedSynonym) => parsedSynonym.label.toLowerCase() === s.label.toLowerCase()\n    );\n    if (!thisSyn) {\n      parsedSynonyms.push({ label: s.label, tooltip: [s.source] });\n    } else {\n      // if synonym already in the list add the source to its tooltip\n      thisSyn.tooltip.push(s.source);\n    }\n  });\n\n  parsedSynonyms.forEach((syn) => {\n    syn.tooltip = `Source: ${syn.tooltip.map((s) => sources[s]).join(\", \")}`;\n  });\n\n  return parsedSynonyms;\n};\n\nfunction ProfileHeader() {\n  const { loading, error, data } = usePlatformApi();\n\n  const theme = useTheme();\n\n  // TODO: Errors!\n  if (error) return null;\n\n  const targetDescription = clearDescriptionCodes(\n    data?.target.functionDescriptions,\n    theme.palette.primary.main\n  );\n  const synonyms = parseSynonyms(data?.target.synonyms || []);\n\n  // geneInfo currently holds the details for the \"core essential\" chip,\n  // however in the future it will hold information to display other chips\n  const geneInfo = [\n    {\n      label: \"Core essential gene\",\n      tooltip: \"Source: Cancer DepMap\",\n      isVisible: data?.target.isEssential,\n    },\n  ];\n\n  return (\n    <BaseProfileHeader>\n      <>\n        <TargetDescription\n          loading={loading}\n          descriptions={targetDescription}\n          targetId={data?.target.id}\n        />\n        {data?.target.genomicLocation && (\n          <Box sx={{ mt: 1, typography: \"body2\" }} component=\"span\">\n            <Tooltip title=\"build | chromosome:start-end,strand\">\n              <Box\n                component=\"span\"\n                sx={{\n                  whiteSpace: \"nowrap\",\n                  background: (theme) => theme.palette.grey[600],\n                  border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                  p: \"1px 5px\",\n                  color: \"white\",\n                  borderRadius: \"5px 0 0 5px\",\n                }}\n              >\n                {/* TODO: check UI and add it to getGenomicLocation function */}\n                GRCh38\n              </Box>\n              <Box\n                component=\"span\"\n                sx={{\n                  whiteSpace: \"nowrap\",\n                  p: \"1px 5px\",\n                  color: (theme) => theme.palette.grey[600],\n                  border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                  borderRadius: \"0 5px 5px 0\",\n                }}\n              >\n                {getGenomicLocation(data?.target.genomicLocation)}\n              </Box>\n            </Tooltip>\n          </Box>\n        )}\n        {geneInfo\n          .filter((gi) => gi.isVisible)\n          .map((e) => (\n            <Box\n              key={e.label}\n              sx={{\n                whiteSpace: \"nowrap\",\n                p: \"1px 5px\",\n                color: (theme) => theme.palette.grey[600],\n                border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                borderRadius: \"5px\",\n                width: \"min-content\",\n                mt: 1,\n                typography: \"body2\",\n              }}\n            >\n              <Tooltip title={e.tooltip}>{e.label}</Tooltip>\n            </Box>\n          ))}\n      </>\n      <ProfileChipList title=\"Synonyms\" loading={loading}>\n        {synonyms}\n      </ProfileChipList>\n    </BaseProfileHeader>\n  );\n}\n\nProfileHeader.fragments = {\n  profileHeader: TARGET_PROFILE_HEADER_FRAGMENT,\n};\n\nexport default ProfileHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/TargetPage/ProfileHeader.jsx" },
        "span": [1001, 1007],
        "sourceCode": "import { useTheme } from \"@mui/styles\";\nimport {\n  ProfileHeader as BaseProfileHeader,\n  Field,\n  ProfileChipList,\n  Tooltip,\n  usePlatformApi,\n} from \"ui\";\nimport TargetDescription from \"./TargetDescription\";\n\nimport { clearDescriptionCodes } from \"@ot/utils\";\n\nimport { Box } from \"@mui/material\";\nimport { getGenomicLocation } from \"@ot/constants\";\nimport TARGET_PROFILE_HEADER_FRAGMENT from \"./TargetProfileHeader.gql\";\n\n/*\n * Target synonyms from the API have a \"label\" and a \"source\"\n * and can be lister more than once, with different sources.\n * Parse synonyms to a unique list (label) where terms can have\n * multiple sources in a tooltip\n */\nconst parseSynonyms = (synonyms) => {\n  const sources = {\n    HGNC: \"HGNC\",\n    uniprot: \"UniProt\",\n    NCBI_entrez: \"Entrez\",\n  };\n  // Synonyms needs to be sorted by source in specific order\n  // (order converted to a map for convenience when doing the sort)\n  const sortingOrder = [\"HGNC\", \"uniprot\", \"NCBI_entrez\"].reduce(\n    (acc, a, i) => ({ ...acc, [a]: i }),\n    {}\n  );\n  const sortedSynonyms = synonyms\n    .slice()\n    .sort((a, b) => sortingOrder[a.source] - sortingOrder[b.source]);\n\n  const parsedSynonyms = [];\n\n  sortedSynonyms.forEach((s) => {\n    const thisSyn = parsedSynonyms.find(\n      (parsedSynonym) => parsedSynonym.label.toLowerCase() === s.label.toLowerCase()\n    );\n    if (!thisSyn) {\n      parsedSynonyms.push({ label: s.label, tooltip: [s.source] });\n    } else {\n      // if synonym already in the list add the source to its tooltip\n      thisSyn.tooltip.push(s.source);\n    }\n  });\n\n  parsedSynonyms.forEach((syn) => {\n    syn.tooltip = `Source: ${syn.tooltip.map((s) => sources[s]).join(\", \")}`;\n  });\n\n  return parsedSynonyms;\n};\n\nfunction ProfileHeader() {\n  const { loading, error, data } = usePlatformApi();\n\n  const theme = useTheme();\n\n  // TODO: Errors!\n  if (error) return null;\n\n  const targetDescription = clearDescriptionCodes(\n    data?.target.functionDescriptions,\n    theme.palette.primary.main\n  );\n  const synonyms = parseSynonyms(data?.target.synonyms || []);\n\n  // geneInfo currently holds the details for the \"core essential\" chip,\n  // however in the future it will hold information to display other chips\n  const geneInfo = [\n    {\n      label: \"Core essential gene\",\n      tooltip: \"Source: Cancer DepMap\",\n      isVisible: data?.target.isEssential,\n    },\n  ];\n\n  return (\n    <BaseProfileHeader>\n      <>\n        <TargetDescription\n          loading={loading}\n          descriptions={targetDescription}\n          targetId={data?.target.id}\n        />\n        {data?.target.genomicLocation && (\n          <Box sx={{ mt: 1, typography: \"body2\" }} component=\"span\">\n            <Tooltip title=\"build | chromosome:start-end,strand\">\n              <Box\n                component=\"span\"\n                sx={{\n                  whiteSpace: \"nowrap\",\n                  background: (theme) => theme.palette.grey[600],\n                  border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                  p: \"1px 5px\",\n                  color: \"white\",\n                  borderRadius: \"5px 0 0 5px\",\n                }}\n              >\n                {/* TODO: check UI and add it to getGenomicLocation function */}\n                GRCh38\n              </Box>\n              <Box\n                component=\"span\"\n                sx={{\n                  whiteSpace: \"nowrap\",\n                  p: \"1px 5px\",\n                  color: (theme) => theme.palette.grey[600],\n                  border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                  borderRadius: \"0 5px 5px 0\",\n                }}\n              >\n                {getGenomicLocation(data?.target.genomicLocation)}\n              </Box>\n            </Tooltip>\n          </Box>\n        )}\n        {geneInfo\n          .filter((gi) => gi.isVisible)\n          .map((e) => (\n            <Box\n              key={e.label}\n              sx={{\n                whiteSpace: \"nowrap\",\n                p: \"1px 5px\",\n                color: (theme) => theme.palette.grey[600],\n                border: (theme) => `1px solid ${theme.palette.grey[600]}`,\n                borderRadius: \"5px\",\n                width: \"min-content\",\n                mt: 1,\n                typography: \"body2\",\n              }}\n            >\n              <Tooltip title={e.tooltip}>{e.label}</Tooltip>\n            </Box>\n          ))}\n      </>\n      <ProfileChipList title=\"Synonyms\" loading={loading}>\n        {synonyms}\n      </ProfileChipList>\n    </BaseProfileHeader>\n  );\n}\n\nProfileHeader.fragments = {\n  profileHeader: TARGET_PROFILE_HEADER_FRAGMENT,\n};\n\nexport default ProfileHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/useKeyWithClickEvents",
      "severity": "error",
      "description": "Enforce to have the onClick mouse event with the onKeyUp, the onKeyDown, or the onKeyPress keyboard event.",
      "message": [
        { "elements": [], "content": "Enforce to have the " },
        { "elements": ["Emphasis"], "content": "onClick" },
        { "elements": [], "content": " mouse event with the " },
        { "elements": ["Emphasis"], "content": "onKeyUp" },
        { "elements": [], "content": ", the " },
        { "elements": ["Emphasis"], "content": "onKeyDown" },
        { "elements": [], "content": ", or the " },
        { "elements": ["Emphasis"], "content": "onKeyPress" },
        { "elements": [], "content": " keyboard event." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/TargetPage/TargetDescription.jsx" },
        "span": [2031, 2105],
        "sourceCode": "import { Skeleton, Typography } from \"@mui/material\";\nimport { withStyles } from \"@mui/styles\";\nimport { useLayoutEffect, useRef, useState } from \"react\";\nimport { v1 } from \"uuid\";\n\nconst styles = (theme) => ({\n  textContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    overflow: \"hidden\",\n    \"& span:not(:last-child)\": { marginBottom: \"12px\" },\n  },\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n});\n\nconst getStyleHeight = ({ newNumberOfLines, lineLimit, showMore, lineHeight }) => {\n  if (newNumberOfLines <= lineLimit) return \"auto\";\n  if (showMore) return \"auto\";\n  return `${lineLimit * lineHeight}px`;\n};\n\nfunction LongText({\n  classes,\n  lineLimit,\n  children,\n  variant = \"body2\",\n  descriptions,\n  targetId,\n  hasGutterBottom = false,\n}) {\n  const containerRef = useRef();\n  const [showMore, setShowMore] = useState(false);\n  const [numberOfLines, setNumberOfLines] = useState();\n\n  useLayoutEffect(() => {\n    const container = containerRef.current;\n    const el = containerRef.current;\n    const height = el.offsetHeight;\n    const lineHeight = Number.parseInt(\n      document.defaultView.getComputedStyle(el, null).getPropertyValue(\"line-height\"),\n      10\n    );\n    const newNumberOfLines = Math.round(height / lineHeight);\n\n    container.style.height = getStyleHeight({\n      newNumberOfLines,\n      lineHeight,\n      lineLimit,\n      showMore,\n    });\n\n    setNumberOfLines(newNumberOfLines);\n  }, [lineLimit, showMore, children]);\n\n  function createDescriptionMarkup(desc) {\n    return { __html: desc };\n  }\n\n  return (\n    <Typography variant={variant} gutterBottom={hasGutterBottom}>\n      <span ref={containerRef} className={classes.textContainer}>\n        {descriptions.map((desc, _i) => (\n          <span\n            key={`${targetId}-${v1()}`}\n            dangerouslySetInnerHTML={createDescriptionMarkup(desc)}\n          />\n        ))}\n      </span>\n      {numberOfLines >= lineLimit && (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      )}\n    </Typography>\n  );\n}\n\nconst StyledLongText = withStyles(styles)(LongText);\n\nfunction TargetDescription({\n  descriptions,\n  loading = false,\n  showLabel = true,\n  targetId,\n  lineLimit = 3,\n}) {\n  let content;\n\n  if (!descriptions || descriptions.length < 1) {\n    content = (\n      <Typography variant=\"body2\" gutterBottom>\n        No description available\n      </Typography>\n    );\n  } else {\n    content = (\n      <StyledLongText\n        lineLimit={lineLimit}\n        descriptions={descriptions}\n        targetId={targetId}\n        hasGutterBottom\n      />\n    );\n  }\n\n  return (\n    <>\n      {showLabel && <Typography variant=\"subtitle2\">Description</Typography>}\n      {loading ? <Skeleton height=\"6.5rem\" /> : content}\n    </>\n  );\n}\n\nexport default TargetDescription;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: children",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: children"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Outer scope values aren't valid dependencies because mutating them doesn't re-render the component."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1488, 1496],
              "sourceCode": "import { Skeleton, Typography } from \"@mui/material\";\nimport { withStyles } from \"@mui/styles\";\nimport { useLayoutEffect, useRef, useState } from \"react\";\nimport { v1 } from \"uuid\";\n\nconst styles = (theme) => ({\n  textContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    overflow: \"hidden\",\n    \"& span:not(:last-child)\": { marginBottom: \"12px\" },\n  },\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n});\n\nconst getStyleHeight = ({ newNumberOfLines, lineLimit, showMore, lineHeight }) => {\n  if (newNumberOfLines <= lineLimit) return \"auto\";\n  if (showMore) return \"auto\";\n  return `${lineLimit * lineHeight}px`;\n};\n\nfunction LongText({\n  classes,\n  lineLimit,\n  children,\n  variant = \"body2\",\n  descriptions,\n  targetId,\n  hasGutterBottom = false,\n}) {\n  const containerRef = useRef();\n  const [showMore, setShowMore] = useState(false);\n  const [numberOfLines, setNumberOfLines] = useState();\n\n  useLayoutEffect(() => {\n    const container = containerRef.current;\n    const el = containerRef.current;\n    const height = el.offsetHeight;\n    const lineHeight = Number.parseInt(\n      document.defaultView.getComputedStyle(el, null).getPropertyValue(\"line-height\"),\n      10\n    );\n    const newNumberOfLines = Math.round(height / lineHeight);\n\n    container.style.height = getStyleHeight({\n      newNumberOfLines,\n      lineHeight,\n      lineLimit,\n      showMore,\n    });\n\n    setNumberOfLines(newNumberOfLines);\n  }, [lineLimit, showMore, children]);\n\n  function createDescriptionMarkup(desc) {\n    return { __html: desc };\n  }\n\n  return (\n    <Typography variant={variant} gutterBottom={hasGutterBottom}>\n      <span ref={containerRef} className={classes.textContainer}>\n        {descriptions.map((desc, _i) => (\n          <span\n            key={`${targetId}-${v1()}`}\n            dangerouslySetInnerHTML={createDescriptionMarkup(desc)}\n          />\n        ))}\n      </span>\n      {numberOfLines >= lineLimit && (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      )}\n    </Typography>\n  );\n}\n\nconst StyledLongText = withStyles(styles)(LongText);\n\nfunction TargetDescription({\n  descriptions,\n  loading = false,\n  showLabel = true,\n  targetId,\n  lineLimit = 3,\n}) {\n  let content;\n\n  if (!descriptions || descriptions.length < 1) {\n    content = (\n      <Typography variant=\"body2\" gutterBottom>\n        No description available\n      </Typography>\n    );\n  } else {\n    content = (\n      <StyledLongText\n        lineLimit={lineLimit}\n        descriptions={descriptions}\n        targetId={targetId}\n        hasGutterBottom\n      />\n    );\n  }\n\n  return (\n    <>\n      {showLabel && <Typography variant=\"subtitle2\">Description</Typography>}\n      {loading ? <Skeleton height=\"6.5rem\" /> : content}\n    </>\n  );\n}\n\nexport default TargetDescription;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/TargetPage/TargetDescription.jsx" },
        "span": [944, 959],
        "sourceCode": "import { Skeleton, Typography } from \"@mui/material\";\nimport { withStyles } from \"@mui/styles\";\nimport { useLayoutEffect, useRef, useState } from \"react\";\nimport { v1 } from \"uuid\";\n\nconst styles = (theme) => ({\n  textContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    overflow: \"hidden\",\n    \"& span:not(:last-child)\": { marginBottom: \"12px\" },\n  },\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n});\n\nconst getStyleHeight = ({ newNumberOfLines, lineLimit, showMore, lineHeight }) => {\n  if (newNumberOfLines <= lineLimit) return \"auto\";\n  if (showMore) return \"auto\";\n  return `${lineLimit * lineHeight}px`;\n};\n\nfunction LongText({\n  classes,\n  lineLimit,\n  children,\n  variant = \"body2\",\n  descriptions,\n  targetId,\n  hasGutterBottom = false,\n}) {\n  const containerRef = useRef();\n  const [showMore, setShowMore] = useState(false);\n  const [numberOfLines, setNumberOfLines] = useState();\n\n  useLayoutEffect(() => {\n    const container = containerRef.current;\n    const el = containerRef.current;\n    const height = el.offsetHeight;\n    const lineHeight = Number.parseInt(\n      document.defaultView.getComputedStyle(el, null).getPropertyValue(\"line-height\"),\n      10\n    );\n    const newNumberOfLines = Math.round(height / lineHeight);\n\n    container.style.height = getStyleHeight({\n      newNumberOfLines,\n      lineHeight,\n      lineLimit,\n      showMore,\n    });\n\n    setNumberOfLines(newNumberOfLines);\n  }, [lineLimit, showMore, children]);\n\n  function createDescriptionMarkup(desc) {\n    return { __html: desc };\n  }\n\n  return (\n    <Typography variant={variant} gutterBottom={hasGutterBottom}>\n      <span ref={containerRef} className={classes.textContainer}>\n        {descriptions.map((desc, _i) => (\n          <span\n            key={`${targetId}-${v1()}`}\n            dangerouslySetInnerHTML={createDescriptionMarkup(desc)}\n          />\n        ))}\n      </span>\n      {numberOfLines >= lineLimit && (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      )}\n    </Typography>\n  );\n}\n\nconst StyledLongText = withStyles(styles)(LongText);\n\nfunction TargetDescription({\n  descriptions,\n  loading = false,\n  showLabel = true,\n  targetId,\n  lineLimit = 3,\n}) {\n  let content;\n\n  if (!descriptions || descriptions.length < 1) {\n    content = (\n      <Typography variant=\"body2\" gutterBottom>\n        No description available\n      </Typography>\n    );\n  } else {\n    content = (\n      <StyledLongText\n        lineLimit={lineLimit}\n        descriptions={descriptions}\n        targetId={targetId}\n        hasGutterBottom\n      />\n    );\n  }\n\n  return (\n    <>\n      {showLabel && <Typography variant=\"subtitle2\">Description</Typography>}\n      {loading ? <Skeleton height=\"6.5rem\" /> : content}\n    </>\n  );\n}\n\nexport default TargetDescription;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/security/noDangerouslySetInnerHtml",
      "severity": "error",
      "description": "Avoid passing content using the dangerouslySetInnerHTML prop.",
      "message": [
        { "elements": [], "content": "Avoid passing content using the " },
        { "elements": ["Emphasis"], "content": "dangerouslySetInnerHTML" },
        { "elements": [], "content": " prop." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "warn",
              [
                {
                  "elements": [],
                  "content": "Setting content using code can expose users to cross-site scripting (XSS) attacks"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./apps/platform/src/pages/TargetPage/TargetDescription.jsx" },
        "span": [1831, 1854],
        "sourceCode": "import { Skeleton, Typography } from \"@mui/material\";\nimport { withStyles } from \"@mui/styles\";\nimport { useLayoutEffect, useRef, useState } from \"react\";\nimport { v1 } from \"uuid\";\n\nconst styles = (theme) => ({\n  textContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    overflow: \"hidden\",\n    \"& span:not(:last-child)\": { marginBottom: \"12px\" },\n  },\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n});\n\nconst getStyleHeight = ({ newNumberOfLines, lineLimit, showMore, lineHeight }) => {\n  if (newNumberOfLines <= lineLimit) return \"auto\";\n  if (showMore) return \"auto\";\n  return `${lineLimit * lineHeight}px`;\n};\n\nfunction LongText({\n  classes,\n  lineLimit,\n  children,\n  variant = \"body2\",\n  descriptions,\n  targetId,\n  hasGutterBottom = false,\n}) {\n  const containerRef = useRef();\n  const [showMore, setShowMore] = useState(false);\n  const [numberOfLines, setNumberOfLines] = useState();\n\n  useLayoutEffect(() => {\n    const container = containerRef.current;\n    const el = containerRef.current;\n    const height = el.offsetHeight;\n    const lineHeight = Number.parseInt(\n      document.defaultView.getComputedStyle(el, null).getPropertyValue(\"line-height\"),\n      10\n    );\n    const newNumberOfLines = Math.round(height / lineHeight);\n\n    container.style.height = getStyleHeight({\n      newNumberOfLines,\n      lineHeight,\n      lineLimit,\n      showMore,\n    });\n\n    setNumberOfLines(newNumberOfLines);\n  }, [lineLimit, showMore, children]);\n\n  function createDescriptionMarkup(desc) {\n    return { __html: desc };\n  }\n\n  return (\n    <Typography variant={variant} gutterBottom={hasGutterBottom}>\n      <span ref={containerRef} className={classes.textContainer}>\n        {descriptions.map((desc, _i) => (\n          <span\n            key={`${targetId}-${v1()}`}\n            dangerouslySetInnerHTML={createDescriptionMarkup(desc)}\n          />\n        ))}\n      </span>\n      {numberOfLines >= lineLimit && (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      )}\n    </Typography>\n  );\n}\n\nconst StyledLongText = withStyles(styles)(LongText);\n\nfunction TargetDescription({\n  descriptions,\n  loading = false,\n  showLabel = true,\n  targetId,\n  lineLimit = 3,\n}) {\n  let content;\n\n  if (!descriptions || descriptions.length < 1) {\n    content = (\n      <Typography variant=\"body2\" gutterBottom>\n        No description available\n      </Typography>\n    );\n  } else {\n    content = (\n      <StyledLongText\n        lineLimit={lineLimit}\n        descriptions={descriptions}\n        targetId={targetId}\n        hasGutterBottom\n      />\n    );\n  }\n\n  return (\n    <>\n      {showLabel && <Typography variant=\"subtitle2\">Description</Typography>}\n      {loading ? <Skeleton height=\"6.5rem\" /> : content}\n    </>\n  );\n}\n\nexport default TargetDescription;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/utils.js" },
        "span": [216, 222],
        "sourceCode": "/*\n  Returns a list of breakpoints translating values from hidden prop.\n */\nexport const getHiddenBreakpoints = (column) =>\n  column.hidden?.reduce(\n    (obj, b) => {\n      if (b.includes(\"Only\")) {\n        return { ...obj, only: [...obj.only, b.replace(/Only/, \"\")] };\n      }\n      return { ...obj, [b]: true };\n    },\n    { only: [] }\n  );\n\nexport const getPage = (rows, page, pageSize) =>\n  rows.slice(pageSize * page, pageSize * page + pageSize);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/utils.js" },
        "span": [293, 299],
        "sourceCode": "/*\n  Returns a list of breakpoints translating values from hidden prop.\n */\nexport const getHiddenBreakpoints = (column) =>\n  column.hidden?.reduce(\n    (obj, b) => {\n      if (b.includes(\"Only\")) {\n        return { ...obj, only: [...obj.only, b.replace(/Only/, \"\")] };\n      }\n      return { ...obj, [b]: true };\n    },\n    { only: [] }\n  );\n\nexport const getPage = (rows, page, pageSize) =>\n  rows.slice(pageSize * page, pageSize * page + pageSize);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [0, 4],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [5, 8],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [9, 11],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `.`",
      "message": [{ "elements": [], "content": "unexpected character `.`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [11, 12],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "End of file expected",
      "message": [{ "elements": [], "content": "End of file expected" }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Use an array for a sequence of values: `[1, 2]`" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [12, 17],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [18, 19],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [20, 21],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [21, 26],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [26, 27],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [27, 38],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [38, 39],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [39, 47],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [47, 48],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [48, 50],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [50, 51],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [51, 53],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [53, 54],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [54, 56],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [56, 57],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [57, 61],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [61, 62],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [62, 74],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [74, 75],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `.`",
      "message": [{ "elements": [], "content": "unexpected character `.`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [75, 76],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [76, 79],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [79, 80],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [80, 85],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [86, 91],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `.`",
      "message": [{ "elements": [], "content": "unexpected character `.`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [92, 93],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [94, 95],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [95, 96],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [96, 106],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [106, 107],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [107, 112],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `=`",
      "message": [{ "elements": [], "content": "unexpected character `=`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [112, 113],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [113, 118],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [119, 120],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [120, 121],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [121, 129],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `=`",
      "message": [{ "elements": [], "content": "unexpected character `=`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [129, 130],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [130, 134],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [134, 135],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [135, 141],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [0, 4],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [5, 8],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [9, 11],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `.`",
      "message": [{ "elements": [], "content": "unexpected character `.`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [11, 12],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "End of file expected",
      "message": [{ "elements": [], "content": "End of file expected" }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Use an array for a sequence of values: `[1, 2]`" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [12, 17],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [18, 19],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [20, 21],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [21, 26],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [26, 27],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [27, 38],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [38, 39],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [39, 47],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [47, 48],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [48, 50],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [50, 51],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [51, 53],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [53, 54],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [54, 56],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [56, 57],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [57, 61],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [61, 62],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [62, 74],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [74, 75],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `.`",
      "message": [{ "elements": [], "content": "unexpected character `.`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [75, 76],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [76, 79],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `/`",
      "message": [{ "elements": [], "content": "unexpected character `/`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [79, 80],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [80, 85],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [86, 91],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `.`",
      "message": [{ "elements": [], "content": "unexpected character `.`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [92, 93],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [94, 95],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [95, 96],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [96, 106],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [106, 107],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [107, 112],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `=`",
      "message": [{ "elements": [], "content": "unexpected character `=`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [112, 113],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [113, 118],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [119, 120],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [120, 121],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [121, 129],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "unexpected character `=`",
      "message": [{ "elements": [], "content": "unexpected character `=`" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [129, 130],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [130, 134],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "Minus must be followed by a digit",
      "message": [{ "elements": [], "content": "Minus must be followed by a digit" }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [134, 135],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "parse",
      "severity": "error",
      "description": "String values must be double quoted.",
      "message": [{ "elements": [], "content": "String values must be double quoted." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./biome-errors.json" },
        "span": [135, 141],
        "sourceCode": "yarn run v1.22.22\n$ /Users/carlos_cruz/projects/ot/ot-ui-apps/node_modules/.bin/biome check . --diagnostic-level=error --reporter=json-pretty\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "format",
      "severity": "error",
      "description": "Code formatting aborted due to parsing errors. To format code with errors, enable the 'formatter.formatWithErrors' option.",
      "message": [
        {
          "elements": [],
          "content": "Code formatting aborted due to parsing errors. To format code with errors, enable the 'formatter.formatWithErrors' option."
        }
      ],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": { "path": { "file": "./biome-errors.json" }, "span": null, "sourceCode": null },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [571, 576],
              "sourceCode": "import { Hidden, TableRow as MUITableRow, TableCell } from \"@mui/material\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction TableRow({ columns, hover, isFixedRow, noWrap, row, style, onClick, selected }) {\n  const classes = tableStyles();\n\n  return (\n    <MUITableRow\n      classes={{ root: isFixedRow ? classes.rowFixed : \"\" }}\n      hover={hover}\n      onClick={onClick}\n      selected={selected}\n    >\n      {columns.map((column, index) => (\n        <Hidden {...getHiddenBreakpoints(column)} key={index}>\n          <TableCell\n            align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n            classes={{\n              root: classNames(classes.cell, classes.cellBody, column.classes?.cell, {\n                [classes.tabularNums]: column.numeric,\n                [classes.cellSticky]: column.sticky,\n                [classes.noWrap]: noWrap,\n              }),\n            }}\n            component={column.sticky ? \"th\" : \"td\"}\n            key={index}\n            style={{ ...column.style, ...row.rowStyle, ...style }}\n          >\n            {column.renderCell\n              ? column.renderCell(row)\n              : _.get(row, column.propertyPath || column.id, \"N/A\")}\n          </TableCell>\n        </Hidden>\n      ))}\n    </MUITableRow>\n  );\n}\n\nexport default TableRow;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/TableRow.jsx" },
        "span": [638, 643],
        "sourceCode": "import { Hidden, TableRow as MUITableRow, TableCell } from \"@mui/material\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction TableRow({ columns, hover, isFixedRow, noWrap, row, style, onClick, selected }) {\n  const classes = tableStyles();\n\n  return (\n    <MUITableRow\n      classes={{ root: isFixedRow ? classes.rowFixed : \"\" }}\n      hover={hover}\n      onClick={onClick}\n      selected={selected}\n    >\n      {columns.map((column, index) => (\n        <Hidden {...getHiddenBreakpoints(column)} key={index}>\n          <TableCell\n            align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n            classes={{\n              root: classNames(classes.cell, classes.cellBody, column.classes?.cell, {\n                [classes.tabularNums]: column.numeric,\n                [classes.cellSticky]: column.sticky,\n                [classes.noWrap]: noWrap,\n              }),\n            }}\n            component={column.sticky ? \"th\" : \"td\"}\n            key={index}\n            style={{ ...column.style, ...row.rowStyle, ...style }}\n          >\n            {column.renderCell\n              ? column.renderCell(row)\n              : _.get(row, column.propertyPath || column.id, \"N/A\")}\n          </TableCell>\n        </Hidden>\n      ))}\n    </MUITableRow>\n  );\n}\n\nexport default TableRow;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [571, 576],
              "sourceCode": "import { Hidden, TableRow as MUITableRow, TableCell } from \"@mui/material\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction TableRow({ columns, hover, isFixedRow, noWrap, row, style, onClick, selected }) {\n  const classes = tableStyles();\n\n  return (\n    <MUITableRow\n      classes={{ root: isFixedRow ? classes.rowFixed : \"\" }}\n      hover={hover}\n      onClick={onClick}\n      selected={selected}\n    >\n      {columns.map((column, index) => (\n        <Hidden {...getHiddenBreakpoints(column)} key={index}>\n          <TableCell\n            align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n            classes={{\n              root: classNames(classes.cell, classes.cellBody, column.classes?.cell, {\n                [classes.tabularNums]: column.numeric,\n                [classes.cellSticky]: column.sticky,\n                [classes.noWrap]: noWrap,\n              }),\n            }}\n            component={column.sticky ? \"th\" : \"td\"}\n            key={index}\n            style={{ ...column.style, ...row.rowStyle, ...style }}\n          >\n            {column.renderCell\n              ? column.renderCell(row)\n              : _.get(row, column.propertyPath || column.id, \"N/A\")}\n          </TableCell>\n        </Hidden>\n      ))}\n    </MUITableRow>\n  );\n}\n\nexport default TableRow;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/TableRow.jsx" },
        "span": [1113, 1118],
        "sourceCode": "import { Hidden, TableRow as MUITableRow, TableCell } from \"@mui/material\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction TableRow({ columns, hover, isFixedRow, noWrap, row, style, onClick, selected }) {\n  const classes = tableStyles();\n\n  return (\n    <MUITableRow\n      classes={{ root: isFixedRow ? classes.rowFixed : \"\" }}\n      hover={hover}\n      onClick={onClick}\n      selected={selected}\n    >\n      {columns.map((column, index) => (\n        <Hidden {...getHiddenBreakpoints(column)} key={index}>\n          <TableCell\n            align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n            classes={{\n              root: classNames(classes.cell, classes.cellBody, column.classes?.cell, {\n                [classes.tabularNums]: column.numeric,\n                [classes.cellSticky]: column.sticky,\n                [classes.noWrap]: noWrap,\n              }),\n            }}\n            component={column.sticky ? \"th\" : \"td\"}\n            key={index}\n            style={{ ...column.style, ...row.rowStyle, ...style }}\n          >\n            {column.renderCell\n              ? column.renderCell(row)\n              : _.get(row, column.propertyPath || column.id, \"N/A\")}\n          </TableCell>\n        </Hidden>\n      ))}\n    </MUITableRow>\n  );\n}\n\nexport default TableRow;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ot-utils/src/downloads.js" },
        "span": [536, 550],
        "sourceCode": "import _ from \"lodash\";\n\nconst targetName = {\n  id: \"symbol\",\n  label: \"Symbol\",\n  exportValue: (data) => data.target.approvedSymbol,\n};\n\nconst diseaseName = {\n  id: \"disease\",\n  label: \"Disease\",\n  exportValue: (data) => data.disease.name,\n};\n\nconst asJSON = (columns, rows) => {\n  const rowStrings = rows.map((row) =>\n    columns.reduce((accumulator, newKey) => {\n      if (newKey.exportValue === false) return accumulator;\n\n      const newLabel = _.camelCase(newKey.exportLabel || newKey.label || newKey.id);\n\n      return {\n        ...accumulator,\n        [newLabel]: newKey.exportValue\n          ? newKey.exportValue(row)\n          : _.get(row, newKey.propertyPath || newKey.id, \"\"),\n      };\n    }, {})\n  );\n\n  return JSON.stringify(rowStrings);\n};\n\nconst getHeaderString = ({ columns, quoteString, separator }) =>\n  columns\n    .reduce((headerString, column) => {\n      if (column.exportValue === false) return headerString;\n\n      const newLabel = quoteString(_.camelCase(column.exportLabel || column.label || column.id));\n\n      return [...headerString, newLabel];\n    }, [])\n    .join(separator);\n\nconst asDSV = (columns, rows, separator = \",\", quoteStrings = true) => {\n  const quoteString = (d) => {\n    let result = d;\n    // converts arrays to strings\n    if (Array.isArray(d)) {\n      result = d.join(\",\");\n    }\n    return quoteStrings && typeof result === \"string\" ? `\"${result}\"` : result;\n  };\n\n  const lineSeparator = \"\\n\";\n\n  const headerString = getHeaderString({ columns, quoteString, separator });\n\n  const rowStrings = rows\n    .map((row) =>\n      columns\n        .reduce((rowString, column) => {\n          if (column.exportValue === false) return rowString;\n\n          const newValue = quoteString(\n            column.exportValue\n              ? column.exportValue(row)\n              : _.get(row, column.propertyPath || column.id, \"\")\n          );\n\n          return [...rowString, newValue];\n        }, [])\n        .join(separator)\n    )\n    .join(lineSeparator);\n\n  return [headerString, rowStrings].join(lineSeparator);\n};\n\nexport const getRowsQuerySelector = (entityToGet) =>\n  entityToGet === \"target\" ? \"data.disease.associatedTargets\" : \"data.target.associatedDiseases\";\n\nexport const getExportedColumns = (entityToGet, assocArr, prioArr, pinnedArr) => {\n  const nameColumn = entityToGet === \"target\" ? targetName : diseaseName;\n  let exportedColumns = [];\n\n  if (pinnedArr.length > 0) {\n    const isPinnedObj = [\n      {\n        id: \"isPinned\",\n        exportValue: (data) =>\n          pinnedArr.some((currentValue) => currentValue.id === data[entityToGet].id),\n      },\n    ];\n    exportedColumns = [...exportedColumns, ...isPinnedObj];\n  }\n\n  const sources = assocArr.map(({ id }) => ({\n    id,\n    exportValue: (data) => {\n      const datatypeScore = data.datasourceScores.find(\n        (datasourceScore) => datasourceScore.componentId === id\n      );\n      return datatypeScore ? Number.parseFloat(datatypeScore.score) : \"No data\";\n    },\n  }));\n\n  exportedColumns = [...exportedColumns, ...sources];\n\n  if (entityToGet === \"target\") {\n    const prioritisationExportCols = prioArr.map(({ id }) => ({\n      id,\n      exportValue: (data) => {\n        const prioritisationScore = data.target.prioritisation.items.find(\n          (prioritisationItem) => prioritisationItem.key === id\n        );\n        return prioritisationScore ? Number.parseFloat(prioritisationScore.value) : \"No data\";\n      },\n    }));\n\n    exportedColumns = [...exportedColumns, ...prioritisationExportCols];\n  }\n\n  return [\n    nameColumn,\n    {\n      id: \"globalScore\",\n      label: \"Global Score\",\n      exportValue: (data) => data.score,\n    },\n    ...exportedColumns,\n  ];\n};\n\nexport const getExportedPrioritisationColumns = (arr, pinnedArr, entityToGet) => {\n  let exportedColumns = [];\n\n  if (pinnedArr.length > 0) {\n    const isPinnedObj = [\n      {\n        id: \"isPinned\",\n        exportValue: (data) =>\n          pinnedArr.some((currentValue) => currentValue.id === data[entityToGet].id),\n      },\n    ];\n    exportedColumns = [...exportedColumns, ...isPinnedObj];\n  }\n\n  const prioritisationExportCols = arr.map(({ id }) => ({\n    id,\n    exportValue: (data) => {\n      const prioritisationScore = data.target.prioritisation.items.find(\n        (prioritisationItem) => prioritisationItem.key === id\n      );\n      return prioritisationScore ? Number.parseFloat(prioritisationScore.value) : \"No data\";\n    },\n  }));\n\n  exportedColumns = [...exportedColumns, ...prioritisationExportCols];\n\n  return [\n    targetName,\n    {\n      id: \"globalScore\",\n      label: \"Global Score\",\n      exportValue: (data) => data.score,\n    },\n    ...exportedColumns,\n  ];\n};\n\nexport const createBlob = (format) =>\n  ({\n    json: (columns, rows) =>\n      new Blob([asJSON(columns, rows)], {\n        type: \"application/json;charset=utf-8\",\n      }),\n    csv: (columns, rows) =>\n      new Blob([asDSV(columns, rows)], {\n        type: \"text/csv;charset=utf-8\",\n      }),\n    tsv: (columns, rows) =>\n      new Blob([asDSV(columns, rows, \"\\t\", false)], {\n        type: \"text/tab-separated-values;charset=utf-8\",\n      }),\n  })[format];\n\nexport const getFilteredColumnArray = (selectArray, requestArray) => {\n  const arr = selectArray.flatMap((ag) => requestArray.filter((e) => e.aggregation === ag));\n\n  return arr.length > 0 ? arr : [];\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ot-utils/src/downloads.js" },
        "span": [1046, 1061],
        "sourceCode": "import _ from \"lodash\";\n\nconst targetName = {\n  id: \"symbol\",\n  label: \"Symbol\",\n  exportValue: (data) => data.target.approvedSymbol,\n};\n\nconst diseaseName = {\n  id: \"disease\",\n  label: \"Disease\",\n  exportValue: (data) => data.disease.name,\n};\n\nconst asJSON = (columns, rows) => {\n  const rowStrings = rows.map((row) =>\n    columns.reduce((accumulator, newKey) => {\n      if (newKey.exportValue === false) return accumulator;\n\n      const newLabel = _.camelCase(newKey.exportLabel || newKey.label || newKey.id);\n\n      return {\n        ...accumulator,\n        [newLabel]: newKey.exportValue\n          ? newKey.exportValue(row)\n          : _.get(row, newKey.propertyPath || newKey.id, \"\"),\n      };\n    }, {})\n  );\n\n  return JSON.stringify(rowStrings);\n};\n\nconst getHeaderString = ({ columns, quoteString, separator }) =>\n  columns\n    .reduce((headerString, column) => {\n      if (column.exportValue === false) return headerString;\n\n      const newLabel = quoteString(_.camelCase(column.exportLabel || column.label || column.id));\n\n      return [...headerString, newLabel];\n    }, [])\n    .join(separator);\n\nconst asDSV = (columns, rows, separator = \",\", quoteStrings = true) => {\n  const quoteString = (d) => {\n    let result = d;\n    // converts arrays to strings\n    if (Array.isArray(d)) {\n      result = d.join(\",\");\n    }\n    return quoteStrings && typeof result === \"string\" ? `\"${result}\"` : result;\n  };\n\n  const lineSeparator = \"\\n\";\n\n  const headerString = getHeaderString({ columns, quoteString, separator });\n\n  const rowStrings = rows\n    .map((row) =>\n      columns\n        .reduce((rowString, column) => {\n          if (column.exportValue === false) return rowString;\n\n          const newValue = quoteString(\n            column.exportValue\n              ? column.exportValue(row)\n              : _.get(row, column.propertyPath || column.id, \"\")\n          );\n\n          return [...rowString, newValue];\n        }, [])\n        .join(separator)\n    )\n    .join(lineSeparator);\n\n  return [headerString, rowStrings].join(lineSeparator);\n};\n\nexport const getRowsQuerySelector = (entityToGet) =>\n  entityToGet === \"target\" ? \"data.disease.associatedTargets\" : \"data.target.associatedDiseases\";\n\nexport const getExportedColumns = (entityToGet, assocArr, prioArr, pinnedArr) => {\n  const nameColumn = entityToGet === \"target\" ? targetName : diseaseName;\n  let exportedColumns = [];\n\n  if (pinnedArr.length > 0) {\n    const isPinnedObj = [\n      {\n        id: \"isPinned\",\n        exportValue: (data) =>\n          pinnedArr.some((currentValue) => currentValue.id === data[entityToGet].id),\n      },\n    ];\n    exportedColumns = [...exportedColumns, ...isPinnedObj];\n  }\n\n  const sources = assocArr.map(({ id }) => ({\n    id,\n    exportValue: (data) => {\n      const datatypeScore = data.datasourceScores.find(\n        (datasourceScore) => datasourceScore.componentId === id\n      );\n      return datatypeScore ? Number.parseFloat(datatypeScore.score) : \"No data\";\n    },\n  }));\n\n  exportedColumns = [...exportedColumns, ...sources];\n\n  if (entityToGet === \"target\") {\n    const prioritisationExportCols = prioArr.map(({ id }) => ({\n      id,\n      exportValue: (data) => {\n        const prioritisationScore = data.target.prioritisation.items.find(\n          (prioritisationItem) => prioritisationItem.key === id\n        );\n        return prioritisationScore ? Number.parseFloat(prioritisationScore.value) : \"No data\";\n      },\n    }));\n\n    exportedColumns = [...exportedColumns, ...prioritisationExportCols];\n  }\n\n  return [\n    nameColumn,\n    {\n      id: \"globalScore\",\n      label: \"Global Score\",\n      exportValue: (data) => data.score,\n    },\n    ...exportedColumns,\n  ];\n};\n\nexport const getExportedPrioritisationColumns = (arr, pinnedArr, entityToGet) => {\n  let exportedColumns = [];\n\n  if (pinnedArr.length > 0) {\n    const isPinnedObj = [\n      {\n        id: \"isPinned\",\n        exportValue: (data) =>\n          pinnedArr.some((currentValue) => currentValue.id === data[entityToGet].id),\n      },\n    ];\n    exportedColumns = [...exportedColumns, ...isPinnedObj];\n  }\n\n  const prioritisationExportCols = arr.map(({ id }) => ({\n    id,\n    exportValue: (data) => {\n      const prioritisationScore = data.target.prioritisation.items.find(\n        (prioritisationItem) => prioritisationItem.key === id\n      );\n      return prioritisationScore ? Number.parseFloat(prioritisationScore.value) : \"No data\";\n    },\n  }));\n\n  exportedColumns = [...exportedColumns, ...prioritisationExportCols];\n\n  return [\n    targetName,\n    {\n      id: \"globalScore\",\n      label: \"Global Score\",\n      exportValue: (data) => data.score,\n    },\n    ...exportedColumns,\n  ];\n};\n\nexport const createBlob = (format) =>\n  ({\n    json: (columns, rows) =>\n      new Blob([asJSON(columns, rows)], {\n        type: \"application/json;charset=utf-8\",\n      }),\n    csv: (columns, rows) =>\n      new Blob([asDSV(columns, rows)], {\n        type: \"text/csv;charset=utf-8\",\n      }),\n    tsv: (columns, rows) =>\n      new Blob([asDSV(columns, rows, \"\\t\", false)], {\n        type: \"text/tab-separated-values;charset=utf-8\",\n      }),\n  })[format];\n\nexport const getFilteredColumnArray = (selectArray, requestArray) => {\n  const arr = selectArray.flatMap((ag) => requestArray.filter((e) => e.aggregation === ag));\n\n  return arr.length > 0 ? arr : [];\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ot-utils/src/downloads.js" },
        "span": [1893, 1905],
        "sourceCode": "import _ from \"lodash\";\n\nconst targetName = {\n  id: \"symbol\",\n  label: \"Symbol\",\n  exportValue: (data) => data.target.approvedSymbol,\n};\n\nconst diseaseName = {\n  id: \"disease\",\n  label: \"Disease\",\n  exportValue: (data) => data.disease.name,\n};\n\nconst asJSON = (columns, rows) => {\n  const rowStrings = rows.map((row) =>\n    columns.reduce((accumulator, newKey) => {\n      if (newKey.exportValue === false) return accumulator;\n\n      const newLabel = _.camelCase(newKey.exportLabel || newKey.label || newKey.id);\n\n      return {\n        ...accumulator,\n        [newLabel]: newKey.exportValue\n          ? newKey.exportValue(row)\n          : _.get(row, newKey.propertyPath || newKey.id, \"\"),\n      };\n    }, {})\n  );\n\n  return JSON.stringify(rowStrings);\n};\n\nconst getHeaderString = ({ columns, quoteString, separator }) =>\n  columns\n    .reduce((headerString, column) => {\n      if (column.exportValue === false) return headerString;\n\n      const newLabel = quoteString(_.camelCase(column.exportLabel || column.label || column.id));\n\n      return [...headerString, newLabel];\n    }, [])\n    .join(separator);\n\nconst asDSV = (columns, rows, separator = \",\", quoteStrings = true) => {\n  const quoteString = (d) => {\n    let result = d;\n    // converts arrays to strings\n    if (Array.isArray(d)) {\n      result = d.join(\",\");\n    }\n    return quoteStrings && typeof result === \"string\" ? `\"${result}\"` : result;\n  };\n\n  const lineSeparator = \"\\n\";\n\n  const headerString = getHeaderString({ columns, quoteString, separator });\n\n  const rowStrings = rows\n    .map((row) =>\n      columns\n        .reduce((rowString, column) => {\n          if (column.exportValue === false) return rowString;\n\n          const newValue = quoteString(\n            column.exportValue\n              ? column.exportValue(row)\n              : _.get(row, column.propertyPath || column.id, \"\")\n          );\n\n          return [...rowString, newValue];\n        }, [])\n        .join(separator)\n    )\n    .join(lineSeparator);\n\n  return [headerString, rowStrings].join(lineSeparator);\n};\n\nexport const getRowsQuerySelector = (entityToGet) =>\n  entityToGet === \"target\" ? \"data.disease.associatedTargets\" : \"data.target.associatedDiseases\";\n\nexport const getExportedColumns = (entityToGet, assocArr, prioArr, pinnedArr) => {\n  const nameColumn = entityToGet === \"target\" ? targetName : diseaseName;\n  let exportedColumns = [];\n\n  if (pinnedArr.length > 0) {\n    const isPinnedObj = [\n      {\n        id: \"isPinned\",\n        exportValue: (data) =>\n          pinnedArr.some((currentValue) => currentValue.id === data[entityToGet].id),\n      },\n    ];\n    exportedColumns = [...exportedColumns, ...isPinnedObj];\n  }\n\n  const sources = assocArr.map(({ id }) => ({\n    id,\n    exportValue: (data) => {\n      const datatypeScore = data.datasourceScores.find(\n        (datasourceScore) => datasourceScore.componentId === id\n      );\n      return datatypeScore ? Number.parseFloat(datatypeScore.score) : \"No data\";\n    },\n  }));\n\n  exportedColumns = [...exportedColumns, ...sources];\n\n  if (entityToGet === \"target\") {\n    const prioritisationExportCols = prioArr.map(({ id }) => ({\n      id,\n      exportValue: (data) => {\n        const prioritisationScore = data.target.prioritisation.items.find(\n          (prioritisationItem) => prioritisationItem.key === id\n        );\n        return prioritisationScore ? Number.parseFloat(prioritisationScore.value) : \"No data\";\n      },\n    }));\n\n    exportedColumns = [...exportedColumns, ...prioritisationExportCols];\n  }\n\n  return [\n    nameColumn,\n    {\n      id: \"globalScore\",\n      label: \"Global Score\",\n      exportValue: (data) => data.score,\n    },\n    ...exportedColumns,\n  ];\n};\n\nexport const getExportedPrioritisationColumns = (arr, pinnedArr, entityToGet) => {\n  let exportedColumns = [];\n\n  if (pinnedArr.length > 0) {\n    const isPinnedObj = [\n      {\n        id: \"isPinned\",\n        exportValue: (data) =>\n          pinnedArr.some((currentValue) => currentValue.id === data[entityToGet].id),\n      },\n    ];\n    exportedColumns = [...exportedColumns, ...isPinnedObj];\n  }\n\n  const prioritisationExportCols = arr.map(({ id }) => ({\n    id,\n    exportValue: (data) => {\n      const prioritisationScore = data.target.prioritisation.items.find(\n        (prioritisationItem) => prioritisationItem.key === id\n      );\n      return prioritisationScore ? Number.parseFloat(prioritisationScore.value) : \"No data\";\n    },\n  }));\n\n  exportedColumns = [...exportedColumns, ...prioritisationExportCols];\n\n  return [\n    targetName,\n    {\n      id: \"globalScore\",\n      label: \"Global Score\",\n      exportValue: (data) => data.score,\n    },\n    ...exportedColumns,\n  ];\n};\n\nexport const createBlob = (format) =>\n  ({\n    json: (columns, rows) =>\n      new Blob([asJSON(columns, rows)], {\n        type: \"application/json;charset=utf-8\",\n      }),\n    csv: (columns, rows) =>\n      new Blob([asDSV(columns, rows)], {\n        type: \"text/csv;charset=utf-8\",\n      }),\n    tsv: (columns, rows) =>\n      new Blob([asDSV(columns, rows, \"\\t\", false)], {\n        type: \"text/tab-separated-values;charset=utf-8\",\n      }),\n  })[format];\n\nexport const getFilteredColumnArray = (selectArray, requestArray) => {\n  const arr = selectArray.flatMap((ag) => requestArray.filter((e) => e.aggregation === ag));\n\n  return arr.length > 0 ? arr : [];\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ot-utils/src/urls.ts" },
        "span": [1057, 1258],
        "sourceCode": "import { getConfig } from \"@ot/config\";\n\nconst config = getConfig();\n\ninterface RequestOptions {\n  method: string;\n  headers: Record<string, string>;\n  body: string;\n}\n\ninterface SearchPostResult {\n  baseUrl: string;\n  formBody: string;\n  requestOptions?: RequestOptions;\n}\n\ninterface PublicationSummaryParams {\n  pmcId: string;\n  symbol: string;\n  name: string;\n}\n\nexport function epmcUrl(id: string): string {\n  return `https://europepmc.org/article/MED/${id}`;\n}\n\nexport function otgStudyUrl(id: string): string {\n  return `${config.geneticsPortalUrl}/study/${id}`;\n}\n\nexport function otgVariantUrl(id: string): string {\n  return `${config.geneticsPortalUrl}/variant/${id}`;\n}\n\nexport function europePmcLiteratureQuery(ids: string[]): string {\n  const baseUrl = `https://www.ebi.ac.uk/europepmc/webservices/rest/search?&format=json&resultType=core&pageSize=${ids.length}&query=ext_id:`;\n  return encodeURI(baseUrl + ids.join(\" OR ext_id:\"));\n}\n\nexport const encodeParams = (params: Record<string, string>): string => {\n  const formBody: string[] = [];\n  Object.keys(params).forEach((key) => {\n    const encodedKey = encodeURIComponent(key);\n    const encodedValue = encodeURIComponent(params[key]);\n    formBody.push(`${encodedKey}=${encodedValue}`);\n  });\n  return formBody.join(\"&\");\n};\n\nexport function europePmcSearchPOSTQuery(ids: string[]): SearchPostResult {\n  const baseUrl = \"https://www.ebi.ac.uk/europepmc/webservices/rest/searchPOST\";\n  const query = ids.join(\" OR ext_id:\");\n  const bodyOptions = {\n    resultType: \"core\",\n    format: \"json\",\n    pageSize: \"1000\",\n    query: `ext_id:${query}`,\n    sort: \"P_PDATE_D desc\",\n  };\n  const formBody = encodeParams(bodyOptions);\n  return { baseUrl, formBody };\n}\n\nexport function europePmcBiblioSearchPOSTQuery(ids: string[], size = 25): SearchPostResult {\n  const baseUrl = \"https://www.ebi.ac.uk/europepmc/webservices/rest/searchPOST\";\n  const query = ids.join(\" OR ext_id:\");\n  const bodyOptions = {\n    resultType: \"core\",\n    format: \"json\",\n    pageSize: String(size),\n    query: `ext_id:${query}`,\n  };\n  const formBody = encodeParams(bodyOptions);\n  const requestOptions: RequestOptions = {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\",\n    },\n    body: formBody,\n  };\n  return { baseUrl, formBody, requestOptions };\n}\n\nfunction innUrl() {\n  return \"https://www.who.int/publications/m/item/inn-pl-126\";\n}\n\nfunction emaUrl() {\n  return \"https://www.ema.europa.eu/en/medicines\";\n}\n\nfunction usanUrl(id) {\n  return `https://searchusan.ama-assn.org/finder/usan/search/${id}/relevant/1`;\n}\n\nfunction clinicalTrialsUrl(id: string): string {\n  return `https://www.clinicaltrials.gov/study/${id}`;\n}\n\nfunction fdaUrl(id: string): string {\n  return `https://api.fda.gov/drug/label.json?search=set_id:${id}`;\n}\n\nfunction atcUrl(id: string): string {\n  return `http://www.whocc.no/atc_ddd_index/?code=${id}`;\n}\n\nfunction dailyMedUrl(id: string): string {\n  return `http://dailymed.nlm.nih.gov/dailymed/drugInfo.cfm?setid=${id}`;\n}\n\nexport const referenceUrls: Record<string, (id: string) => string> = {\n  ClinicalTrials: clinicalTrialsUrl,\n  FDA: fdaUrl,\n  ATC: atcUrl,\n  DailyMed: dailyMedUrl,\n  INN: innUrl,\n  EMA: emaUrl,\n  USAN: usanUrl,\n};\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/security/noDangerouslySetInnerHtml",
      "severity": "error",
      "description": "Avoid passing content using the dangerouslySetInnerHTML prop.",
      "message": [
        { "elements": [], "content": "Avoid passing content using the " },
        { "elements": ["Emphasis"], "content": "dangerouslySetInnerHTML" },
        { "elements": [], "content": " prop." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "warn",
              [
                {
                  "elements": [],
                  "content": "Setting content using code can expose users to cross-site scripting (XSS) attacks"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Bibliography/BibliographyHtmlText.jsx" },
        "span": [124, 147],
        "sourceCode": "import { Typography } from \"@mui/material\";\n\nfunction BibliographyHtmlText({ text }) {\n  return <Typography variant=\"body1\" dangerouslySetInnerHTML={{ __html: text }} />;\n}\n\nexport default BibliographyHtmlText;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/security/noDangerouslySetInnerHtml",
      "severity": "error",
      "description": "Avoid passing content using the dangerouslySetInnerHTML prop.",
      "message": [
        { "elements": [], "content": "Avoid passing content using the " },
        { "elements": ["Emphasis"], "content": "dangerouslySetInnerHTML" },
        { "elements": [], "content": " prop." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "warn",
              [
                {
                  "elements": [],
                  "content": "Setting content using code can expose users to cross-site scripting (XSS) attacks"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Bibliography/SimplePublication.jsx" },
        "span": [976, 999],
        "sourceCode": "import { Box, Typography } from \"@mui/material\";\n\nimport { Link, LongText } from \"ui\";\n\nconst pmUrl = \"https://europepmc.org/\";\n// const pmTitleUrl = 'abstract/med/';\n\n/**\n * This renders a publication block in the bibliography details.\n * Props:\n *  - pmId\n *  - title\n *  - titleHtml\n *  - authors\n *  - source\n *  - patentDetails\n *  - journal: {\n *      title\n *      date\n *      ref\n *    }\n *  - variant: \"regular\" (default) or \"small\" (has smaller titles)\n */\n\nfunction SimplePublication({\n  pmId,\n  title,\n  titleHtml,\n  authors,\n  journal,\n  variant = \"regular\",\n  source,\n  patentDetails,\n}) {\n  const isSourcePAT = source === \"PAT\";\n  const sourceScope = isSourcePAT ? \"abstract/pat/\" : \"abstract/med/\";\n  const pubURL = pmUrl + sourceScope + pmId;\n\n  return (\n    <>\n      {/* paper title */}\n      <Typography variant={variant === \"small\" ? \"subtitle2\" : \"subtitle1\"}>\n        <Link external to={pubURL}>\n          {titleHtml ? (\n            <span\n              dangerouslySetInnerHTML={{ __html: titleHtml }}\n              style={{ whiteSpace: \"normal\" }}\n            />\n          ) : (\n            title\n          )}\n        </Link>\n      </Typography>\n\n      {/* paper data */}\n      {/* authors */}\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <LongText lineLimit={1} variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n          {authors\n            .map((author) => author.lastName + (author.initials ? ` ${author.initials}` : \"\"))\n            .join(\", \")}\n        </LongText>\n      </Box>\n\n      {isSourcePAT ? (\n        <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n          {/* journal, year, reference */}\n          {patentDetails.typeDescription}\n          {\" - \"}\n          <span>{patentDetails.country}</span>\n        </Typography>\n      ) : (\n        <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n          {/* journal, year, reference */}\n          {journal.title}{\" \"}\n          <span>\n            <b>{journal?.date?.substring(0, 4)}</b>\n          </span>{\" \"}\n          <span>{journal.ref.volume}</span>\n          <span>({journal.ref.issue})</span>\n          <span>:{journal.ref.pgn}</span>\n        </Typography>\n      )}\n    </>\n  );\n}\n\nexport default SimplePublication;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: BODY_QUERY",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: BODY_QUERY"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1546, 1556],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1007, 1017],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include them or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: client" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [972, 978],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: id",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: id" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1527, 1529],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [988, 990],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include them or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: startYear",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: startYear"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1045, 1054],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: startMonth",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: startMonth"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1064, 1074],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: entity",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: entity" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1580, 1586],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1191, 1197],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include them or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: literatureDispatch",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: literatureDispatch"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1603, 1621],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: endYear",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: endYear" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1084, 1091],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: category",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: category"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1027, 1035],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: endMonth",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: endMonth"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1101, 1109],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/Body.jsx" },
        "span": [855, 864],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\nimport Category from \"./Category\";\nimport CountInfo from \"./CountInfo\";\nimport { DateFilter } from \"./DateFilter\";\nimport Description from \"./Description\";\nimport Entities from \"./Entities\";\nimport { LiteratureProvider, useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport PublicationsList from \"./PublicationsList\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nfunction LiteratureList({ id, name, entity, BODY_QUERY, definition }) {\n  const [requestObj, setRequestObj] = useState({});\n  const literature = useLiterature();\n  const { category, startYear, startMonth, endYear, endMonth } = literature;\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  useEffect(() => {\n    async function startRequest() {\n      const initRequest = await fetchSimilarEntities({\n        client,\n        id,\n        query: BODY_QUERY,\n        category,\n        startYear,\n        startMonth,\n        endYear,\n        endMonth,\n      });\n      setRequestObj(initRequest);\n      const data = initRequest.data[entity];\n      const update = {\n        entities: data.similarEntities,\n        litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n        litsCount: data.literatureOcurrences?.filteredCount,\n        earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n        cursor: data.literatureOcurrences?.cursor,\n        id,\n        query: BODY_QUERY,\n        globalEntity: entity,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    }\n    startRequest();\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={requestObj}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          <Box display=\"flex\" sx={{ justifyContent: \"space-between\" }}>\n            <Box display=\"flex\" sx={{ flexDirection: \"column\" }}>\n              <Category />\n              <DateFilter />\n            </Box>\n            <CountInfo />\n          </Box>\n          <Entities id={id} name={name} />\n          <PublicationsList hideSearch />\n        </>\n      )}\n    />\n  );\n}\n\nfunction Body({ definition, name, id, entity, BODY_QUERY }) {\n  return (\n    <LiteratureProvider>\n      <LiteratureList\n        id={id}\n        name={name}\n        entity={entity}\n        BODY_QUERY={BODY_QUERY}\n        definition={definition}\n      />\n    </LiteratureProvider>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Bibliography/Body.jsx" },
        "span": [2825, 2835],
        "sourceCode": "import { Autocomplete, Box, Button, Chip, Grid, TextField, Typography } from \"@mui/material\";\nimport { withStyles } from \"@mui/styles\";\nimport { Component } from \"react\";\nimport { v1 } from \"uuid\";\n// TODO: note this component is not actually used.\n// Only SimplePublication is used in evidence bibliography\n\nimport { SectionItem } from \"ui\";\nimport { getAggregationsData, getPublicationsData } from \"./Api\";\nimport Description from \"./Description\";\nimport Publication from \"./Publication\";\n\nconst aggtype = [\n  { value: \"top_chunks_significant_terms\", label: \"Concepts\" },\n  { value: \"genes\", label: \"Genes\" },\n  { value: \"diseases\", label: \"Diseases\" },\n  { value: \"drugs\", label: \"Drugs\" },\n  { value: \"journal_abbr_significant_terms\", label: \"Journal\" },\n  { value: \"authors_significant_terms\", label: \"Authors\" },\n  // the following are also valid aggregation types in Link but we currently don't use them:\n  // {value: 'phenotypes', label: 'Phenotypes'}, // phenotypes don't return any hits at the moment\n  // {value: 'pub_date_histogram', label: 'publication date'}\n];\n\nconst styles = (theme) => ({\n  aggtypeAutocomplete: {\n    width: \"15rem\",\n    \"& .MuiFormControl-root\": { marginTop: 0 },\n  },\n  icon: {\n    width: \"50px\",\n    height: \"50px\",\n    fill: \"#5a5f5f\",\n  },\n  iconNoData: {\n    fill: \"#e2dfdf\",\n  },\n  chip: {\n    margin: theme.spacing(0.25),\n  },\n  filterCategoryContainer: {\n    display: \"flex\",\n    \"& p\": {\n      margin: \".2rem 1rem 0 0\",\n    },\n  },\n  noTagsSelected: {\n    margin: \".375rem 0\",\n  },\n  resultCount: {\n    marginBottom: \"2rem\",\n  },\n});\n\nclass Section extends Component {\n  constructor(props) {\n    super(props);\n    const { id, label } = props;\n    const searchTerm = { key: id, label };\n    this.state = {\n      bibliographyCount: 0,\n      isLoading: true,\n      hasData: false,\n      hasError: false,\n      aggregations: {},\n      selectedAggregation: aggtype[0],\n      hits: [], // the list of papers\n      selected: [searchTerm], // the selected chips (first item is the page gene or disease)\n    };\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    this.getData();\n  }\n\n  componentDidUpdate(_prevProps, prevState) {\n    // If a chip has been added or removed, fetch new data\n    const { selected } = this.state;\n    if (selected.length !== prevState.selected.length) {\n      this.getData();\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  // Handler for drop down menu\n  aggtypeFilterHandler = (_e, selection) => {\n    this.setState({ selectedAggregation: selection });\n  };\n\n  // Parse the aggregation data based on defined aggtypes\n  // and filter out all entries that are already selected\n  filterAggregations = (aggs) => {\n    const { selected } = this.state;\n    return aggtype.reduce((newaggs, agg) => {\n      const newAggregationObject = { ...newaggs };\n      newAggregationObject[agg.value] = {\n        buckets: aggs[agg.value].buckets.filter(\n          (b) =>\n            selected.filter((a) => {\n              const selectedNewAggregationObject = a;\n              selectedNewAggregationObject.label = a.label || a.key;\n              return (\n                selectedNewAggregationObject.key.toString().toLowerCase() ===\n                  b.key.toString().toLowerCase() ||\n                selectedNewAggregationObject.label.toString().toLowerCase() ===\n                  b.key.toString().toLowerCase()\n              );\n            }).length === 0\n        ),\n      };\n      return newAggregationObject;\n    }, {});\n  };\n\n  // Get the data for the chips\n  getAggregations = () => {\n    const { selected } = this.state;\n    getAggregationsData(selected).then(\n      (resp) => {\n        if (this.mounted) {\n          this.setState({\n            bibliographyCount: resp.hits.total,\n            hasData: resp.hits.total > 0,\n            aggregations: this.filterAggregations(resp.aggregations),\n          });\n        }\n      },\n      () => {\n        if (this.mounted) {\n          this.setState({\n            aggregations: {},\n            hasError: true,\n          });\n        }\n      }\n    );\n  };\n\n  // Get the data for the publications\n  getPublications = (append) => {\n    this.setState({ isLoading: true });\n    const { hits } = this.state;\n    const last = hits[hits.length - 1];\n    const after = append ? last.sort[0] : undefined;\n    const afterId = append ? last._id : undefined;\n    const { selected } = this.state;\n\n    getPublicationsData(selected, after, afterId).then(\n      (resp) => {\n        const { state: stateHits } = this.state;\n        // if loading more data (after & afterId) append that, if not just reset hits\n        const newHits = after && afterId ? stateHits.concat(resp.hits.hits) : resp.hits.hits;\n        if (this.mounted) {\n          this.setState({ hits: newHits, isLoading: false });\n        }\n      },\n      () => {\n        if (this.mounted) {\n          this.setState({ hits: [], hasError: true, isLoading: false });\n        }\n      }\n    );\n  };\n\n  // Handler for when a chip is deselected\n  deselectChip = (index) => {\n    const { selected } = this.state;\n    if (index < selected.length) {\n      this.setState({ selected: selected.filter((_sel, i) => i !== index) });\n    }\n  };\n\n  // Handler for when a chip is selected\n  selectChip = (chip) => {\n    const { selected } = this.state;\n    const newSelected = selected.concat([chip]);\n    this.setState({ selected: newSelected });\n  };\n\n  // We make 2 calls: one for chips and one for papers\n  // This is because aggregations can be computationally demanding (e.g. for neoplasm) and fail.\n  // By splitting the call we always have some papers to show\n  getData = () => {\n    // get aggregation data for chips\n    this.getAggregations();\n    // get papers\n    this.getPublications();\n  };\n\n  render() {\n    const {\n      bibliographyCount,\n      aggregations,\n      selectedAggregation,\n      hits,\n      selected,\n      isLoading,\n      hasError,\n      hasData,\n    } = this.state;\n    const { classes, definition, label } = this.props;\n\n    return (\n      <SectionItem\n        definition={definition}\n        request={{ loading: isLoading, error: hasError, data: hasData }}\n        renderDescription={() => <Description label={label} />}\n        renderBody={() => (\n          <Grid\n            container\n            direction=\"column\"\n            justifyContent=\"flex-start\"\n            alignItems=\"stretch\"\n            spacing={2}\n          >\n            <Grid item xs={12}>\n              <Box className={classes.filterCategoryContainer}>\n                <Typography>Tag category:</Typography>\n                {/* Dropdown menu */}\n                <Autocomplete\n                  classes={{ root: classes.aggtypeAutocomplete }}\n                  disableClearable\n                  getOptionLabel={(option) => option.label}\n                  getOptionSelected={(option) => option.value}\n                  onChange={this.aggtypeFilterHandler}\n                  options={aggtype}\n                  renderInput={(params) => (\n                    // eslint-disable-next-line\n                    <TextField {...params} margin=\"normal\" />\n                  )}\n                  value={selectedAggregation}\n                />\n              </Box>\n              {/* Chips */}\n              <Box>\n                {selected.length > 1 ? (\n                  selected.map((sel, i) =>\n                    i > 0 ? (\n                      <Chip\n                        key={v1()}\n                        color=\"primary\"\n                        label={sel.label || sel.key}\n                        onDelete={() => this.deselectChip(i)}\n                        className={classes.chip}\n                      />\n                    ) : null\n                  )\n                ) : (\n                  <Typography className={classes.noTagsSelected}>\n                    No tags selected, please select from below\n                  </Typography>\n                )}\n              </Box>\n              <Box>\n                {aggregations[selectedAggregation.value]\n                  ? aggregations[selectedAggregation.value].buckets.map((agg, _i) => (\n                      <Chip\n                        key={v1()}\n                        variant=\"outlined\"\n                        label={agg.label || agg.key}\n                        onClick={() => this.selectChip(agg)}\n                        className={classes.chip}\n                      />\n                    ))\n                  : null}\n              </Box>\n            </Grid>\n\n            <Grid item xs={12}>\n              {/* Total result */}\n              <Typography variant=\"body2\" className={classes.resultCount}>\n                Showing {Math.min(hits.length, bibliographyCount)} of {bibliographyCount} results\n              </Typography>\n\n              {/* Publications */}\n              <Grid\n                container\n                direction=\"column\"\n                justifyContent=\"flex-start\"\n                alignItems=\"stretch\"\n                spacing={2}\n              >\n                {hits.map((hitItem, _i) => (\n                  <Grid item xs={12} key={hitItem._source.pub_id}>\n                    <Publication\n                      pmId={hitItem._source.pub_id}\n                      title={hitItem._source.title}\n                      authors={\n                        (hitItem._source.authors || []).map((a) => ({\n                          lastName: a.LastName,\n                          initials: a.Initials,\n                        })) || []\n                      }\n                      journal={{\n                        title: hitItem._source.journal.title,\n                        date: hitItem._source.pub_date,\n                        ref: hitItem._source.journal_reference,\n                      }}\n                      hasAbstract={hitItem._source.abstract}\n                    />\n                  </Grid>\n                ))}\n              </Grid>\n            </Grid>\n\n            {/* Load more, if any */}\n            {hits.length < bibliographyCount ? (\n              <Grid item xs={12}>\n                <Button\n                  variant=\"contained\"\n                  size=\"medium\"\n                  color=\"primary\"\n                  disableElevation\n                  onClick={() => {\n                    this.getPublications(true);\n                  }}\n                >\n                  Load more papers\n                </Button>\n              </Grid>\n            ) : null}\n          </Grid>\n        )}\n      />\n    );\n  }\n}\n\nexport default withStyles(styles)(Section);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: getDateFromYear",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: getDateFromYear"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1854, 1869],
              "sourceCode": "import { FormControl, FormGroup, InputLabel, Slider } from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useApolloClient } from \"ui\";\nimport { useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nconst OTSlider = styled(Slider)({\n  root: {\n    padding: \"0 10px !important\",\n  },\n  mark: {\n    backgroundColor: \"#b8b8b8\",\n    width: 10,\n    height: 1,\n    marginLeft: -4,\n  },\n  valueLabel: {\n    zIndex: \"9999\",\n  },\n});\n\nconst DateIndicator = styled(\"span\")({\n  minWidth: 65,\n  maxWidth: 80,\n});\n\nconst monthsBtwnDates = (startDate, endDate) =>\n  Math.max(\n    (endDate.getFullYear() - startDate.getFullYear()) * 12 +\n      (endDate.getMonth() - startDate.getMonth()),\n    0\n  );\n\nexport function DateFilter() {\n  const [filterDate, setFilterDate] = useState([0, 0]);\n  const [numberOfMonths, setNumberOfMonths] = useState(0);\n  const [pubYear, setPubYear] = useState(0);\n  const literature = useLiterature();\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  const {\n    query,\n    id,\n    category,\n    earliestPubYear,\n    selectedEntities,\n    globalEntity,\n    litsIds,\n    pageSize,\n    litsCount,\n    loadingEntities,\n  } = literature;\n\n  function getDateFromYear(year) {\n    return new Date(year, 0, 1, 1, 1, 1, 1);\n  }\n\n  const sumMonthsSinceYear = (year) => (value) => {\n    const from = getDateFromYear(year);\n    const date = new Date(from.setMonth(from.getMonth() + value));\n    return date;\n  };\n\n  const selectedDate = sumMonthsSinceYear(earliestPubYear);\n  const oldSelectedDate = sumMonthsSinceYear(pubYear);\n\n  useEffect(() => {\n    // the publication year has changed\n    if (earliestPubYear && earliestPubYear !== pubYear) {\n      const earliestDate = getDateFromYear(earliestPubYear);\n      const limit = monthsBtwnDates(earliestDate, new Date());\n      const lowerLimit = getLowerLimit(earliestDate);\n      const higherLimit = getHigherLimit(earliestDate, limit);\n      setFilterDate([lowerLimit, higherLimit]);\n      setNumberOfMonths(limit);\n      setPubYear(earliestPubYear);\n    } else {\n      setPubYear(0);\n      setNumberOfMonths(0);\n      setFilterDate([0, 0]);\n    }\n  }, [earliestPubYear]);\n\n  function getHigherLimit(earliestDate, limit) {\n    const oldHigherDate = oldSelectedDate(filterDate[1]);\n    const newHighFilter = monthsBtwnDates(earliestDate, oldHigherDate);\n    const higherLimit =\n      filterDate[1] > 0 && newHighFilter > 0 && newHighFilter < limit ? newHighFilter : limit;\n    return higherLimit;\n  }\n\n  function getLowerLimit(earliestDate) {\n    if (filterDate[0] === 0) return 0;\n    const oldLowerDate = oldSelectedDate(filterDate[0]);\n    const newLowerFilter = monthsBtwnDates(earliestDate, oldLowerDate);\n    const lowerLimit = newLowerFilter > 0 ? newLowerFilter : 0;\n    return lowerLimit;\n  }\n\n  const handleChange = async (values) => {\n    literatureDispatch({ type: \"loadingEntities\", value: true });\n    const request = await fetchSimilarEntities({\n      client,\n      query,\n      id,\n      category,\n      entities: selectedEntities,\n      cursor: null,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    });\n    const data = request.data[globalEntity];\n    const update = {\n      id,\n      cursor: data.literatureOcurrences?.cursor,\n      query,\n      entities: data.similarEntities,\n      loadingEntities: false,\n      category,\n      litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n      litsCount: data.literatureOcurrences?.filteredCount,\n      earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n      globalEntity,\n      selectedEntities,\n      page: 0,\n      pageSize,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    };\n    literatureDispatch({ type: \"stateUpdate\", value: update });\n  };\n\n  const valueLabelFormat = (value) => {\n    if (earliestPubYear) {\n      const labelDate = selectedDate(value);\n      return `${labelDate.getFullYear()}-${labelDate.getMonth() + 1}`;\n    }\n    return \"YYYY-MM\";\n  };\n\n  const handleDateRangeChange = (_event, value, _activeThumb) => {\n    setFilterDate(value);\n  };\n\n  const handleDateRangeChangeCommitted = (_event, value) => {\n    if (Array.isArray(value)) {\n      const startDate = selectedDate(value[0]);\n      const endDate = selectedDate(value[1]);\n      handleChange({\n        startYear: startDate.getFullYear(),\n        startMonth: startDate.getMonth() + 1,\n        endYear: endDate.getFullYear(),\n        endMonth: endDate.getMonth() + 1,\n      });\n    }\n  };\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        marginTop: 20,\n        marginBottom: 20,\n      }}\n    >\n      <InputLabel id=\"date-filter-demo\">Date Filter:</InputLabel>\n      <FormGroup>\n        <FormControl\n          style={{\n            marginLeft: 20,\n            flex: 1,\n            display: \"flex\",\n            flexDirection: \"row\",\n            gap: 12,\n            alignItems: \"center\",\n          }}\n        >\n          <DateIndicator>{valueLabelFormat(filterDate[0])}</DateIndicator>\n          <OTSlider\n            size=\"small\"\n            style={{ width: 275 }}\n            value={filterDate}\n            valueLabelDisplay=\"auto\"\n            onChange={handleDateRangeChange}\n            onChangeCommitted={handleDateRangeChangeCommitted}\n            getAriaLabel={() => \"date-range-slider\"}\n            max={numberOfMonths}\n            valueLabelFormat={valueLabelFormat}\n          />\n          <DateIndicator>{valueLabelFormat(filterDate[1])}</DateIndicator>\n        </FormControl>\n      </FormGroup>\n    </div>\n  );\n}\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/DateFilter.jsx" },
        "span": [1711, 1720],
        "sourceCode": "import { FormControl, FormGroup, InputLabel, Slider } from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useApolloClient } from \"ui\";\nimport { useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nconst OTSlider = styled(Slider)({\n  root: {\n    padding: \"0 10px !important\",\n  },\n  mark: {\n    backgroundColor: \"#b8b8b8\",\n    width: 10,\n    height: 1,\n    marginLeft: -4,\n  },\n  valueLabel: {\n    zIndex: \"9999\",\n  },\n});\n\nconst DateIndicator = styled(\"span\")({\n  minWidth: 65,\n  maxWidth: 80,\n});\n\nconst monthsBtwnDates = (startDate, endDate) =>\n  Math.max(\n    (endDate.getFullYear() - startDate.getFullYear()) * 12 +\n      (endDate.getMonth() - startDate.getMonth()),\n    0\n  );\n\nexport function DateFilter() {\n  const [filterDate, setFilterDate] = useState([0, 0]);\n  const [numberOfMonths, setNumberOfMonths] = useState(0);\n  const [pubYear, setPubYear] = useState(0);\n  const literature = useLiterature();\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  const {\n    query,\n    id,\n    category,\n    earliestPubYear,\n    selectedEntities,\n    globalEntity,\n    litsIds,\n    pageSize,\n    litsCount,\n    loadingEntities,\n  } = literature;\n\n  function getDateFromYear(year) {\n    return new Date(year, 0, 1, 1, 1, 1, 1);\n  }\n\n  const sumMonthsSinceYear = (year) => (value) => {\n    const from = getDateFromYear(year);\n    const date = new Date(from.setMonth(from.getMonth() + value));\n    return date;\n  };\n\n  const selectedDate = sumMonthsSinceYear(earliestPubYear);\n  const oldSelectedDate = sumMonthsSinceYear(pubYear);\n\n  useEffect(() => {\n    // the publication year has changed\n    if (earliestPubYear && earliestPubYear !== pubYear) {\n      const earliestDate = getDateFromYear(earliestPubYear);\n      const limit = monthsBtwnDates(earliestDate, new Date());\n      const lowerLimit = getLowerLimit(earliestDate);\n      const higherLimit = getHigherLimit(earliestDate, limit);\n      setFilterDate([lowerLimit, higherLimit]);\n      setNumberOfMonths(limit);\n      setPubYear(earliestPubYear);\n    } else {\n      setPubYear(0);\n      setNumberOfMonths(0);\n      setFilterDate([0, 0]);\n    }\n  }, [earliestPubYear]);\n\n  function getHigherLimit(earliestDate, limit) {\n    const oldHigherDate = oldSelectedDate(filterDate[1]);\n    const newHighFilter = monthsBtwnDates(earliestDate, oldHigherDate);\n    const higherLimit =\n      filterDate[1] > 0 && newHighFilter > 0 && newHighFilter < limit ? newHighFilter : limit;\n    return higherLimit;\n  }\n\n  function getLowerLimit(earliestDate) {\n    if (filterDate[0] === 0) return 0;\n    const oldLowerDate = oldSelectedDate(filterDate[0]);\n    const newLowerFilter = monthsBtwnDates(earliestDate, oldLowerDate);\n    const lowerLimit = newLowerFilter > 0 ? newLowerFilter : 0;\n    return lowerLimit;\n  }\n\n  const handleChange = async (values) => {\n    literatureDispatch({ type: \"loadingEntities\", value: true });\n    const request = await fetchSimilarEntities({\n      client,\n      query,\n      id,\n      category,\n      entities: selectedEntities,\n      cursor: null,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    });\n    const data = request.data[globalEntity];\n    const update = {\n      id,\n      cursor: data.literatureOcurrences?.cursor,\n      query,\n      entities: data.similarEntities,\n      loadingEntities: false,\n      category,\n      litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n      litsCount: data.literatureOcurrences?.filteredCount,\n      earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n      globalEntity,\n      selectedEntities,\n      page: 0,\n      pageSize,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    };\n    literatureDispatch({ type: \"stateUpdate\", value: update });\n  };\n\n  const valueLabelFormat = (value) => {\n    if (earliestPubYear) {\n      const labelDate = selectedDate(value);\n      return `${labelDate.getFullYear()}-${labelDate.getMonth() + 1}`;\n    }\n    return \"YYYY-MM\";\n  };\n\n  const handleDateRangeChange = (_event, value, _activeThumb) => {\n    setFilterDate(value);\n  };\n\n  const handleDateRangeChangeCommitted = (_event, value) => {\n    if (Array.isArray(value)) {\n      const startDate = selectedDate(value[0]);\n      const endDate = selectedDate(value[1]);\n      handleChange({\n        startYear: startDate.getFullYear(),\n        startMonth: startDate.getMonth() + 1,\n        endYear: endDate.getFullYear(),\n        endMonth: endDate.getMonth() + 1,\n      });\n    }\n  };\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        marginTop: 20,\n        marginBottom: 20,\n      }}\n    >\n      <InputLabel id=\"date-filter-demo\">Date Filter:</InputLabel>\n      <FormGroup>\n        <FormControl\n          style={{\n            marginLeft: 20,\n            flex: 1,\n            display: \"flex\",\n            flexDirection: \"row\",\n            gap: 12,\n            alignItems: \"center\",\n          }}\n        >\n          <DateIndicator>{valueLabelFormat(filterDate[0])}</DateIndicator>\n          <OTSlider\n            size=\"small\"\n            style={{ width: 275 }}\n            value={filterDate}\n            valueLabelDisplay=\"auto\"\n            onChange={handleDateRangeChange}\n            onChangeCommitted={handleDateRangeChangeCommitted}\n            getAriaLabel={() => \"date-range-slider\"}\n            max={numberOfMonths}\n            valueLabelFormat={valueLabelFormat}\n          />\n          <DateIndicator>{valueLabelFormat(filterDate[1])}</DateIndicator>\n        </FormControl>\n      </FormGroup>\n    </div>\n  );\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: pubYear",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: pubYear" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1816, 1823],
              "sourceCode": "import { FormControl, FormGroup, InputLabel, Slider } from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useApolloClient } from \"ui\";\nimport { useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nconst OTSlider = styled(Slider)({\n  root: {\n    padding: \"0 10px !important\",\n  },\n  mark: {\n    backgroundColor: \"#b8b8b8\",\n    width: 10,\n    height: 1,\n    marginLeft: -4,\n  },\n  valueLabel: {\n    zIndex: \"9999\",\n  },\n});\n\nconst DateIndicator = styled(\"span\")({\n  minWidth: 65,\n  maxWidth: 80,\n});\n\nconst monthsBtwnDates = (startDate, endDate) =>\n  Math.max(\n    (endDate.getFullYear() - startDate.getFullYear()) * 12 +\n      (endDate.getMonth() - startDate.getMonth()),\n    0\n  );\n\nexport function DateFilter() {\n  const [filterDate, setFilterDate] = useState([0, 0]);\n  const [numberOfMonths, setNumberOfMonths] = useState(0);\n  const [pubYear, setPubYear] = useState(0);\n  const literature = useLiterature();\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  const {\n    query,\n    id,\n    category,\n    earliestPubYear,\n    selectedEntities,\n    globalEntity,\n    litsIds,\n    pageSize,\n    litsCount,\n    loadingEntities,\n  } = literature;\n\n  function getDateFromYear(year) {\n    return new Date(year, 0, 1, 1, 1, 1, 1);\n  }\n\n  const sumMonthsSinceYear = (year) => (value) => {\n    const from = getDateFromYear(year);\n    const date = new Date(from.setMonth(from.getMonth() + value));\n    return date;\n  };\n\n  const selectedDate = sumMonthsSinceYear(earliestPubYear);\n  const oldSelectedDate = sumMonthsSinceYear(pubYear);\n\n  useEffect(() => {\n    // the publication year has changed\n    if (earliestPubYear && earliestPubYear !== pubYear) {\n      const earliestDate = getDateFromYear(earliestPubYear);\n      const limit = monthsBtwnDates(earliestDate, new Date());\n      const lowerLimit = getLowerLimit(earliestDate);\n      const higherLimit = getHigherLimit(earliestDate, limit);\n      setFilterDate([lowerLimit, higherLimit]);\n      setNumberOfMonths(limit);\n      setPubYear(earliestPubYear);\n    } else {\n      setPubYear(0);\n      setNumberOfMonths(0);\n      setFilterDate([0, 0]);\n    }\n  }, [earliestPubYear]);\n\n  function getHigherLimit(earliestDate, limit) {\n    const oldHigherDate = oldSelectedDate(filterDate[1]);\n    const newHighFilter = monthsBtwnDates(earliestDate, oldHigherDate);\n    const higherLimit =\n      filterDate[1] > 0 && newHighFilter > 0 && newHighFilter < limit ? newHighFilter : limit;\n    return higherLimit;\n  }\n\n  function getLowerLimit(earliestDate) {\n    if (filterDate[0] === 0) return 0;\n    const oldLowerDate = oldSelectedDate(filterDate[0]);\n    const newLowerFilter = monthsBtwnDates(earliestDate, oldLowerDate);\n    const lowerLimit = newLowerFilter > 0 ? newLowerFilter : 0;\n    return lowerLimit;\n  }\n\n  const handleChange = async (values) => {\n    literatureDispatch({ type: \"loadingEntities\", value: true });\n    const request = await fetchSimilarEntities({\n      client,\n      query,\n      id,\n      category,\n      entities: selectedEntities,\n      cursor: null,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    });\n    const data = request.data[globalEntity];\n    const update = {\n      id,\n      cursor: data.literatureOcurrences?.cursor,\n      query,\n      entities: data.similarEntities,\n      loadingEntities: false,\n      category,\n      litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n      litsCount: data.literatureOcurrences?.filteredCount,\n      earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n      globalEntity,\n      selectedEntities,\n      page: 0,\n      pageSize,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    };\n    literatureDispatch({ type: \"stateUpdate\", value: update });\n  };\n\n  const valueLabelFormat = (value) => {\n    if (earliestPubYear) {\n      const labelDate = selectedDate(value);\n      return `${labelDate.getFullYear()}-${labelDate.getMonth() + 1}`;\n    }\n    return \"YYYY-MM\";\n  };\n\n  const handleDateRangeChange = (_event, value, _activeThumb) => {\n    setFilterDate(value);\n  };\n\n  const handleDateRangeChangeCommitted = (_event, value) => {\n    if (Array.isArray(value)) {\n      const startDate = selectedDate(value[0]);\n      const endDate = selectedDate(value[1]);\n      handleChange({\n        startYear: startDate.getFullYear(),\n        startMonth: startDate.getMonth() + 1,\n        endYear: endDate.getFullYear(),\n        endMonth: endDate.getMonth() + 1,\n      });\n    }\n  };\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        marginTop: 20,\n        marginBottom: 20,\n      }}\n    >\n      <InputLabel id=\"date-filter-demo\">Date Filter:</InputLabel>\n      <FormGroup>\n        <FormControl\n          style={{\n            marginLeft: 20,\n            flex: 1,\n            display: \"flex\",\n            flexDirection: \"row\",\n            gap: 12,\n            alignItems: \"center\",\n          }}\n        >\n          <DateIndicator>{valueLabelFormat(filterDate[0])}</DateIndicator>\n          <OTSlider\n            size=\"small\"\n            style={{ width: 275 }}\n            value={filterDate}\n            valueLabelDisplay=\"auto\"\n            onChange={handleDateRangeChange}\n            onChangeCommitted={handleDateRangeChangeCommitted}\n            getAriaLabel={() => \"date-range-slider\"}\n            max={numberOfMonths}\n            valueLabelFormat={valueLabelFormat}\n          />\n          <DateIndicator>{valueLabelFormat(filterDate[1])}</DateIndicator>\n        </FormControl>\n      </FormGroup>\n    </div>\n  );\n}\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/DateFilter.jsx" },
        "span": [1711, 1720],
        "sourceCode": "import { FormControl, FormGroup, InputLabel, Slider } from \"@mui/material\";\nimport { styled } from \"@mui/material/styles\";\nimport { useEffect, useState } from \"react\";\nimport { useApolloClient } from \"ui\";\nimport { useLiterature, useLiteratureDispatch } from \"./LiteratureContext\";\nimport { fetchSimilarEntities } from \"./requests\";\n\nconst OTSlider = styled(Slider)({\n  root: {\n    padding: \"0 10px !important\",\n  },\n  mark: {\n    backgroundColor: \"#b8b8b8\",\n    width: 10,\n    height: 1,\n    marginLeft: -4,\n  },\n  valueLabel: {\n    zIndex: \"9999\",\n  },\n});\n\nconst DateIndicator = styled(\"span\")({\n  minWidth: 65,\n  maxWidth: 80,\n});\n\nconst monthsBtwnDates = (startDate, endDate) =>\n  Math.max(\n    (endDate.getFullYear() - startDate.getFullYear()) * 12 +\n      (endDate.getMonth() - startDate.getMonth()),\n    0\n  );\n\nexport function DateFilter() {\n  const [filterDate, setFilterDate] = useState([0, 0]);\n  const [numberOfMonths, setNumberOfMonths] = useState(0);\n  const [pubYear, setPubYear] = useState(0);\n  const literature = useLiterature();\n  const literatureDispatch = useLiteratureDispatch();\n  const client = useApolloClient();\n\n  const {\n    query,\n    id,\n    category,\n    earliestPubYear,\n    selectedEntities,\n    globalEntity,\n    litsIds,\n    pageSize,\n    litsCount,\n    loadingEntities,\n  } = literature;\n\n  function getDateFromYear(year) {\n    return new Date(year, 0, 1, 1, 1, 1, 1);\n  }\n\n  const sumMonthsSinceYear = (year) => (value) => {\n    const from = getDateFromYear(year);\n    const date = new Date(from.setMonth(from.getMonth() + value));\n    return date;\n  };\n\n  const selectedDate = sumMonthsSinceYear(earliestPubYear);\n  const oldSelectedDate = sumMonthsSinceYear(pubYear);\n\n  useEffect(() => {\n    // the publication year has changed\n    if (earliestPubYear && earliestPubYear !== pubYear) {\n      const earliestDate = getDateFromYear(earliestPubYear);\n      const limit = monthsBtwnDates(earliestDate, new Date());\n      const lowerLimit = getLowerLimit(earliestDate);\n      const higherLimit = getHigherLimit(earliestDate, limit);\n      setFilterDate([lowerLimit, higherLimit]);\n      setNumberOfMonths(limit);\n      setPubYear(earliestPubYear);\n    } else {\n      setPubYear(0);\n      setNumberOfMonths(0);\n      setFilterDate([0, 0]);\n    }\n  }, [earliestPubYear]);\n\n  function getHigherLimit(earliestDate, limit) {\n    const oldHigherDate = oldSelectedDate(filterDate[1]);\n    const newHighFilter = monthsBtwnDates(earliestDate, oldHigherDate);\n    const higherLimit =\n      filterDate[1] > 0 && newHighFilter > 0 && newHighFilter < limit ? newHighFilter : limit;\n    return higherLimit;\n  }\n\n  function getLowerLimit(earliestDate) {\n    if (filterDate[0] === 0) return 0;\n    const oldLowerDate = oldSelectedDate(filterDate[0]);\n    const newLowerFilter = monthsBtwnDates(earliestDate, oldLowerDate);\n    const lowerLimit = newLowerFilter > 0 ? newLowerFilter : 0;\n    return lowerLimit;\n  }\n\n  const handleChange = async (values) => {\n    literatureDispatch({ type: \"loadingEntities\", value: true });\n    const request = await fetchSimilarEntities({\n      client,\n      query,\n      id,\n      category,\n      entities: selectedEntities,\n      cursor: null,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    });\n    const data = request.data[globalEntity];\n    const update = {\n      id,\n      cursor: data.literatureOcurrences?.cursor,\n      query,\n      entities: data.similarEntities,\n      loadingEntities: false,\n      category,\n      litsIds: data.literatureOcurrences?.rows?.map(({ pmid }) => pmid),\n      litsCount: data.literatureOcurrences?.filteredCount,\n      earliestPubYear: data.literatureOcurrences?.earliestPubYear,\n      globalEntity,\n      selectedEntities,\n      page: 0,\n      pageSize,\n      ...values, // values has startYear, startMonth, endYear, endMonth\n    };\n    literatureDispatch({ type: \"stateUpdate\", value: update });\n  };\n\n  const valueLabelFormat = (value) => {\n    if (earliestPubYear) {\n      const labelDate = selectedDate(value);\n      return `${labelDate.getFullYear()}-${labelDate.getMonth() + 1}`;\n    }\n    return \"YYYY-MM\";\n  };\n\n  const handleDateRangeChange = (_event, value, _activeThumb) => {\n    setFilterDate(value);\n  };\n\n  const handleDateRangeChangeCommitted = (_event, value) => {\n    if (Array.isArray(value)) {\n      const startDate = selectedDate(value[0]);\n      const endDate = selectedDate(value[1]);\n      handleChange({\n        startYear: startDate.getFullYear(),\n        startMonth: startDate.getMonth() + 1,\n        endYear: endDate.getFullYear(),\n        endMonth: endDate.getMonth() + 1,\n      });\n    }\n  };\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        marginTop: 20,\n        marginBottom: 20,\n      }}\n    >\n      <InputLabel id=\"date-filter-demo\">Date Filter:</InputLabel>\n      <FormGroup>\n        <FormControl\n          style={{\n            marginLeft: 20,\n            flex: 1,\n            display: \"flex\",\n            flexDirection: \"row\",\n            gap: 12,\n            alignItems: \"center\",\n          }}\n        >\n          <DateIndicator>{valueLabelFormat(filterDate[0])}</DateIndicator>\n          <OTSlider\n            size=\"small\"\n            style={{ width: 275 }}\n            value={filterDate}\n            valueLabelDisplay=\"auto\"\n            onChange={handleDateRangeChange}\n            onChangeCommitted={handleDateRangeChangeCommitted}\n            getAriaLabel={() => \"date-range-slider\"}\n            max={numberOfMonths}\n            valueLabelFormat={valueLabelFormat}\n          />\n          <DateIndicator>{valueLabelFormat(filterDate[1])}</DateIndicator>\n        </FormControl>\n      </FormGroup>\n    </div>\n  );\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [2358, 2367],
              "sourceCode": "import {\n  Hidden, // note this is deprecated in MUI 5\n  TableCell,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  useMediaQuery,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport useDynamicColspan from \"../../hooks/useDynamicColspans\";\nimport Tooltip from \"../Tooltip\";\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction HeaderCell({\n  classes = {},\n  align,\n  colspan,\n  isHeaderGroup = false,\n  label,\n  labelStyle,\n  minWidth,\n  noWrapHeader,\n  sortable = false,\n  sortParams,\n  sticky = false,\n  tooltip,\n  tooltipStyle = {},\n  width,\n}) {\n  const headerClasses = tableStyles();\n\n  const style = {\n    minWidth,\n    width,\n    ...labelStyle,\n  };\n\n  const labelInnerComponent = (\n    <span className={classNames(classes.innerLabel, headerClasses.headerSpan)}>\n      {tooltip ? (\n        <Tooltip style={tooltipStyle} showHelpIcon title={tooltip}>\n          <span className={headerClasses.headerLabelWithTooltip}>{label}</span>\n        </Tooltip>\n      ) : (\n        label\n      )}\n    </span>\n  );\n\n  return (\n    <TableCell\n      align={align}\n      classes={{\n        root: classNames(headerClasses.cell, headerClasses.cellHeader, classes.headerCell, {\n          [headerClasses.cellGroup]: isHeaderGroup,\n          [headerClasses.cellSticky]: sticky,\n          [headerClasses.noWrap]: noWrapHeader,\n        }),\n      }}\n      colSpan={colspan}\n      sortDirection={sortable && sortParams.direction}\n      style={style}\n    >\n      {sortable ? (\n        <TableSortLabel className={classes.sortLabel} {...sortParams}>\n          {labelInnerComponent}\n        </TableSortLabel>\n      ) : (\n        labelInnerComponent\n      )}\n    </TableCell>\n  );\n}\n\nfunction TableHeader({ columns, headerGroups, noWrapHeader, order, onRequestSort, sortBy }) {\n  // workaround for the old withWidth hook\n  const theme = useTheme();\n  const width = theme.breakpoints.keys.filter((k) => useMediaQuery(theme.breakpoints.only(k)));\n\n  const colspans = useDynamicColspan(headerGroups, columns, width);\n  const createSortHandler = (property) => (event) => {\n    onRequestSort(event, property);\n  };\n\n  return (\n    <TableHead>\n      {headerGroups.length > 0 ? (\n        <TableRow>\n          {headerGroups.map((headerCell, cellIndex) => (\n            <HeaderCell\n              colspan={colspans[cellIndex]}\n              isHeaderGroup={true}\n              key={cellIndex}\n              label={headerCell.label || \"\"}\n              noWrapHeader={noWrapHeader}\n              sticky={headerCell.sticky || false}\n              tooltip={headerCell.tooltip}\n              tooltipStyle={headerCell.tooltipStyle || {}}\n            />\n          ))}\n        </TableRow>\n      ) : null}\n      <TableRow>\n        {columns.map((column, index) => (\n          <Hidden {...getHiddenBreakpoints(column)} key={index}>\n            <HeaderCell\n              align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n              label={column.label || _.startCase(column.id)}\n              noWrapHeader={noWrapHeader}\n              sortable={column.sortable}\n              sortParams={\n                column.sortable\n                  ? {\n                      active: sortBy === column.id,\n                      direction: sortBy === column.id ? order : \"asc\",\n                      onClick: createSortHandler(column.id),\n                    }\n                  : null\n              }\n              labelStyle={column.labelStyle}\n              classes={column.classes}\n              sticky={column.sticky}\n              tooltip={column.tooltip}\n              tooltipStyle={column.tooltipStyle}\n              width={column.width}\n              minWidth={column.minWidth}\n            />\n          </Hidden>\n        ))}\n      </TableRow>\n    </TableHead>\n  );\n}\n\nexport default TableHeader;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/TableHeader.jsx" },
        "span": [2496, 2505],
        "sourceCode": "import {\n  Hidden, // note this is deprecated in MUI 5\n  TableCell,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  useMediaQuery,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport useDynamicColspan from \"../../hooks/useDynamicColspans\";\nimport Tooltip from \"../Tooltip\";\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction HeaderCell({\n  classes = {},\n  align,\n  colspan,\n  isHeaderGroup = false,\n  label,\n  labelStyle,\n  minWidth,\n  noWrapHeader,\n  sortable = false,\n  sortParams,\n  sticky = false,\n  tooltip,\n  tooltipStyle = {},\n  width,\n}) {\n  const headerClasses = tableStyles();\n\n  const style = {\n    minWidth,\n    width,\n    ...labelStyle,\n  };\n\n  const labelInnerComponent = (\n    <span className={classNames(classes.innerLabel, headerClasses.headerSpan)}>\n      {tooltip ? (\n        <Tooltip style={tooltipStyle} showHelpIcon title={tooltip}>\n          <span className={headerClasses.headerLabelWithTooltip}>{label}</span>\n        </Tooltip>\n      ) : (\n        label\n      )}\n    </span>\n  );\n\n  return (\n    <TableCell\n      align={align}\n      classes={{\n        root: classNames(headerClasses.cell, headerClasses.cellHeader, classes.headerCell, {\n          [headerClasses.cellGroup]: isHeaderGroup,\n          [headerClasses.cellSticky]: sticky,\n          [headerClasses.noWrap]: noWrapHeader,\n        }),\n      }}\n      colSpan={colspan}\n      sortDirection={sortable && sortParams.direction}\n      style={style}\n    >\n      {sortable ? (\n        <TableSortLabel className={classes.sortLabel} {...sortParams}>\n          {labelInnerComponent}\n        </TableSortLabel>\n      ) : (\n        labelInnerComponent\n      )}\n    </TableCell>\n  );\n}\n\nfunction TableHeader({ columns, headerGroups, noWrapHeader, order, onRequestSort, sortBy }) {\n  // workaround for the old withWidth hook\n  const theme = useTheme();\n  const width = theme.breakpoints.keys.filter((k) => useMediaQuery(theme.breakpoints.only(k)));\n\n  const colspans = useDynamicColspan(headerGroups, columns, width);\n  const createSortHandler = (property) => (event) => {\n    onRequestSort(event, property);\n  };\n\n  return (\n    <TableHead>\n      {headerGroups.length > 0 ? (\n        <TableRow>\n          {headerGroups.map((headerCell, cellIndex) => (\n            <HeaderCell\n              colspan={colspans[cellIndex]}\n              isHeaderGroup={true}\n              key={cellIndex}\n              label={headerCell.label || \"\"}\n              noWrapHeader={noWrapHeader}\n              sticky={headerCell.sticky || false}\n              tooltip={headerCell.tooltip}\n              tooltipStyle={headerCell.tooltipStyle || {}}\n            />\n          ))}\n        </TableRow>\n      ) : null}\n      <TableRow>\n        {columns.map((column, index) => (\n          <Hidden {...getHiddenBreakpoints(column)} key={index}>\n            <HeaderCell\n              align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n              label={column.label || _.startCase(column.id)}\n              noWrapHeader={noWrapHeader}\n              sortable={column.sortable}\n              sortParams={\n                column.sortable\n                  ? {\n                      active: sortBy === column.id,\n                      direction: sortBy === column.id ? order : \"asc\",\n                      onClick: createSortHandler(column.id),\n                    }\n                  : null\n              }\n              labelStyle={column.labelStyle}\n              classes={column.classes}\n              sticky={column.sticky}\n              tooltip={column.tooltip}\n              tooltipStyle={column.tooltipStyle}\n              width={column.width}\n              minWidth={column.minWidth}\n            />\n          </Hidden>\n        ))}\n      </TableRow>\n    </TableHead>\n  );\n}\n\nexport default TableHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [2858, 2863],
              "sourceCode": "import {\n  Hidden, // note this is deprecated in MUI 5\n  TableCell,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  useMediaQuery,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport useDynamicColspan from \"../../hooks/useDynamicColspans\";\nimport Tooltip from \"../Tooltip\";\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction HeaderCell({\n  classes = {},\n  align,\n  colspan,\n  isHeaderGroup = false,\n  label,\n  labelStyle,\n  minWidth,\n  noWrapHeader,\n  sortable = false,\n  sortParams,\n  sticky = false,\n  tooltip,\n  tooltipStyle = {},\n  width,\n}) {\n  const headerClasses = tableStyles();\n\n  const style = {\n    minWidth,\n    width,\n    ...labelStyle,\n  };\n\n  const labelInnerComponent = (\n    <span className={classNames(classes.innerLabel, headerClasses.headerSpan)}>\n      {tooltip ? (\n        <Tooltip style={tooltipStyle} showHelpIcon title={tooltip}>\n          <span className={headerClasses.headerLabelWithTooltip}>{label}</span>\n        </Tooltip>\n      ) : (\n        label\n      )}\n    </span>\n  );\n\n  return (\n    <TableCell\n      align={align}\n      classes={{\n        root: classNames(headerClasses.cell, headerClasses.cellHeader, classes.headerCell, {\n          [headerClasses.cellGroup]: isHeaderGroup,\n          [headerClasses.cellSticky]: sticky,\n          [headerClasses.noWrap]: noWrapHeader,\n        }),\n      }}\n      colSpan={colspan}\n      sortDirection={sortable && sortParams.direction}\n      style={style}\n    >\n      {sortable ? (\n        <TableSortLabel className={classes.sortLabel} {...sortParams}>\n          {labelInnerComponent}\n        </TableSortLabel>\n      ) : (\n        labelInnerComponent\n      )}\n    </TableCell>\n  );\n}\n\nfunction TableHeader({ columns, headerGroups, noWrapHeader, order, onRequestSort, sortBy }) {\n  // workaround for the old withWidth hook\n  const theme = useTheme();\n  const width = theme.breakpoints.keys.filter((k) => useMediaQuery(theme.breakpoints.only(k)));\n\n  const colspans = useDynamicColspan(headerGroups, columns, width);\n  const createSortHandler = (property) => (event) => {\n    onRequestSort(event, property);\n  };\n\n  return (\n    <TableHead>\n      {headerGroups.length > 0 ? (\n        <TableRow>\n          {headerGroups.map((headerCell, cellIndex) => (\n            <HeaderCell\n              colspan={colspans[cellIndex]}\n              isHeaderGroup={true}\n              key={cellIndex}\n              label={headerCell.label || \"\"}\n              noWrapHeader={noWrapHeader}\n              sticky={headerCell.sticky || false}\n              tooltip={headerCell.tooltip}\n              tooltipStyle={headerCell.tooltipStyle || {}}\n            />\n          ))}\n        </TableRow>\n      ) : null}\n      <TableRow>\n        {columns.map((column, index) => (\n          <Hidden {...getHiddenBreakpoints(column)} key={index}>\n            <HeaderCell\n              align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n              label={column.label || _.startCase(column.id)}\n              noWrapHeader={noWrapHeader}\n              sortable={column.sortable}\n              sortParams={\n                column.sortable\n                  ? {\n                      active: sortBy === column.id,\n                      direction: sortBy === column.id ? order : \"asc\",\n                      onClick: createSortHandler(column.id),\n                    }\n                  : null\n              }\n              labelStyle={column.labelStyle}\n              classes={column.classes}\n              sticky={column.sticky}\n              tooltip={column.tooltip}\n              tooltipStyle={column.tooltipStyle}\n              width={column.width}\n              minWidth={column.minWidth}\n            />\n          </Hidden>\n        ))}\n      </TableRow>\n    </TableHead>\n  );\n}\n\nexport default TableHeader;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/TableHeader.jsx" },
        "span": [2927, 2932],
        "sourceCode": "import {\n  Hidden, // note this is deprecated in MUI 5\n  TableCell,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  useMediaQuery,\n} from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n/* eslint-disable */\nimport classNames from \"classnames\";\nimport _ from \"lodash\";\n\nimport useDynamicColspan from \"../../hooks/useDynamicColspans\";\nimport Tooltip from \"../Tooltip\";\nimport { tableStyles } from \"./tableStyles\";\nimport { getHiddenBreakpoints } from \"./utils\";\n\nfunction HeaderCell({\n  classes = {},\n  align,\n  colspan,\n  isHeaderGroup = false,\n  label,\n  labelStyle,\n  minWidth,\n  noWrapHeader,\n  sortable = false,\n  sortParams,\n  sticky = false,\n  tooltip,\n  tooltipStyle = {},\n  width,\n}) {\n  const headerClasses = tableStyles();\n\n  const style = {\n    minWidth,\n    width,\n    ...labelStyle,\n  };\n\n  const labelInnerComponent = (\n    <span className={classNames(classes.innerLabel, headerClasses.headerSpan)}>\n      {tooltip ? (\n        <Tooltip style={tooltipStyle} showHelpIcon title={tooltip}>\n          <span className={headerClasses.headerLabelWithTooltip}>{label}</span>\n        </Tooltip>\n      ) : (\n        label\n      )}\n    </span>\n  );\n\n  return (\n    <TableCell\n      align={align}\n      classes={{\n        root: classNames(headerClasses.cell, headerClasses.cellHeader, classes.headerCell, {\n          [headerClasses.cellGroup]: isHeaderGroup,\n          [headerClasses.cellSticky]: sticky,\n          [headerClasses.noWrap]: noWrapHeader,\n        }),\n      }}\n      colSpan={colspan}\n      sortDirection={sortable && sortParams.direction}\n      style={style}\n    >\n      {sortable ? (\n        <TableSortLabel className={classes.sortLabel} {...sortParams}>\n          {labelInnerComponent}\n        </TableSortLabel>\n      ) : (\n        labelInnerComponent\n      )}\n    </TableCell>\n  );\n}\n\nfunction TableHeader({ columns, headerGroups, noWrapHeader, order, onRequestSort, sortBy }) {\n  // workaround for the old withWidth hook\n  const theme = useTheme();\n  const width = theme.breakpoints.keys.filter((k) => useMediaQuery(theme.breakpoints.only(k)));\n\n  const colspans = useDynamicColspan(headerGroups, columns, width);\n  const createSortHandler = (property) => (event) => {\n    onRequestSort(event, property);\n  };\n\n  return (\n    <TableHead>\n      {headerGroups.length > 0 ? (\n        <TableRow>\n          {headerGroups.map((headerCell, cellIndex) => (\n            <HeaderCell\n              colspan={colspans[cellIndex]}\n              isHeaderGroup={true}\n              key={cellIndex}\n              label={headerCell.label || \"\"}\n              noWrapHeader={noWrapHeader}\n              sticky={headerCell.sticky || false}\n              tooltip={headerCell.tooltip}\n              tooltipStyle={headerCell.tooltipStyle || {}}\n            />\n          ))}\n        </TableRow>\n      ) : null}\n      <TableRow>\n        {columns.map((column, index) => (\n          <Hidden {...getHiddenBreakpoints(column)} key={index}>\n            <HeaderCell\n              align={column.align ? column.align : column.numeric ? \"right\" : \"left\"}\n              label={column.label || _.startCase(column.id)}\n              noWrapHeader={noWrapHeader}\n              sortable={column.sortable}\n              sortParams={\n                column.sortable\n                  ? {\n                      active: sortBy === column.id,\n                      direction: sortBy === column.id ? order : \"asc\",\n                      onClick: createSortHandler(column.id),\n                    }\n                  : null\n              }\n              labelStyle={column.labelStyle}\n              classes={column.classes}\n              sticky={column.sticky}\n              tooltip={column.tooltip}\n              tooltipStyle={column.tooltipStyle}\n              width={column.width}\n              minWidth={column.minWidth}\n            />\n          </Hidden>\n        ))}\n      </TableRow>\n    </TableHead>\n  );\n}\n\nexport default TableHeader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: detailsDispatch",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: detailsDispatch"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2493, 2508],
              "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2288, 2303],
              "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/PublicationsList.tsx" },
        "span": [2102, 2111],
        "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: litsIds.filter",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: litsIds.filter"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2189, 2203],
              "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/PublicationsList.tsx" },
        "span": [2102, 2111],
        "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: details[id]",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: details[id]"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2221, 2232],
              "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/PublicationsList.tsx" },
        "span": [2102, 2111],
        "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: literature",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: literature"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2651, 2661],
              "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/common/Literature/PublicationsList.tsx" },
        "span": [2102, 2111],
        "sourceCode": "import { Box, Fade, Grid, Skeleton } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect } from \"react\";\nimport { PublicationWrapper, Table, useApolloClient } from \"ui\";\nimport {\n  useDetails,\n  useDetailsDispatch,\n  useDisplayedPublications,\n  useLiterature,\n  useLiteratureDispatch,\n} from \"./LiteratureContext\";\nimport Loader from \"./Loader\";\nimport { fetchSimilarEntities, literaturesEuropePMCQuery } from \"./requests\";\nimport type { DetailsStateType, PublicationType } from \"./types\";\n\nconst useStyles = makeStyles(() => ({\n  root: {\n    marginTop: 0,\n  },\n}));\n\nfunction parsePublications(publications: PublicationType[]): DetailsStateType {\n  const obj: DetailsStateType = {};\n  for (const pub of publications) {\n    obj[pub.id] = {\n      source: pub.source,\n      patentDetails: pub.patentDetails,\n      europePmcId: pub.id,\n      fullTextOpen: !!(pub.inEPMC === \"Y\" || pub.inPMC === \"Y\"),\n      title: pub.title,\n      year: pub.pubYear,\n      abstract: pub.abstractText,\n      openAccess: pub.isOpenAccess !== \"N\",\n      authors: pub.authorList?.author || [],\n      journal: {\n        ...pub.journalInfo,\n        page: pub.pageInfo,\n      },\n    };\n  }\n  return obj;\n}\n\nfunction SkeletonRow() {\n  return (\n    <Fade in>\n      <Box mb={2}>\n        <Skeleton height={60} />\n        <Skeleton width=\"60%\" height={45} />\n        <Grid container wrap=\"nowrap\">\n          <Box width={130} mr={1}>\n            <Skeleton height={45} />\n          </Box>\n          <Box width={130}>\n            <Skeleton height={45} />\n          </Box>\n        </Grid>\n      </Box>\n    </Fade>\n  );\n}\n\nfunction PublicationsList({ hideSearch = false }) {\n  const classes = useStyles();\n  const literature = useLiterature();\n  const { loadingEntities, litsCount: count, cursor, page, pageSize, litsIds } = literature;\n  const details = useDetails();\n  const displayedPubs = useDisplayedPublications();\n  const literatureDispatch = useLiteratureDispatch();\n  const detailsDispatch = useDetailsDispatch();\n  const client = useApolloClient();\n\n  // get publications details from Europe PMC\n  useEffect(() => {\n    const fetchFunction = async () => {\n      const missingDetails = litsIds.filter((id: string) => !details[id]);\n      if (missingDetails.length === 0) return;\n      detailsDispatch({\n        type: \"setToLoading\",\n        value: missingDetails,\n      });\n      const queryResult = await literaturesEuropePMCQuery({\n        literaturesIds: missingDetails,\n      });\n      detailsDispatch({\n        type: \"addDetails\",\n        value: parsePublications(queryResult),\n      });\n    };\n    fetchFunction().catch(console.error);\n  }, [literature]);\n\n  const handleRowsPerPageChange = async (newPageSize: string): Promise<void> => {\n    const pageSizeInt = Number(newPageSize);\n    const expected = pageSizeInt * page + pageSizeInt;\n    if (expected > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: 0,\n        pageSize: pageSizeInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: 0, pageSize: pageSizeInt },\n      });\n    }\n  };\n\n  const handlePageChange = async (newPage: string): Promise<void> => {\n    const newPageInt = Number(newPage);\n    if (pageSize * newPageInt + pageSize > litsIds.length && cursor !== null) {\n      const {\n        query,\n        id,\n        category,\n        selectedEntities,\n        cursor: newCursor,\n        globalEntity,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      } = literature;\n      literatureDispatch({ type: \"loadingEntities\", value: true });\n      const request = await fetchSimilarEntities({\n        client,\n        query,\n        id,\n        category,\n        entities: selectedEntities,\n        cursor: newCursor,\n        endYear,\n        endMonth,\n        startYear,\n        startMonth,\n      });\n      literatureDispatch({ type: \"loadingEntities\", value: false });\n      const data = request.data[globalEntity];\n      const newLitsIds = data.literatureOcurrences?.rows?.map(({ pmid }) => pmid) ?? [];\n      const update = {\n        litsIds: [...litsIds, ...newLitsIds],\n        cursor: data.literatureOcurrences?.cursor,\n        page: newPageInt,\n      };\n      literatureDispatch({ type: \"stateUpdate\", value: update });\n    } else {\n      literatureDispatch({\n        type: \"stateUpdate\",\n        value: { page: newPageInt },\n      });\n    }\n  };\n\n  const columns = [\n    {\n      id: \"publications\",\n      label: \" \",\n      renderCell(id) {\n        const det = details[id];\n        if (det === \"loading\") {\n          return <SkeletonRow />;\n        }\n        if (!det) {\n          return null;\n        }\n        return (\n          <PublicationWrapper\n            europePmcId={det.europePmcId}\n            title={det.title}\n            titleHtml={det.titleHtml}\n            authors={det.authors}\n            journal={det.journal}\n            variant={det.variant}\n            abstract={det.abstract}\n            fullTextOpen={det.fullTextOpen}\n            source={det.source}\n            patentDetails={det.patentDetails}\n          />\n        );\n      },\n      filterValue: ({ row: publication }) =>\n        `${publication.journal.journal?.title} ${publication?.title} ${publication?.year}\n        ${publication.authors\n          .reduce((acc, author) => {\n            if (author.fullName) acc.push(author.fullName);\n            return acc;\n          }, [])\n          .join(\" \")}`,\n    },\n  ];\n\n  if (loadingEntities)\n    return <Loader pageSize={pageSize} message=\"Loading literature ocurrences results\" />;\n\n  return (\n    <Table\n      classes={classes}\n      showGlobalFilter={!hideSearch}\n      columns={columns}\n      rows={displayedPubs}\n      rowCount={count}\n      rowsPerPageOptions={[5, 10, 25]}\n      page={page}\n      pageSize={pageSize}\n      onPageChange={handlePageChange}\n      onRowsPerPageChange={handleRowsPerPageChange}\n    />\n  );\n}\n\nexport default PublicationsList;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/credibleSet/Locus2Gene/helpers.ts" },
        "span": [2081, 2091],
        "sourceCode": "import { extent, interpolateRgbBasis, mean, scaleDiverging, scaleLinear } from \"d3\";\nimport { DIVERGING_COLORS, featureToGroup, groupNames } from \"./constants\";\n\nexport function getGroupResults(data) {\n  const rows = data.map((d) => {\n    const row = {\n      targetId: d.target.id,\n      targetSymbol: d.target.approvedSymbol,\n      shapBaseValue: d.shapBaseValue,\n      score: d.score,\n    };\n    for (const groupName of groupNames) {\n      row[groupName] = 0;\n    }\n    for (const feature of d.features) {\n      const groupName = featureToGroup[feature.name];\n      if (groupName) {\n        row[groupName] += feature.shapValue;\n      } else {\n        console.warn(`feature ${feature.name} does not belong to any group`);\n      }\n    }\n    return row;\n  });\n  rows.sort((a, b) => b.score - a.score);\n  return rows;\n}\n\nexport function computeWaterfall(originalRow, fullXDomain, zeroBase) {\n  const row = structuredClone(originalRow);\n  const { features } = row;\n  features.sort((a, b) => Math.abs(a.shapValue) - Math.abs(b.shapValue));\n  for (const [index, feature] of features.entries()) {\n    feature._start = features[index - 1]?._end ?? (zeroBase ? 0 : row.shapBaseValue);\n    feature._end = feature._start + feature.shapValue;\n  }\n  const xExtent = extent(features.flatMap((d) => [d._start, d._end]));\n  if (fullXDomain) {\n    const relativeSize = (xExtent[1] - xExtent[0]) / (fullXDomain[1] - fullXDomain[0]);\n    if (relativeSize < 0.25) {\n      const middle = mean(xExtent);\n      const stretch = 0.25 / relativeSize;\n      xExtent[0] = middle + (xExtent[0] - middle) * stretch;\n      xExtent[1] = middle + (xExtent[1] - middle) * stretch;\n    }\n  }\n  const xDomain = scaleLinear().domain(xExtent).nice().domain();\n  return { row, xDomain };\n}\n\nexport function getColorInterpolator(groupResults) {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  for (const row of groupResults) {\n    for (const groupName of groupNames) {\n      min = Math.min(min, row[groupName]);\n      max = Math.max(max, row[groupName]);\n    }\n  }\n  Math.abs(min) > max ? (max = -min) : (min = -max);\n  return scaleDiverging().domain([min, 0, max]).interpolator(interpolateRgbBasis(DIVERGING_COLORS));\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/credibleSet/Locus2Gene/helpers.ts" },
        "span": [2096, 2106],
        "sourceCode": "import { extent, interpolateRgbBasis, mean, scaleDiverging, scaleLinear } from \"d3\";\nimport { DIVERGING_COLORS, featureToGroup, groupNames } from \"./constants\";\n\nexport function getGroupResults(data) {\n  const rows = data.map((d) => {\n    const row = {\n      targetId: d.target.id,\n      targetSymbol: d.target.approvedSymbol,\n      shapBaseValue: d.shapBaseValue,\n      score: d.score,\n    };\n    for (const groupName of groupNames) {\n      row[groupName] = 0;\n    }\n    for (const feature of d.features) {\n      const groupName = featureToGroup[feature.name];\n      if (groupName) {\n        row[groupName] += feature.shapValue;\n      } else {\n        console.warn(`feature ${feature.name} does not belong to any group`);\n      }\n    }\n    return row;\n  });\n  rows.sort((a, b) => b.score - a.score);\n  return rows;\n}\n\nexport function computeWaterfall(originalRow, fullXDomain, zeroBase) {\n  const row = structuredClone(originalRow);\n  const { features } = row;\n  features.sort((a, b) => Math.abs(a.shapValue) - Math.abs(b.shapValue));\n  for (const [index, feature] of features.entries()) {\n    feature._start = features[index - 1]?._end ?? (zeroBase ? 0 : row.shapBaseValue);\n    feature._end = feature._start + feature.shapValue;\n  }\n  const xExtent = extent(features.flatMap((d) => [d._start, d._end]));\n  if (fullXDomain) {\n    const relativeSize = (xExtent[1] - xExtent[0]) / (fullXDomain[1] - fullXDomain[0]);\n    if (relativeSize < 0.25) {\n      const middle = mean(xExtent);\n      const stretch = 0.25 / relativeSize;\n      xExtent[0] = middle + (xExtent[0] - middle) * stretch;\n      xExtent[1] = middle + (xExtent[1] - middle) * stretch;\n    }\n  }\n  const xDomain = scaleLinear().domain(xExtent).nice().domain();\n  return { row, xDomain };\n}\n\nexport function getColorInterpolator(groupResults) {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  for (const row of groupResults) {\n    for (const groupName of groupNames) {\n      min = Math.min(min, row[groupName]);\n      max = Math.max(max, row[groupName]);\n    }\n  }\n  Math.abs(min) > max ? (max = -min) : (min = -max);\n  return scaleDiverging().domain([min, 0, max]).interpolator(interpolateRgbBasis(DIVERGING_COLORS));\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/GWASStudies/Body.tsx" },
        "span": [1073, 1084],
        "sourceCode": "import { Box, Typography } from \"@mui/material\";\nimport { naLabel, table5HChunkSize } from \"@ot/constants\";\nimport { epmcUrl, getStudyCategory } from \"@ot/utils\";\nimport type { ReactElement } from \"react\";\nimport { Link, OtTable, PublicationsDrawer, SectionItem, Tooltip, useBatchQuery } from \"ui\";\nimport Description from \"./Description\";\n\nimport { definition } from \".\";\nimport GWAS_STUDIES_BODY_QUERY from \"./GWASStudiesQuery.gql\";\n\nconst columns = [\n  {\n    id: \"id\",\n    label: \"Study\",\n    enableHiding: false,\n    renderCell: ({ id }) => (\n      <Link asyncTooltip to={`/study/${id}`}>\n        {id}\n      </Link>\n    ),\n  },\n  {\n    id: \"traitFromSource\",\n    label: \"Reported trait\",\n  },\n  {\n    id: \"nSamples\",\n    label: \"Sample size\",\n    renderCell: ({ nSamples }) => {\n      return typeof nSamples === \"number\" ? nSamples.toLocaleString() : naLabel;\n    },\n    comparator: (a, b) => a?.nSamples - b?.nSamples,\n    sortable: true,\n  },\n  {\n    id: \"cohorts\",\n    label: \"Cohorts\",\n    renderCell: ({ projectId, cohorts, ldPopulationStructure }) => {\n      let displayText;\n      if (getStudyCategory(projectId) === \"FINNGEN\") displayText = \"FinnGen\";\n      else if (cohorts?.length) displayText = cohorts.join(\", \");\n      else return naLabel;\n      return ldPopulationStructure?.length ? (\n        <Tooltip\n          title={\n            <>\n              <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                LD populations and relative sample sizes\n              </Typography>\n              {ldPopulationStructure.map(({ ldPopulation, relativeSampleSize }) => (\n                <Box key={ldPopulation}>\n                  <Typography variant=\"caption\">\n                    {ldPopulation}: {relativeSampleSize}\n                  </Typography>\n                </Box>\n              ))}\n            </>\n          }\n          showHelpIcon\n        >\n          {displayText}\n        </Tooltip>\n      ) : (\n        displayText\n      );\n    },\n    exportValue: ({ projectId, cohorts }) =>\n      getStudyCategory(projectId) === \"FINNGEN\"\n        ? \"FinnGen\"\n        : cohorts?.length\n          ? cohorts.join(\", \")\n          : null,\n  },\n  {\n    id: \"publication\",\n    label: \"Publication\",\n    renderCell: ({ publicationFirstAuthor, publicationDate, pubmedId, projectId }) => {\n      if (!publicationFirstAuthor) return naLabel;\n      return (\n        <PublicationsDrawer\n          entries={[{ name: pubmedId, url: epmcUrl(pubmedId) }]}\n          customLabel={`${\n            getStudyCategory(projectId) === \"FINNGEN\"\n              ? \"FinnGen\"\n              : publicationFirstAuthor || naLabel\n          } et al. (${new Date(publicationDate).getFullYear()})`}\n        />\n      );\n    },\n    filterValue: ({ publicationYear, publicationFirstAuthor }) =>\n      `${publicationYear} ${publicationFirstAuthor}`,\n    exportValue: ({ pubmedId }) => `${pubmedId}`,\n  },\n];\n\ntype BodyProps = {\n  id: string;\n  label: string;\n};\n\nfunction Body({ id: efoId, label: diseaseName }: BodyProps): ReactElement {\n  const variables = {\n    diseaseIds: [efoId],\n    size: table5HChunkSize,\n    index: 0,\n  };\n\n  const request = useBatchQuery({\n    query: GWAS_STUDIES_BODY_QUERY,\n    variables,\n    dataPath: \"studies\",\n    size: table5HChunkSize,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity=\"studies\"\n      pageEntity=\"disease\"\n      showContentLoading\n      loadingMessage=\"Loading data. This may take some time...\"\n      request={request}\n      renderDescription={() => <Description name={diseaseName} />}\n      renderBody={() => (\n        <OtTable\n          columns={columns}\n          rows={request.data?.studies.rows}\n          sortBy=\"nSamples\"\n          order=\"desc\"\n          dataDownloader\n          loading={request.loading}\n          query={GWAS_STUDIES_BODY_QUERY.loc.source.body}\n          variables={variables}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [3217, 3218],
              "sourceCode": "import {\n  Box,\n  CircularProgress,\n  Grid,\n  TableRow as MUITableRow,\n  Table as MuiTable,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TablePagination,\n} from \"@mui/material\";\nimport classNames from \"classnames\";\n/* eslint-disable */\nimport { useState } from \"react\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport GlobalFilter from \"./GlobalFilter\";\nimport TableHeader from \"./TableHeader\";\nimport TableRow from \"./TableRow\";\nimport { tableStyles } from \"./tableStyles\";\n\nconst Table = ({\n  classes = {},\n  sortBy,\n  order,\n  page,\n  columns,\n  rows,\n  rowCount = rows.length,\n  fixed = false,\n  headerGroups = [],\n  loading,\n  onGlobalFilterChange = () => {},\n  onSortBy = () => {},\n  onRowsPerPageChange = () => {},\n  onPageChange = () => {},\n  pageSize = 10,\n  dataDownloader = false,\n  dataDownloaderFileStem = \"data\",\n  dataDownloaderRows,\n  dataDownloaderColumns,\n  hover = false,\n  noWrap = true,\n  noWrapHeader = true,\n  showGlobalFilter,\n  showPagination = true,\n  globalFilter,\n  rowsPerPageOptions = [],\n  ActionsComponent,\n  onRowClick = () => {},\n  rowIsSelectable = false,\n  query,\n  variables,\n}) => {\n  const emptyRows = pageSize - rows.length;\n  const [selectedRow, setSelectedRow] = useState(0);\n  const defaultClasses = tableStyles();\n\n  const handleGlobalFilterChange = (newGlobalFilter) => {\n    if (newGlobalFilter !== globalFilter) {\n      onGlobalFilterChange(newGlobalFilter);\n    }\n  };\n\n  const handleSort = (_, sortBy) => {\n    onSortBy(sortBy);\n  };\n\n  const handleChangeRowsPerPage = (event) => {\n    onRowsPerPageChange(Number(event.target.value));\n  };\n  const handleChangePage = (_, page) => {\n    // reset the selected;\n    // TODO: maybe should be handled in individual implementation\n    setSelectedRow(0);\n    onPageChange(page);\n  };\n  const handleClick = (_event, row, i) => {\n    setSelectedRow(i);\n    onRowClick(row, i);\n  };\n\n  return (\n    <Grid container direction=\"column\">\n      <Grid item container>\n        <Grid className={defaultClasses.filter} item xs={12} md={4} lg={4}>\n          {showGlobalFilter && <GlobalFilter onGlobalFilterChange={handleGlobalFilterChange} />}\n        </Grid>\n        <Grid\n          className={defaultClasses.downloader}\n          item\n          xs={12}\n          md={8}\n          lg={8}\n          sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}\n        >\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={dataDownloaderRows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      <TableContainer className={classNames(defaultClasses.container, classes.root)}>\n        <MuiTable\n          className={classNames(defaultClasses.table, classes.table, {\n            [defaultClasses.tableFixed]: fixed,\n          })}\n        >\n          <TableHeader\n            columns={columns}\n            headerGroups={headerGroups}\n            noWrapHeader={noWrapHeader}\n            order={order}\n            sortBy={sortBy}\n            onRequestSort={handleSort}\n          />\n          <TableBody>\n            {rows.map((row, i) => (\n              <TableRow\n                columns={columns}\n                hover={hover}\n                isFixedRow={row.isFixedRow}\n                key={i}\n                row={row}\n                noWrap={noWrap}\n                onClick={(event) => handleClick(event, row, i)}\n                selected={rowIsSelectable && selectedRow === i}\n              />\n            ))}\n            {page > 0 && noWrap && emptyRows > 0 && (\n              <MUITableRow style={{ height: `${1.6875 * emptyRows}rem` }}>\n                <TableCell\n                  colSpan={columns.length}\n                  classes={{\n                    root: `${defaultClasses.cellBody} ${defaultClasses.noData}`,\n                  }}\n                >\n                  {!rows.length && \"No data\"}\n                </TableCell>\n              </MUITableRow>\n            )}\n          </TableBody>\n        </MuiTable>\n      </TableContainer>\n      <Grid item container justifyContent=\"center\">\n        {loading && <CircularProgress className={defaultClasses.progress} size={22} />}\n      </Grid>\n      <Grid item container justifyContent=\"flex-end\">\n        {showPagination ? (\n          <TablePagination\n            ActionsComponent={ActionsComponent}\n            backIconButtonProps={{ disabled: loading || page === 0 }}\n            nextIconButtonProps={{\n              disabled: loading || page >= rowCount / pageSize - 1,\n            }}\n            component=\"div\"\n            count={rowCount}\n            onPageChange={handleChangePage}\n            onRowsPerPageChange={handleChangeRowsPerPage}\n            page={page}\n            rowsPerPage={pageSize}\n            rowsPerPageOptions={rowsPerPageOptions}\n            SelectProps={{\n              native: true,\n              inputProps: {\n                \"aria-label\": \"Rows per page select dropdown\",\n              },\n            }}\n          />\n        ) : (\n          <Box className={defaultClasses.paginationPlaceholder} />\n        )}\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Table;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/Table.jsx" },
        "span": [3378, 3379],
        "sourceCode": "import {\n  Box,\n  CircularProgress,\n  Grid,\n  TableRow as MUITableRow,\n  Table as MuiTable,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TablePagination,\n} from \"@mui/material\";\nimport classNames from \"classnames\";\n/* eslint-disable */\nimport { useState } from \"react\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport GlobalFilter from \"./GlobalFilter\";\nimport TableHeader from \"./TableHeader\";\nimport TableRow from \"./TableRow\";\nimport { tableStyles } from \"./tableStyles\";\n\nconst Table = ({\n  classes = {},\n  sortBy,\n  order,\n  page,\n  columns,\n  rows,\n  rowCount = rows.length,\n  fixed = false,\n  headerGroups = [],\n  loading,\n  onGlobalFilterChange = () => {},\n  onSortBy = () => {},\n  onRowsPerPageChange = () => {},\n  onPageChange = () => {},\n  pageSize = 10,\n  dataDownloader = false,\n  dataDownloaderFileStem = \"data\",\n  dataDownloaderRows,\n  dataDownloaderColumns,\n  hover = false,\n  noWrap = true,\n  noWrapHeader = true,\n  showGlobalFilter,\n  showPagination = true,\n  globalFilter,\n  rowsPerPageOptions = [],\n  ActionsComponent,\n  onRowClick = () => {},\n  rowIsSelectable = false,\n  query,\n  variables,\n}) => {\n  const emptyRows = pageSize - rows.length;\n  const [selectedRow, setSelectedRow] = useState(0);\n  const defaultClasses = tableStyles();\n\n  const handleGlobalFilterChange = (newGlobalFilter) => {\n    if (newGlobalFilter !== globalFilter) {\n      onGlobalFilterChange(newGlobalFilter);\n    }\n  };\n\n  const handleSort = (_, sortBy) => {\n    onSortBy(sortBy);\n  };\n\n  const handleChangeRowsPerPage = (event) => {\n    onRowsPerPageChange(Number(event.target.value));\n  };\n  const handleChangePage = (_, page) => {\n    // reset the selected;\n    // TODO: maybe should be handled in individual implementation\n    setSelectedRow(0);\n    onPageChange(page);\n  };\n  const handleClick = (_event, row, i) => {\n    setSelectedRow(i);\n    onRowClick(row, i);\n  };\n\n  return (\n    <Grid container direction=\"column\">\n      <Grid item container>\n        <Grid className={defaultClasses.filter} item xs={12} md={4} lg={4}>\n          {showGlobalFilter && <GlobalFilter onGlobalFilterChange={handleGlobalFilterChange} />}\n        </Grid>\n        <Grid\n          className={defaultClasses.downloader}\n          item\n          xs={12}\n          md={8}\n          lg={8}\n          sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}\n        >\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={dataDownloaderRows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      <TableContainer className={classNames(defaultClasses.container, classes.root)}>\n        <MuiTable\n          className={classNames(defaultClasses.table, classes.table, {\n            [defaultClasses.tableFixed]: fixed,\n          })}\n        >\n          <TableHeader\n            columns={columns}\n            headerGroups={headerGroups}\n            noWrapHeader={noWrapHeader}\n            order={order}\n            sortBy={sortBy}\n            onRequestSort={handleSort}\n          />\n          <TableBody>\n            {rows.map((row, i) => (\n              <TableRow\n                columns={columns}\n                hover={hover}\n                isFixedRow={row.isFixedRow}\n                key={i}\n                row={row}\n                noWrap={noWrap}\n                onClick={(event) => handleClick(event, row, i)}\n                selected={rowIsSelectable && selectedRow === i}\n              />\n            ))}\n            {page > 0 && noWrap && emptyRows > 0 && (\n              <MUITableRow style={{ height: `${1.6875 * emptyRows}rem` }}>\n                <TableCell\n                  colSpan={columns.length}\n                  classes={{\n                    root: `${defaultClasses.cellBody} ${defaultClasses.noData}`,\n                  }}\n                >\n                  {!rows.length && \"No data\"}\n                </TableCell>\n              </MUITableRow>\n            )}\n          </TableBody>\n        </MuiTable>\n      </TableContainer>\n      <Grid item container justifyContent=\"center\">\n        {loading && <CircularProgress className={defaultClasses.progress} size={22} />}\n      </Grid>\n      <Grid item container justifyContent=\"flex-end\">\n        {showPagination ? (\n          <TablePagination\n            ActionsComponent={ActionsComponent}\n            backIconButtonProps={{ disabled: loading || page === 0 }}\n            nextIconButtonProps={{\n              disabled: loading || page >= rowCount / pageSize - 1,\n            }}\n            component=\"div\"\n            count={rowCount}\n            onPageChange={handleChangePage}\n            onRowsPerPageChange={handleChangeRowsPerPage}\n            page={page}\n            rowsPerPage={pageSize}\n            rowsPerPageOptions={rowsPerPageOptions}\n            SelectProps={{\n              native: true,\n              inputProps: {\n                \"aria-label\": \"Rows per page select dropdown\",\n              },\n            }}\n          />\n        ) : (\n          <Box className={defaultClasses.paginationPlaceholder} />\n        )}\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Table;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/KnownDrugs/Body.jsx" },
        "span": [1702, 1926],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Target information\",\n      columns: [\n        {\n          id: \"targetSymbol\",\n          label: \"Symbol\",\n          propertyPath: \"target.approvedSymbol\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/target/${d.target.id}`}>\n              {d.target.approvedSymbol}\n            </Link>\n          ),\n        },\n        {\n          id: \"targetName\",\n          label: \"Name\",\n          propertyPath: \"target.approvedName\",\n          hidden: [\"lgDown\"],\n          renderCell: (d) => d.target.approvedName,\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = [\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction }, target }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === target.id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"symbol\",\n    exportValue: (row) => row.target.approvedSymbol,\n  },\n  {\n    label: \"name\",\n    exportValue: (row) => row.target.approvedName,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: efoId, label: name, entity }) {\n  const columnPool = getColumnPool(efoId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns}\n            dataDownloaderFileStem={`${efoId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(dd) => {\n              setRequest(dd);\n            }}\n            variables={{ efoId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/KnownDrugs/Body.jsx" },
        "span": [1764, 1910],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Target information\",\n      columns: [\n        {\n          id: \"targetSymbol\",\n          label: \"Symbol\",\n          propertyPath: \"target.approvedSymbol\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/target/${d.target.id}`}>\n              {d.target.approvedSymbol}\n            </Link>\n          ),\n        },\n        {\n          id: \"targetName\",\n          label: \"Name\",\n          propertyPath: \"target.approvedName\",\n          hidden: [\"lgDown\"],\n          renderCell: (d) => d.target.approvedName,\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = [\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction }, target }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === target.id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"symbol\",\n    exportValue: (row) => row.target.approvedSymbol,\n  },\n  {\n    label: \"name\",\n    exportValue: (row) => row.target.approvedName,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: efoId, label: name, entity }) {\n  const columnPool = getColumnPool(efoId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns}\n            dataDownloaderFileStem={`${efoId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(dd) => {\n              setRequest(dd);\n            }}\n            variables={{ efoId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/KnownDrugs/Body.jsx" },
        "span": [4325, 4509],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Target information\",\n      columns: [\n        {\n          id: \"targetSymbol\",\n          label: \"Symbol\",\n          propertyPath: \"target.approvedSymbol\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/target/${d.target.id}`}>\n              {d.target.approvedSymbol}\n            </Link>\n          ),\n        },\n        {\n          id: \"targetName\",\n          label: \"Name\",\n          propertyPath: \"target.approvedName\",\n          hidden: [\"lgDown\"],\n          renderCell: (d) => d.target.approvedName,\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = [\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction }, target }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === target.id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"symbol\",\n    exportValue: (row) => row.target.approvedSymbol,\n  },\n  {\n    label: \"name\",\n    exportValue: (row) => row.target.approvedName,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: efoId, label: name, entity }) {\n  const columnPool = getColumnPool(efoId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns}\n            dataDownloaderFileStem={`${efoId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(dd) => {\n              setRequest(dd);\n            }}\n            variables={{ efoId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/KnownDrugs/Body.jsx" },
        "span": [4376, 4499],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Target information\",\n      columns: [\n        {\n          id: \"targetSymbol\",\n          label: \"Symbol\",\n          propertyPath: \"target.approvedSymbol\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/target/${d.target.id}`}>\n              {d.target.approvedSymbol}\n            </Link>\n          ),\n        },\n        {\n          id: \"targetName\",\n          label: \"Name\",\n          propertyPath: \"target.approvedName\",\n          hidden: [\"lgDown\"],\n          renderCell: (d) => d.target.approvedName,\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = [\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction }, target }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === target.id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"symbol\",\n    exportValue: (row) => row.target.approvedSymbol,\n  },\n  {\n    label: \"name\",\n    exportValue: (row) => row.target.approvedName,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: efoId, label: name, entity }) {\n  const columnPool = getColumnPool(efoId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns}\n            dataDownloaderFileStem={`${efoId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(dd) => {\n              setRequest(dd);\n            }}\n            variables={{ efoId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: requestEfoNodes",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: requestEfoNodes"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [885, 900],
              "sourceCode": "import { useEffect, useState } from \"react\";\nimport { SectionItem, useConfigContext } from \"ui\";\n\nimport Description from \"./Description\";\nimport OntologySubgraph from \"./OntologySubgraph\";\n\nimport { definition } from \"./index\";\n\nfunction Body({ id: efoId, label: name, entity }) {\n  const { config } = useConfigContext();\n\n  const [efoNodes, setEfoNodes] = useState({\n    allNodes: null,\n    filteredNodes: null,\n  });\n\n  function requestEfoNodes() {\n    fetch(config.efoURL)\n      .then((res) => res.text())\n      .then((lines) => {\n        const nodes = lines.trim().split(\"\\n\").map(JSON.parse);\n        const idToDisease = nodes.reduce((acc, disease) => {\n          acc[disease.id] = disease;\n          return acc;\n        }, {});\n        setEfoNodes({ allNodes: nodes, filteredNodes: idToDisease });\n      });\n  }\n\n  useEffect(() => {\n    let isCurrent = true;\n    if (isCurrent) requestEfoNodes();\n\n    return () => {\n      isCurrent = false;\n    };\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={{\n        loading: !efoNodes.filteredNodes,\n        data: {\n          [entity]: { efoNodes: efoNodes.allNodes },\n        },\n      }}\n      showContentLoading={true}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        return (\n          <OntologySubgraph\n            efoId={efoId}\n            efo={efoNodes.allNodes}\n            name={name}\n            idToDisease={efoNodes.filteredNodes}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Ontology/Body.jsx" },
        "span": [822, 831],
        "sourceCode": "import { useEffect, useState } from \"react\";\nimport { SectionItem, useConfigContext } from \"ui\";\n\nimport Description from \"./Description\";\nimport OntologySubgraph from \"./OntologySubgraph\";\n\nimport { definition } from \"./index\";\n\nfunction Body({ id: efoId, label: name, entity }) {\n  const { config } = useConfigContext();\n\n  const [efoNodes, setEfoNodes] = useState({\n    allNodes: null,\n    filteredNodes: null,\n  });\n\n  function requestEfoNodes() {\n    fetch(config.efoURL)\n      .then((res) => res.text())\n      .then((lines) => {\n        const nodes = lines.trim().split(\"\\n\").map(JSON.parse);\n        const idToDisease = nodes.reduce((acc, disease) => {\n          acc[disease.id] = disease;\n          return acc;\n        }, {});\n        setEfoNodes({ allNodes: nodes, filteredNodes: idToDisease });\n      });\n  }\n\n  useEffect(() => {\n    let isCurrent = true;\n    if (isCurrent) requestEfoNodes();\n\n    return () => {\n      isCurrent = false;\n    };\n  }, []);\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={{\n        loading: !efoNodes.filteredNodes,\n        data: {\n          [entity]: { efoNodes: efoNodes.allNodes },\n        },\n      }}\n      showContentLoading={true}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        return (\n          <OntologySubgraph\n            efoId={efoId}\n            efo={efoNodes.allNodes}\n            name={name}\n            idToDisease={efoNodes.filteredNodes}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: onGlobalFilterChange",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: onGlobalFilterChange"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [689, 709],
              "sourceCode": "import { faMagnifyingGlass, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, IconButton, Input } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\n\nimport useDebounce from \"../../hooks/useDebounce\";\nimport { globalSearchStyles } from \"./tableStyles\";\n\nfunction GlobalFilter({ onGlobalFilterChange }) {\n  const [inputValue, setInputValue] = useState(\"\");\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  const handleInputChange = (e) => {\n    setInputValue(e.target.value);\n  };\n\n  const handleInputClean = () => {\n    setInputValue(\"\");\n  };\n\n  useEffect(\n    () => {\n      onGlobalFilterChange(debouncedInputValue);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [debouncedInputValue]\n  );\n\n  const classes = globalSearchStyles();\n\n  return (\n    <Grid container>\n      <Grid item xs={12}>\n        <Input\n          autoComplete=\"off\"\n          classes={{ root: classes.root }}\n          startAdornment={<FontAwesomeIcon icon={faMagnifyingGlass} />}\n          endAdornment={\n            !!inputValue && (\n              <IconButton onClick={handleInputClean}>\n                <FontAwesomeIcon icon={faXmark} />\n              </IconButton>\n            )\n          }\n          placeholder=\"Search\"\n          label=\"Filter\"\n          onChange={handleInputChange}\n          value={inputValue}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default GlobalFilter;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Table/GlobalFilter.jsx" },
        "span": [660, 669],
        "sourceCode": "import { faMagnifyingGlass, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, IconButton, Input } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\n\nimport useDebounce from \"../../hooks/useDebounce\";\nimport { globalSearchStyles } from \"./tableStyles\";\n\nfunction GlobalFilter({ onGlobalFilterChange }) {\n  const [inputValue, setInputValue] = useState(\"\");\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  const handleInputChange = (e) => {\n    setInputValue(e.target.value);\n  };\n\n  const handleInputClean = () => {\n    setInputValue(\"\");\n  };\n\n  useEffect(\n    () => {\n      onGlobalFilterChange(debouncedInputValue);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [debouncedInputValue]\n  );\n\n  const classes = globalSearchStyles();\n\n  return (\n    <Grid container>\n      <Grid item xs={12}>\n        <Input\n          autoComplete=\"off\"\n          classes={{ root: classes.root }}\n          startAdornment={<FontAwesomeIcon icon={faMagnifyingGlass} />}\n          endAdornment={\n            !!inputValue && (\n              <IconButton onClick={handleInputClean}>\n                <FontAwesomeIcon icon={faXmark} />\n              </IconButton>\n            )\n          }\n          placeholder=\"Search\"\n          label=\"Filter\"\n          onChange={handleInputChange}\n          value={inputValue}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default GlobalFilter;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Phenotypes/Body.jsx" },
        "span": [6768, 6970],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport _ from \"lodash\";\nimport { Link, OtTable, SectionItem, TableDrawer, Tooltip } from \"ui\";\n\nimport { naLabel } from \"@ot/constants\";\nimport Description from \"./Description\";\n\nimport { definition } from \".\";\nimport PHENOTYPES_BODY_QUERY from \"./PhenotypesQuery.gql\";\n\nconst evidenceTypeDescription = {\n  IEA: \"Inferred from Electronic Annotations (IEA) are extracted by parsing the Clinical Features sections of the Online Mendelian Inheritance in Man resource\",\n  PCS: \"Published Clinical Study (PCS) are annotations extracted from articles in the medical literature with the PubMed ID of the published study (if available)\",\n  TAS: \"Traceable Author Statement (TAS) is used for information gleaned from knowledge bases such as OMIM or Orphanet that have derived the information from a published source\",\n};\n\nconst aspectDescription = {\n  P: \"Phenotypic abnormality\",\n  I: \"Inheritance\",\n  C: \"Onset and clinical course\",\n  M: \"Clinical modifier\",\n};\n\nconst columns = [\n  {\n    id: \"qualifierNot\",\n    label: \"Qualifier\",\n    exportLabel: \"qualifierNot\",\n    renderCell: ({ evidence }) => (evidence.qualifierNot ? \"NOT\" : \"\"),\n    filterValue: ({ evidence }) => (evidence.qualifierNot ? \"NOT\" : \"\"),\n    exportValue: ({ evidence }) => (evidence.qualifierNot ? \"NOT\" : \"\"),\n  },\n  {\n    id: \"phenotypeHPO\",\n    label: \"Phenotype\",\n    enableHiding: false,\n    renderCell: ({ phenotypeEFO, phenotypeHPO }) => {\n      let content;\n      if (phenotypeEFO?.id) {\n        content = (\n          <Link asyncTooltip to={`/disease/${phenotypeEFO.id}`}>\n            {phenotypeHPO.name}\n          </Link>\n        );\n      } else if (phenotypeHPO?.name) content = phenotypeHPO.name;\n      else content = naLabel;\n\n      return phenotypeHPO?.description ? (\n        <Tooltip title={`Description: ${phenotypeHPO.description}`} showHelpIcon>\n          {content}\n        </Tooltip>\n      ) : (\n        content\n      );\n    },\n    filterValue: (row) => row.phenotypeHPO.name,\n    exportValue: (row) => row.phenotypeHPO.name,\n  },\n  {\n    id: \"phenotypeHDOid\",\n    label: \"Phenotype ID\",\n    enableHiding: false,\n    renderCell: ({ phenotypeHPO }) => {\n      const id = phenotypeHPO?.id.replace(\"_\", \":\");\n      return (\n        <Link external to={`https://identifiers.org/ols/${id}`}>\n          {id}\n        </Link>\n      );\n    },\n    filterValue: (row) => row.phenotypeHPO.id.replace(\"_\", \":\"),\n    exportValue: (row) => row.phenotypeHPO.id.replace(\"_\", \":\"),\n  },\n  {\n    id: \"aspect\",\n    label: \"Aspect\",\n    renderCell: ({ evidence }) =>\n      evidence.aspect ? (\n        <Tooltip\n          title={`Sub-ontology: ${evidence.aspect} (${aspectDescription[evidence.aspect]})`}\n          showHelpIcon\n        >\n          {evidence.aspect}\n        </Tooltip>\n      ) : (\n        naLabel\n      ),\n    filterValue: (row) => row.evidence.aspect,\n    exportValue: (row) => row.evidence.aspect,\n  },\n  {\n    id: \"frequency\",\n    label: \"Frequency\",\n    renderCell: ({ evidence }) => {\n      if (evidence.frequencyHPO?.id && evidence.frequencyHPO.name)\n        return (\n          <Link\n            external\n            to={`https://identifiers.org/ols/${evidence.frequencyHPO.id.replace(\"_\", \":\")}`}\n          >\n            {evidence.frequencyHPO.name}\n          </Link>\n        );\n      if (evidence.frequencyHPO?.name) return evidence.frequencyHPO.name;\n      return naLabel;\n    },\n    filterValue: (row) => row.evidence.frequencyHPO?.name || naLabel,\n    exportValue: (row) => row.evidence.frequencyHPO?.name || naLabel,\n  },\n  {\n    id: \"onset\",\n    label: \"Onset\",\n    renderCell: ({ evidence }) =>\n      evidence.onset?.length > 0\n        ? evidence.onset.map((o) => (\n            <span key={o.id}>\n              <Link external to={`https://identifiers.org/ols/${o.id.replace(\"_\", \":\")}`}>\n                {o.name}\n              </Link>\n              <br />\n            </span>\n          ))\n        : naLabel,\n    filterValue: (row) => row.evidence.onset?.map((o) => o.name).join() || naLabel,\n    exportValue: (row) => row.evidence.onset?.map((o) => o.name).join() || naLabel,\n  },\n  {\n    id: \"modifier\",\n    label: \"Modifier\",\n    renderCell: ({ evidence }) =>\n      evidence.modifiers?.length > 0\n        ? evidence.modifiers.map((m) => (\n            <span key={m.id}>\n              <Link external to={`https://identifiers.org/ols/${m.id.replace(\"_\", \":\")}`}>\n                {m.name}\n              </Link>\n              <br />\n            </span>\n          ))\n        : naLabel,\n    filterValue: (row) => row.evidence.modifiers?.map((m) => m.name).join() || naLabel,\n    exportValue: (row) => row.evidence.modifiers?.map((m) => m.name).join() || naLabel,\n  },\n  {\n    id: \"sex\",\n    label: \"Sex\",\n    renderCell: ({ evidence }) => _.capitalize(evidence.sex) || naLabel,\n    filterValue: (row) => row.evidence.sex || naLabel,\n  },\n  {\n    id: \"evidenceType\",\n    label: \"Evidence\",\n    renderCell: ({ evidence }) =>\n      evidence.evidenceType ? (\n        <Tooltip title={evidenceTypeDescription[evidence.evidenceType?.toUpperCase()]} showHelpIcon>\n          {evidence.evidenceType}\n        </Tooltip>\n      ) : (\n        naLabel\n      ),\n    filterValue: (row) => row.evidence.evidenceType || naLabel,\n    exportValue: (row) => row.evidence.evidenceType || naLabel,\n  },\n  {\n    id: \"source\",\n    label: \"Source\",\n    renderCell: ({ evidence }) => evidence.resource || naLabel,\n    filterValue: (row) => row.evidence.resource || naLabel,\n    exportValue: (row) => row.evidence.resource || naLabel,\n  },\n  {\n    id: \"references\",\n    label: \"References\",\n    renderCell: ({ evidence }) => {\n      // no references\n      if (!evidence.references || evidence.references.length === 0) {\n        return naLabel;\n      }\n      // parse references\n      const refs = evidence.references.map((r) => ({\n        url: r.toUpperCase().startsWith(\"PMID:\")\n          ? `https://europepmc.org/search?query=EXT_ID:${r.split(\":\").pop()}`\n          : `https://hpo.jax.org/app/browse/disease/${r}`,\n        name: r,\n        group: \"References\",\n      }));\n      return <TableDrawer entries={refs} />;\n    },\n    filterValue: (row) => row.evidence.references?.map((r) => r).join() || naLabel,\n    exportValue: (row) => row.evidence.references?.map((r) => r).join() || naLabel,\n    // width: '9%',\n  },\n];\n\nfunction Body({ label: name, id: efoId, entity }) {\n  const variables = {\n    efoId,\n    index: 0,\n    size: 1000,\n  };\n\n  const request = useQuery(PHENOTYPES_BODY_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        // process the data\n        const rows = [];\n        request.data?.disease.phenotypes.rows.forEach((p) =>\n          p.evidence.forEach((e) => {\n            const p1 = { ...p };\n            p1.evidence = e;\n            rows.push(p1);\n          })\n        );\n\n        return (\n          <OtTable\n            columns={columns}\n            rows={rows}\n            dataDownloader\n            dataDownloaderFileStem={`${efoId}-phenotypes`}\n            showGlobalFilter\n            query={PHENOTYPES_BODY_QUERY.loc.source.body}\n            variables={variables}\n            loading={request.loading}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Phenotypes/Body.jsx" },
        "span": [6831, 6960],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport _ from \"lodash\";\nimport { Link, OtTable, SectionItem, TableDrawer, Tooltip } from \"ui\";\n\nimport { naLabel } from \"@ot/constants\";\nimport Description from \"./Description\";\n\nimport { definition } from \".\";\nimport PHENOTYPES_BODY_QUERY from \"./PhenotypesQuery.gql\";\n\nconst evidenceTypeDescription = {\n  IEA: \"Inferred from Electronic Annotations (IEA) are extracted by parsing the Clinical Features sections of the Online Mendelian Inheritance in Man resource\",\n  PCS: \"Published Clinical Study (PCS) are annotations extracted from articles in the medical literature with the PubMed ID of the published study (if available)\",\n  TAS: \"Traceable Author Statement (TAS) is used for information gleaned from knowledge bases such as OMIM or Orphanet that have derived the information from a published source\",\n};\n\nconst aspectDescription = {\n  P: \"Phenotypic abnormality\",\n  I: \"Inheritance\",\n  C: \"Onset and clinical course\",\n  M: \"Clinical modifier\",\n};\n\nconst columns = [\n  {\n    id: \"qualifierNot\",\n    label: \"Qualifier\",\n    exportLabel: \"qualifierNot\",\n    renderCell: ({ evidence }) => (evidence.qualifierNot ? \"NOT\" : \"\"),\n    filterValue: ({ evidence }) => (evidence.qualifierNot ? \"NOT\" : \"\"),\n    exportValue: ({ evidence }) => (evidence.qualifierNot ? \"NOT\" : \"\"),\n  },\n  {\n    id: \"phenotypeHPO\",\n    label: \"Phenotype\",\n    enableHiding: false,\n    renderCell: ({ phenotypeEFO, phenotypeHPO }) => {\n      let content;\n      if (phenotypeEFO?.id) {\n        content = (\n          <Link asyncTooltip to={`/disease/${phenotypeEFO.id}`}>\n            {phenotypeHPO.name}\n          </Link>\n        );\n      } else if (phenotypeHPO?.name) content = phenotypeHPO.name;\n      else content = naLabel;\n\n      return phenotypeHPO?.description ? (\n        <Tooltip title={`Description: ${phenotypeHPO.description}`} showHelpIcon>\n          {content}\n        </Tooltip>\n      ) : (\n        content\n      );\n    },\n    filterValue: (row) => row.phenotypeHPO.name,\n    exportValue: (row) => row.phenotypeHPO.name,\n  },\n  {\n    id: \"phenotypeHDOid\",\n    label: \"Phenotype ID\",\n    enableHiding: false,\n    renderCell: ({ phenotypeHPO }) => {\n      const id = phenotypeHPO?.id.replace(\"_\", \":\");\n      return (\n        <Link external to={`https://identifiers.org/ols/${id}`}>\n          {id}\n        </Link>\n      );\n    },\n    filterValue: (row) => row.phenotypeHPO.id.replace(\"_\", \":\"),\n    exportValue: (row) => row.phenotypeHPO.id.replace(\"_\", \":\"),\n  },\n  {\n    id: \"aspect\",\n    label: \"Aspect\",\n    renderCell: ({ evidence }) =>\n      evidence.aspect ? (\n        <Tooltip\n          title={`Sub-ontology: ${evidence.aspect} (${aspectDescription[evidence.aspect]})`}\n          showHelpIcon\n        >\n          {evidence.aspect}\n        </Tooltip>\n      ) : (\n        naLabel\n      ),\n    filterValue: (row) => row.evidence.aspect,\n    exportValue: (row) => row.evidence.aspect,\n  },\n  {\n    id: \"frequency\",\n    label: \"Frequency\",\n    renderCell: ({ evidence }) => {\n      if (evidence.frequencyHPO?.id && evidence.frequencyHPO.name)\n        return (\n          <Link\n            external\n            to={`https://identifiers.org/ols/${evidence.frequencyHPO.id.replace(\"_\", \":\")}`}\n          >\n            {evidence.frequencyHPO.name}\n          </Link>\n        );\n      if (evidence.frequencyHPO?.name) return evidence.frequencyHPO.name;\n      return naLabel;\n    },\n    filterValue: (row) => row.evidence.frequencyHPO?.name || naLabel,\n    exportValue: (row) => row.evidence.frequencyHPO?.name || naLabel,\n  },\n  {\n    id: \"onset\",\n    label: \"Onset\",\n    renderCell: ({ evidence }) =>\n      evidence.onset?.length > 0\n        ? evidence.onset.map((o) => (\n            <span key={o.id}>\n              <Link external to={`https://identifiers.org/ols/${o.id.replace(\"_\", \":\")}`}>\n                {o.name}\n              </Link>\n              <br />\n            </span>\n          ))\n        : naLabel,\n    filterValue: (row) => row.evidence.onset?.map((o) => o.name).join() || naLabel,\n    exportValue: (row) => row.evidence.onset?.map((o) => o.name).join() || naLabel,\n  },\n  {\n    id: \"modifier\",\n    label: \"Modifier\",\n    renderCell: ({ evidence }) =>\n      evidence.modifiers?.length > 0\n        ? evidence.modifiers.map((m) => (\n            <span key={m.id}>\n              <Link external to={`https://identifiers.org/ols/${m.id.replace(\"_\", \":\")}`}>\n                {m.name}\n              </Link>\n              <br />\n            </span>\n          ))\n        : naLabel,\n    filterValue: (row) => row.evidence.modifiers?.map((m) => m.name).join() || naLabel,\n    exportValue: (row) => row.evidence.modifiers?.map((m) => m.name).join() || naLabel,\n  },\n  {\n    id: \"sex\",\n    label: \"Sex\",\n    renderCell: ({ evidence }) => _.capitalize(evidence.sex) || naLabel,\n    filterValue: (row) => row.evidence.sex || naLabel,\n  },\n  {\n    id: \"evidenceType\",\n    label: \"Evidence\",\n    renderCell: ({ evidence }) =>\n      evidence.evidenceType ? (\n        <Tooltip title={evidenceTypeDescription[evidence.evidenceType?.toUpperCase()]} showHelpIcon>\n          {evidence.evidenceType}\n        </Tooltip>\n      ) : (\n        naLabel\n      ),\n    filterValue: (row) => row.evidence.evidenceType || naLabel,\n    exportValue: (row) => row.evidence.evidenceType || naLabel,\n  },\n  {\n    id: \"source\",\n    label: \"Source\",\n    renderCell: ({ evidence }) => evidence.resource || naLabel,\n    filterValue: (row) => row.evidence.resource || naLabel,\n    exportValue: (row) => row.evidence.resource || naLabel,\n  },\n  {\n    id: \"references\",\n    label: \"References\",\n    renderCell: ({ evidence }) => {\n      // no references\n      if (!evidence.references || evidence.references.length === 0) {\n        return naLabel;\n      }\n      // parse references\n      const refs = evidence.references.map((r) => ({\n        url: r.toUpperCase().startsWith(\"PMID:\")\n          ? `https://europepmc.org/search?query=EXT_ID:${r.split(\":\").pop()}`\n          : `https://hpo.jax.org/app/browse/disease/${r}`,\n        name: r,\n        group: \"References\",\n      }));\n      return <TableDrawer entries={refs} />;\n    },\n    filterValue: (row) => row.evidence.references?.map((r) => r).join() || naLabel,\n    exportValue: (row) => row.evidence.references?.map((r) => r).join() || naLabel,\n    // width: '9%',\n  },\n];\n\nfunction Body({ label: name, id: efoId, entity }) {\n  const variables = {\n    efoId,\n    index: 0,\n    size: 1000,\n  };\n\n  const request = useQuery(PHENOTYPES_BODY_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        // process the data\n        const rows = [];\n        request.data?.disease.phenotypes.rows.forEach((p) =>\n          p.evidence.forEach((e) => {\n            const p1 = { ...p };\n            p1.evidence = e;\n            rows.push(p1);\n          })\n        );\n\n        return (\n          <OtTable\n            columns={columns}\n            rows={rows}\n            dataDownloader\n            dataDownloaderFileStem={`${efoId}-phenotypes`}\n            showGlobalFilter\n            query={PHENOTYPES_BODY_QUERY.loc.source.body}\n            variables={variables}\n            loading={request.loading}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noUnsafeOptionalChaining",
      "severity": "error",
      "description": "Unsafe usage of optional chaining.",
      "message": [{ "elements": [], "content": "Unsafe usage of optional chaining." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "If it short-circuits with 'undefined' the evaluation will throw TypeError here:"
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3355, 3412],
              "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport _ from \"lodash\";\nimport { useState } from \"react\";\nimport { Link, PaginationActionsComplete, SectionItem, Table, useBatchDownloader } from \"ui\";\n\nimport { definition } from \".\";\nimport Description from \"./Description\";\n\nimport ADVERSE_EVENTS_QUERY from \"./AdverseEventsQuery.gql\";\n\nconst useStyles = makeStyles((theme) => ({\n  levelBarContainer: {\n    display: \"flex\",\n    alignItems: \"center\",\n  },\n  levelBar: {\n    backgroundColor: theme.palette.primary.main,\n    borderRight: `1px solid ${theme.palette.primary.main}`,\n    height: \"10px\",\n    marginRight: \"5px\",\n  },\n}));\n\nconst getColumns = (critVal, maxLlr, classes) => [\n  {\n    id: \"name\",\n    label: \"Adverse event (MedDRA)\",\n    renderCell: (d) =>\n      d.meddraCode ? (\n        <Link to={`https://identifiers.org/meddra:${d.meddraCode}`} external>\n          <Typography variant=\"body2\" noWrap display=\"block\" title={_.upperFirst(d.name)}>\n            {_.upperFirst(d.name)}\n          </Typography>\n        </Link>\n      ) : (\n        _.upperFirst(d.name)\n      ),\n    width: \"30%\",\n  },\n  {\n    id: \"count\",\n    label: \"Number of reported events\",\n    numeric: true,\n    width: \"25%\",\n  },\n  {\n    id: \"llr\",\n    label: `Log likelihood ratio (CV = ${critVal.toFixed(2)})`,\n    renderCell: (d) => {\n      const w = ((d.logLR / maxLlr) * 85).toFixed(2); // scale to max 85% of the width to allows space for label\n      return (\n        <div className={classes.levelBarContainer}>\n          <div\n            className={classes.levelBar}\n            style={{\n              width: `${w}%`,\n            }}\n          />\n          <div>{d.logLR.toFixed(2)}</div>\n        </div>\n      );\n    },\n    exportValue: (d) => d.logLR.toFixed(2),\n    width: \"45%\",\n  },\n];\n\nfunction Body({ id: chemblId, label: name, entity }) {\n  const classes = useStyles();\n  const variables = { chemblId };\n  const [page, setPage] = useState(0);\n  const [pageSize, setPageSize] = useState(10);\n  const { loading, error, data, fetchMore } = useQuery(ADVERSE_EVENTS_QUERY, {\n    variables,\n  });\n\n  // TODO: fetchMore doesn't seem to use gql/apollo caching\n  // but a new query causes flickering when rendering the table\n  function getData(newPage, size) {\n    fetchMore({\n      variables: {\n        index: newPage,\n        size,\n      },\n      updateQuery: (_prev, { fetchMoreResult }) => fetchMoreResult,\n    });\n  }\n\n  const handlePageChange = (newPage) => {\n    setPage(newPage);\n    getData(newPage, pageSize);\n  };\n\n  function handleRowsPerPageChange(newSize) {\n    setPageSize(newSize);\n    setPage(0);\n    getData(0, newSize);\n  }\n\n  const getAllAdverseEvents = useBatchDownloader(\n    ADVERSE_EVENTS_QUERY,\n    variables,\n    \"data.drug.adverseEvents\"\n  );\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={{ loading, error, data }}\n      entity={entity}\n      showContentLoading={true}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        // TODO: Change GraphQL schema to have a maxLlr field instead of having\n        // to get the first item of adverse events to get the largest llr since\n        // items are sorted in decreasing llr order.\n        const maxLlr = data?.drug.maxLlr.rows[0].logLR;\n        const { criticalValue, rows, count } = data?.drug.adverseEvents;\n\n        return (\n          <Table\n            dataDownloader\n            dataDownloaderRows={getAllAdverseEvents}\n            dataDownloaderFileStem={`${name}-adverse-events`}\n            loading={loading}\n            columns={getColumns(criticalValue, maxLlr, classes)}\n            rows={rows}\n            rowCount={count}\n            page={page}\n            onPageChange={handlePageChange}\n            ActionsComponent={PaginationActionsComplete}\n            fixed\n            pageSize={pageSize}\n            rowsPerPageOptions={[10, 25, 50, 100]}\n            onRowsPerPageChange={(newSize) => handleRowsPerPageChange(newSize)}\n            query={ADVERSE_EVENTS_QUERY.loc.source.body}\n            variables={variables}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/drug/AdverseEvents/Body.jsx" },
        "span": [3392, 3394],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport _ from \"lodash\";\nimport { useState } from \"react\";\nimport { Link, PaginationActionsComplete, SectionItem, Table, useBatchDownloader } from \"ui\";\n\nimport { definition } from \".\";\nimport Description from \"./Description\";\n\nimport ADVERSE_EVENTS_QUERY from \"./AdverseEventsQuery.gql\";\n\nconst useStyles = makeStyles((theme) => ({\n  levelBarContainer: {\n    display: \"flex\",\n    alignItems: \"center\",\n  },\n  levelBar: {\n    backgroundColor: theme.palette.primary.main,\n    borderRight: `1px solid ${theme.palette.primary.main}`,\n    height: \"10px\",\n    marginRight: \"5px\",\n  },\n}));\n\nconst getColumns = (critVal, maxLlr, classes) => [\n  {\n    id: \"name\",\n    label: \"Adverse event (MedDRA)\",\n    renderCell: (d) =>\n      d.meddraCode ? (\n        <Link to={`https://identifiers.org/meddra:${d.meddraCode}`} external>\n          <Typography variant=\"body2\" noWrap display=\"block\" title={_.upperFirst(d.name)}>\n            {_.upperFirst(d.name)}\n          </Typography>\n        </Link>\n      ) : (\n        _.upperFirst(d.name)\n      ),\n    width: \"30%\",\n  },\n  {\n    id: \"count\",\n    label: \"Number of reported events\",\n    numeric: true,\n    width: \"25%\",\n  },\n  {\n    id: \"llr\",\n    label: `Log likelihood ratio (CV = ${critVal.toFixed(2)})`,\n    renderCell: (d) => {\n      const w = ((d.logLR / maxLlr) * 85).toFixed(2); // scale to max 85% of the width to allows space for label\n      return (\n        <div className={classes.levelBarContainer}>\n          <div\n            className={classes.levelBar}\n            style={{\n              width: `${w}%`,\n            }}\n          />\n          <div>{d.logLR.toFixed(2)}</div>\n        </div>\n      );\n    },\n    exportValue: (d) => d.logLR.toFixed(2),\n    width: \"45%\",\n  },\n];\n\nfunction Body({ id: chemblId, label: name, entity }) {\n  const classes = useStyles();\n  const variables = { chemblId };\n  const [page, setPage] = useState(0);\n  const [pageSize, setPageSize] = useState(10);\n  const { loading, error, data, fetchMore } = useQuery(ADVERSE_EVENTS_QUERY, {\n    variables,\n  });\n\n  // TODO: fetchMore doesn't seem to use gql/apollo caching\n  // but a new query causes flickering when rendering the table\n  function getData(newPage, size) {\n    fetchMore({\n      variables: {\n        index: newPage,\n        size,\n      },\n      updateQuery: (_prev, { fetchMoreResult }) => fetchMoreResult,\n    });\n  }\n\n  const handlePageChange = (newPage) => {\n    setPage(newPage);\n    getData(newPage, pageSize);\n  };\n\n  function handleRowsPerPageChange(newSize) {\n    setPageSize(newSize);\n    setPage(0);\n    getData(0, newSize);\n  }\n\n  const getAllAdverseEvents = useBatchDownloader(\n    ADVERSE_EVENTS_QUERY,\n    variables,\n    \"data.drug.adverseEvents\"\n  );\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={{ loading, error, data }}\n      entity={entity}\n      showContentLoading={true}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        // TODO: Change GraphQL schema to have a maxLlr field instead of having\n        // to get the first item of adverse events to get the largest llr since\n        // items are sorted in decreasing llr order.\n        const maxLlr = data?.drug.maxLlr.rows[0].logLR;\n        const { criticalValue, rows, count } = data?.drug.adverseEvents;\n\n        return (\n          <Table\n            dataDownloader\n            dataDownloaderRows={getAllAdverseEvents}\n            dataDownloaderFileStem={`${name}-adverse-events`}\n            loading={loading}\n            columns={getColumns(criticalValue, maxLlr, classes)}\n            rows={rows}\n            rowCount={count}\n            page={page}\n            onPageChange={handlePageChange}\n            ActionsComponent={PaginationActionsComplete}\n            fixed\n            pageSize={pageSize}\n            rowsPerPageOptions={[10, 25, 50, 100]}\n            onRowsPerPageChange={(newSize) => handleRowsPerPageChange(newSize)}\n            query={ADVERSE_EVENTS_QUERY.loc.source.body}\n            variables={variables}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Ontology/OntologySubgraph.jsx" },
        "span": [706, 932],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { curveMonotoneX, line as d3Line, max } from \"d3\";\nimport { coordCenter, dagStratify, decrossTwoLayer, layeringLongestPath, sugiyama } from \"d3-dag\";\nimport { withContentRect } from \"react-measure\";\nimport { Link } from \"react-router-dom\";\nimport OntologyTooltip from \"./OntologyTooltip\";\n\nconst useStyles = makeStyles({\n  labelText: {\n    \"&:hover\": { fontWeight: \"700\" },\n  },\n});\n\nfunction getAncestors(efoId, idToDisease) {\n  const ancestors = [{ ...idToDisease[efoId], nodeType: \"anchor\" }];\n  const queue = [efoId];\n  const visited = new Set([efoId]);\n\n  while (queue.length > 0) {\n    const id = queue.shift();\n    const node = idToDisease[id];\n\n    node.parentIds.forEach((parentId) => {\n      if (!visited.has(parentId)) {\n        ancestors.push({ ...idToDisease[parentId], nodeType: \"ancestor\" });\n        queue.push(parentId);\n        visited.add(parentId);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction buildDagData(efoId, efo, idToDisease) {\n  const dag = [];\n\n  if (!efo) return dag;\n\n  // find direct children of efoId\n  efo.forEach((disease) => {\n    if (disease.parentIds.includes(efoId)) {\n      dag.push({\n        id: disease.id,\n        name: disease.name,\n        parentIds: [efoId],\n        nodeType: \"child\",\n      });\n    }\n  });\n\n  const ancestors = getAncestors(efoId, idToDisease); // find ancestors\n\n  ancestors.forEach((ancestor) => {\n    dag.push(ancestor);\n  });\n\n  return dag;\n}\n\nconst layering = layeringLongestPath();\nconst decross = decrossTwoLayer();\nconst coord = coordCenter();\n\nconst helperLayout = sugiyama().layering(layering).decross(decross).coord(coord);\n\nfunction textWithEllipsis(text, threshold) {\n  return text.length <= threshold ? text : `${text.slice(0, threshold)}...`;\n}\n\nfunction getMaxLayerCount(dag) {\n  helperLayout(dag);\n\n  const counts = {};\n  let maxCount = Number.NEGATIVE_INFINITY;\n\n  dag.descendants().forEach((node) => {\n    const { layer } = node;\n\n    if (counts[layer]) {\n      counts[layer] += 1;\n    } else {\n      counts[layer] = 1;\n    }\n\n    if (counts[layer] > maxCount) {\n      maxCount = counts[layer];\n    }\n  });\n\n  dag.links().forEach((link) => {\n    link.points.forEach((_, i) => {\n      const index = link.source.layer + i;\n      counts[index] += 1;\n      if (counts[index] > maxCount) {\n        maxCount = counts[index];\n      }\n    });\n  });\n\n  return maxCount;\n}\n\nconst colorMap = {\n  anchor: \"#ff6350\",\n  ancestor: \"#3489ca\",\n  child: \"#85b8df\",\n};\nconst diameter = 12;\nconst radius = diameter / 2;\nconst yOffset = 100;\nconst line = d3Line().curve(curveMonotoneX);\n\nfunction OntologySubgraph({ efoId, efo, name, idToDisease, measureRef, contentRect }) {\n  const classes = useStyles();\n  const { width } = contentRect.bounds;\n  if (!efo) return null;\n  const dagData = buildDagData(efoId, efo, idToDisease);\n  const dag = dagStratify()(dagData);\n  const maxLayerCount = getMaxLayerCount(dag);\n  const height = maxLayerCount * 6;\n  const layout = sugiyama()\n    .layering(layering)\n    .decross(decross)\n    .coord(coord)\n    .nodeSize(() => {\n      const base = diameter + 3;\n      return [base, base];\n    })\n    .size([height, width]);\n\n  layout(dag);\n  const nodes = dag.descendants();\n  const links = dag.links();\n  const separation = width / (max(nodes, (d) => d.layer) + 1);\n  const xOffset = separation / 2 - radius;\n  const textLimit = separation / 8;\n\n  line.x((d) => d.y - xOffset).y((d) => d.x);\n\n  return (\n    <div ref={measureRef}>\n      {width ? (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          width={width}\n          height={height + yOffset}\n        >\n          <defs>\n            <marker\n              id=\"arrowhead\"\n              orient=\"auto\"\n              markerWidth=\"2\"\n              markerHeight=\"4\"\n              refX=\"0.1\"\n              refY=\"2\"\n            >\n              <path d=\"M0,0 V4 L2,2 Z\" fill=\"#5a5f5f\" />\n            </marker>\n          </defs>\n          <g transform=\"translate(0, 10)\">\n            <rect\n              x=\"4\"\n              y=\"11\"\n              width={diameter}\n              height={diameter}\n              fill=\"none\"\n              stroke=\"#e0e0e0\"\n              strokeWidth=\"2\"\n            />\n            <text x=\"20\" y=\"17\" fill=\"#5a5f5f\" dominantBaseline=\"middle\" fontSize=\"12\">\n              therapeutic area\n            </text>\n            <circle cx=\"10\" cy=\"34\" r={radius} fill=\"none\" stroke=\"#e0e0e0\" strokeWidth=\"2\" />\n            <text fill=\"#5a5f5f\" x=\"20\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              disease\n            </text>\n            <circle cx=\"150\" cy=\"0\" r={radius} fill={colorMap.child} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"0\" dominantBaseline=\"middle\" fontSize=\"12\">\n              descendants\n            </text>\n            <circle cx=\"150\" cy=\"17\" r={radius} fill={colorMap.ancestor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"17\" dominantBaseline=\"middle\" fontSize=\"12\">\n              ancestors\n            </text>\n            <circle cx=\"150\" cy=\"34\" r={radius} fill={colorMap.anchor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              {name}\n            </text>\n          </g>\n          <g transform={`translate(${width / 2}, 70)`}>\n            <text x=\"-160\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              GENERAL\n            </text>\n            <text x=\"100\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              SPECIFIC\n            </text>\n            <path\n              markerEnd=\"url(#arrowhead)\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n              stroke=\"#5a5f5f\"\n              d=\"M-80,0 L80,0\"\n            />\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {links.map(({ points, source, target }) => (\n              <path\n                key={`${source.id}-${target.id}`}\n                d={line(points)}\n                fill=\"none\"\n                strokeWidth=\"2\"\n                stroke=\"#eeeeee\"\n              />\n            ))}\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {nodes.map((node) => (\n              <Link to={`/disease/${node.data.id}`} className={classes.labelText} key={node.id}>\n                <OntologyTooltip title={`${node.data.name || \"No name\"} | ID: ${node.id}`}>\n                  <g>\n                    <text\n                      x={node.y - xOffset}\n                      y={node.x}\n                      dx=\"9\"\n                      fontSize=\"12\"\n                      dominantBaseline=\"middle\"\n                      fill=\"#5a5f5f\"\n                      style={{ cursor: \"pointer\" }}\n                    >\n                      <title>{node.data.name}</title>\n                      {textWithEllipsis(node.data.name || \"No name\", textLimit)}\n                    </text>\n\n                    {node.data.parentIds.length === 0 ? (\n                      <rect\n                        x={node.y - radius - xOffset}\n                        y={node.x - radius}\n                        width={diameter}\n                        height={diameter}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    ) : (\n                      <circle\n                        cx={node.y - xOffset}\n                        cy={node.x}\n                        r={radius}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    )}\n                  </g>\n                </OntologyTooltip>\n              </Link>\n            ))}\n          </g>\n        </svg>\n      ) : null}\n    </div>\n  );\n}\n\nexport default withContentRect(\"bounds\")(OntologySubgraph);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Ontology/OntologySubgraph.jsx" },
        "span": [1092, 1308],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { curveMonotoneX, line as d3Line, max } from \"d3\";\nimport { coordCenter, dagStratify, decrossTwoLayer, layeringLongestPath, sugiyama } from \"d3-dag\";\nimport { withContentRect } from \"react-measure\";\nimport { Link } from \"react-router-dom\";\nimport OntologyTooltip from \"./OntologyTooltip\";\n\nconst useStyles = makeStyles({\n  labelText: {\n    \"&:hover\": { fontWeight: \"700\" },\n  },\n});\n\nfunction getAncestors(efoId, idToDisease) {\n  const ancestors = [{ ...idToDisease[efoId], nodeType: \"anchor\" }];\n  const queue = [efoId];\n  const visited = new Set([efoId]);\n\n  while (queue.length > 0) {\n    const id = queue.shift();\n    const node = idToDisease[id];\n\n    node.parentIds.forEach((parentId) => {\n      if (!visited.has(parentId)) {\n        ancestors.push({ ...idToDisease[parentId], nodeType: \"ancestor\" });\n        queue.push(parentId);\n        visited.add(parentId);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction buildDagData(efoId, efo, idToDisease) {\n  const dag = [];\n\n  if (!efo) return dag;\n\n  // find direct children of efoId\n  efo.forEach((disease) => {\n    if (disease.parentIds.includes(efoId)) {\n      dag.push({\n        id: disease.id,\n        name: disease.name,\n        parentIds: [efoId],\n        nodeType: \"child\",\n      });\n    }\n  });\n\n  const ancestors = getAncestors(efoId, idToDisease); // find ancestors\n\n  ancestors.forEach((ancestor) => {\n    dag.push(ancestor);\n  });\n\n  return dag;\n}\n\nconst layering = layeringLongestPath();\nconst decross = decrossTwoLayer();\nconst coord = coordCenter();\n\nconst helperLayout = sugiyama().layering(layering).decross(decross).coord(coord);\n\nfunction textWithEllipsis(text, threshold) {\n  return text.length <= threshold ? text : `${text.slice(0, threshold)}...`;\n}\n\nfunction getMaxLayerCount(dag) {\n  helperLayout(dag);\n\n  const counts = {};\n  let maxCount = Number.NEGATIVE_INFINITY;\n\n  dag.descendants().forEach((node) => {\n    const { layer } = node;\n\n    if (counts[layer]) {\n      counts[layer] += 1;\n    } else {\n      counts[layer] = 1;\n    }\n\n    if (counts[layer] > maxCount) {\n      maxCount = counts[layer];\n    }\n  });\n\n  dag.links().forEach((link) => {\n    link.points.forEach((_, i) => {\n      const index = link.source.layer + i;\n      counts[index] += 1;\n      if (counts[index] > maxCount) {\n        maxCount = counts[index];\n      }\n    });\n  });\n\n  return maxCount;\n}\n\nconst colorMap = {\n  anchor: \"#ff6350\",\n  ancestor: \"#3489ca\",\n  child: \"#85b8df\",\n};\nconst diameter = 12;\nconst radius = diameter / 2;\nconst yOffset = 100;\nconst line = d3Line().curve(curveMonotoneX);\n\nfunction OntologySubgraph({ efoId, efo, name, idToDisease, measureRef, contentRect }) {\n  const classes = useStyles();\n  const { width } = contentRect.bounds;\n  if (!efo) return null;\n  const dagData = buildDagData(efoId, efo, idToDisease);\n  const dag = dagStratify()(dagData);\n  const maxLayerCount = getMaxLayerCount(dag);\n  const height = maxLayerCount * 6;\n  const layout = sugiyama()\n    .layering(layering)\n    .decross(decross)\n    .coord(coord)\n    .nodeSize(() => {\n      const base = diameter + 3;\n      return [base, base];\n    })\n    .size([height, width]);\n\n  layout(dag);\n  const nodes = dag.descendants();\n  const links = dag.links();\n  const separation = width / (max(nodes, (d) => d.layer) + 1);\n  const xOffset = separation / 2 - radius;\n  const textLimit = separation / 8;\n\n  line.x((d) => d.y - xOffset).y((d) => d.x);\n\n  return (\n    <div ref={measureRef}>\n      {width ? (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          width={width}\n          height={height + yOffset}\n        >\n          <defs>\n            <marker\n              id=\"arrowhead\"\n              orient=\"auto\"\n              markerWidth=\"2\"\n              markerHeight=\"4\"\n              refX=\"0.1\"\n              refY=\"2\"\n            >\n              <path d=\"M0,0 V4 L2,2 Z\" fill=\"#5a5f5f\" />\n            </marker>\n          </defs>\n          <g transform=\"translate(0, 10)\">\n            <rect\n              x=\"4\"\n              y=\"11\"\n              width={diameter}\n              height={diameter}\n              fill=\"none\"\n              stroke=\"#e0e0e0\"\n              strokeWidth=\"2\"\n            />\n            <text x=\"20\" y=\"17\" fill=\"#5a5f5f\" dominantBaseline=\"middle\" fontSize=\"12\">\n              therapeutic area\n            </text>\n            <circle cx=\"10\" cy=\"34\" r={radius} fill=\"none\" stroke=\"#e0e0e0\" strokeWidth=\"2\" />\n            <text fill=\"#5a5f5f\" x=\"20\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              disease\n            </text>\n            <circle cx=\"150\" cy=\"0\" r={radius} fill={colorMap.child} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"0\" dominantBaseline=\"middle\" fontSize=\"12\">\n              descendants\n            </text>\n            <circle cx=\"150\" cy=\"17\" r={radius} fill={colorMap.ancestor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"17\" dominantBaseline=\"middle\" fontSize=\"12\">\n              ancestors\n            </text>\n            <circle cx=\"150\" cy=\"34\" r={radius} fill={colorMap.anchor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              {name}\n            </text>\n          </g>\n          <g transform={`translate(${width / 2}, 70)`}>\n            <text x=\"-160\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              GENERAL\n            </text>\n            <text x=\"100\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              SPECIFIC\n            </text>\n            <path\n              markerEnd=\"url(#arrowhead)\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n              stroke=\"#5a5f5f\"\n              d=\"M-80,0 L80,0\"\n            />\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {links.map(({ points, source, target }) => (\n              <path\n                key={`${source.id}-${target.id}`}\n                d={line(points)}\n                fill=\"none\"\n                strokeWidth=\"2\"\n                stroke=\"#eeeeee\"\n              />\n            ))}\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {nodes.map((node) => (\n              <Link to={`/disease/${node.data.id}`} className={classes.labelText} key={node.id}>\n                <OntologyTooltip title={`${node.data.name || \"No name\"} | ID: ${node.id}`}>\n                  <g>\n                    <text\n                      x={node.y - xOffset}\n                      y={node.x}\n                      dx=\"9\"\n                      fontSize=\"12\"\n                      dominantBaseline=\"middle\"\n                      fill=\"#5a5f5f\"\n                      style={{ cursor: \"pointer\" }}\n                    >\n                      <title>{node.data.name}</title>\n                      {textWithEllipsis(node.data.name || \"No name\", textLimit)}\n                    </text>\n\n                    {node.data.parentIds.length === 0 ? (\n                      <rect\n                        x={node.y - radius - xOffset}\n                        y={node.x - radius}\n                        width={diameter}\n                        height={diameter}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    ) : (\n                      <circle\n                        cx={node.y - xOffset}\n                        cy={node.x}\n                        r={radius}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    )}\n                  </g>\n                </OntologyTooltip>\n              </Link>\n            ))}\n          </g>\n        </svg>\n      ) : null}\n    </div>\n  );\n}\n\nexport default withContentRect(\"bounds\")(OntologySubgraph);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Ontology/OntologySubgraph.jsx" },
        "span": [1386, 1448],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { curveMonotoneX, line as d3Line, max } from \"d3\";\nimport { coordCenter, dagStratify, decrossTwoLayer, layeringLongestPath, sugiyama } from \"d3-dag\";\nimport { withContentRect } from \"react-measure\";\nimport { Link } from \"react-router-dom\";\nimport OntologyTooltip from \"./OntologyTooltip\";\n\nconst useStyles = makeStyles({\n  labelText: {\n    \"&:hover\": { fontWeight: \"700\" },\n  },\n});\n\nfunction getAncestors(efoId, idToDisease) {\n  const ancestors = [{ ...idToDisease[efoId], nodeType: \"anchor\" }];\n  const queue = [efoId];\n  const visited = new Set([efoId]);\n\n  while (queue.length > 0) {\n    const id = queue.shift();\n    const node = idToDisease[id];\n\n    node.parentIds.forEach((parentId) => {\n      if (!visited.has(parentId)) {\n        ancestors.push({ ...idToDisease[parentId], nodeType: \"ancestor\" });\n        queue.push(parentId);\n        visited.add(parentId);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction buildDagData(efoId, efo, idToDisease) {\n  const dag = [];\n\n  if (!efo) return dag;\n\n  // find direct children of efoId\n  efo.forEach((disease) => {\n    if (disease.parentIds.includes(efoId)) {\n      dag.push({\n        id: disease.id,\n        name: disease.name,\n        parentIds: [efoId],\n        nodeType: \"child\",\n      });\n    }\n  });\n\n  const ancestors = getAncestors(efoId, idToDisease); // find ancestors\n\n  ancestors.forEach((ancestor) => {\n    dag.push(ancestor);\n  });\n\n  return dag;\n}\n\nconst layering = layeringLongestPath();\nconst decross = decrossTwoLayer();\nconst coord = coordCenter();\n\nconst helperLayout = sugiyama().layering(layering).decross(decross).coord(coord);\n\nfunction textWithEllipsis(text, threshold) {\n  return text.length <= threshold ? text : `${text.slice(0, threshold)}...`;\n}\n\nfunction getMaxLayerCount(dag) {\n  helperLayout(dag);\n\n  const counts = {};\n  let maxCount = Number.NEGATIVE_INFINITY;\n\n  dag.descendants().forEach((node) => {\n    const { layer } = node;\n\n    if (counts[layer]) {\n      counts[layer] += 1;\n    } else {\n      counts[layer] = 1;\n    }\n\n    if (counts[layer] > maxCount) {\n      maxCount = counts[layer];\n    }\n  });\n\n  dag.links().forEach((link) => {\n    link.points.forEach((_, i) => {\n      const index = link.source.layer + i;\n      counts[index] += 1;\n      if (counts[index] > maxCount) {\n        maxCount = counts[index];\n      }\n    });\n  });\n\n  return maxCount;\n}\n\nconst colorMap = {\n  anchor: \"#ff6350\",\n  ancestor: \"#3489ca\",\n  child: \"#85b8df\",\n};\nconst diameter = 12;\nconst radius = diameter / 2;\nconst yOffset = 100;\nconst line = d3Line().curve(curveMonotoneX);\n\nfunction OntologySubgraph({ efoId, efo, name, idToDisease, measureRef, contentRect }) {\n  const classes = useStyles();\n  const { width } = contentRect.bounds;\n  if (!efo) return null;\n  const dagData = buildDagData(efoId, efo, idToDisease);\n  const dag = dagStratify()(dagData);\n  const maxLayerCount = getMaxLayerCount(dag);\n  const height = maxLayerCount * 6;\n  const layout = sugiyama()\n    .layering(layering)\n    .decross(decross)\n    .coord(coord)\n    .nodeSize(() => {\n      const base = diameter + 3;\n      return [base, base];\n    })\n    .size([height, width]);\n\n  layout(dag);\n  const nodes = dag.descendants();\n  const links = dag.links();\n  const separation = width / (max(nodes, (d) => d.layer) + 1);\n  const xOffset = separation / 2 - radius;\n  const textLimit = separation / 8;\n\n  line.x((d) => d.y - xOffset).y((d) => d.x);\n\n  return (\n    <div ref={measureRef}>\n      {width ? (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          width={width}\n          height={height + yOffset}\n        >\n          <defs>\n            <marker\n              id=\"arrowhead\"\n              orient=\"auto\"\n              markerWidth=\"2\"\n              markerHeight=\"4\"\n              refX=\"0.1\"\n              refY=\"2\"\n            >\n              <path d=\"M0,0 V4 L2,2 Z\" fill=\"#5a5f5f\" />\n            </marker>\n          </defs>\n          <g transform=\"translate(0, 10)\">\n            <rect\n              x=\"4\"\n              y=\"11\"\n              width={diameter}\n              height={diameter}\n              fill=\"none\"\n              stroke=\"#e0e0e0\"\n              strokeWidth=\"2\"\n            />\n            <text x=\"20\" y=\"17\" fill=\"#5a5f5f\" dominantBaseline=\"middle\" fontSize=\"12\">\n              therapeutic area\n            </text>\n            <circle cx=\"10\" cy=\"34\" r={radius} fill=\"none\" stroke=\"#e0e0e0\" strokeWidth=\"2\" />\n            <text fill=\"#5a5f5f\" x=\"20\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              disease\n            </text>\n            <circle cx=\"150\" cy=\"0\" r={radius} fill={colorMap.child} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"0\" dominantBaseline=\"middle\" fontSize=\"12\">\n              descendants\n            </text>\n            <circle cx=\"150\" cy=\"17\" r={radius} fill={colorMap.ancestor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"17\" dominantBaseline=\"middle\" fontSize=\"12\">\n              ancestors\n            </text>\n            <circle cx=\"150\" cy=\"34\" r={radius} fill={colorMap.anchor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              {name}\n            </text>\n          </g>\n          <g transform={`translate(${width / 2}, 70)`}>\n            <text x=\"-160\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              GENERAL\n            </text>\n            <text x=\"100\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              SPECIFIC\n            </text>\n            <path\n              markerEnd=\"url(#arrowhead)\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n              stroke=\"#5a5f5f\"\n              d=\"M-80,0 L80,0\"\n            />\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {links.map(({ points, source, target }) => (\n              <path\n                key={`${source.id}-${target.id}`}\n                d={line(points)}\n                fill=\"none\"\n                strokeWidth=\"2\"\n                stroke=\"#eeeeee\"\n              />\n            ))}\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {nodes.map((node) => (\n              <Link to={`/disease/${node.data.id}`} className={classes.labelText} key={node.id}>\n                <OntologyTooltip title={`${node.data.name || \"No name\"} | ID: ${node.id}`}>\n                  <g>\n                    <text\n                      x={node.y - xOffset}\n                      y={node.x}\n                      dx=\"9\"\n                      fontSize=\"12\"\n                      dominantBaseline=\"middle\"\n                      fill=\"#5a5f5f\"\n                      style={{ cursor: \"pointer\" }}\n                    >\n                      <title>{node.data.name}</title>\n                      {textWithEllipsis(node.data.name || \"No name\", textLimit)}\n                    </text>\n\n                    {node.data.parentIds.length === 0 ? (\n                      <rect\n                        x={node.y - radius - xOffset}\n                        y={node.x - radius}\n                        width={diameter}\n                        height={diameter}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    ) : (\n                      <circle\n                        cx={node.y - xOffset}\n                        cy={node.x}\n                        r={radius}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    )}\n                  </g>\n                </OntologyTooltip>\n              </Link>\n            ))}\n          </g>\n        </svg>\n      ) : null}\n    </div>\n  );\n}\n\nexport default withContentRect(\"bounds\")(OntologySubgraph);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Ontology/OntologySubgraph.jsx" },
        "span": [1903, 2144],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { curveMonotoneX, line as d3Line, max } from \"d3\";\nimport { coordCenter, dagStratify, decrossTwoLayer, layeringLongestPath, sugiyama } from \"d3-dag\";\nimport { withContentRect } from \"react-measure\";\nimport { Link } from \"react-router-dom\";\nimport OntologyTooltip from \"./OntologyTooltip\";\n\nconst useStyles = makeStyles({\n  labelText: {\n    \"&:hover\": { fontWeight: \"700\" },\n  },\n});\n\nfunction getAncestors(efoId, idToDisease) {\n  const ancestors = [{ ...idToDisease[efoId], nodeType: \"anchor\" }];\n  const queue = [efoId];\n  const visited = new Set([efoId]);\n\n  while (queue.length > 0) {\n    const id = queue.shift();\n    const node = idToDisease[id];\n\n    node.parentIds.forEach((parentId) => {\n      if (!visited.has(parentId)) {\n        ancestors.push({ ...idToDisease[parentId], nodeType: \"ancestor\" });\n        queue.push(parentId);\n        visited.add(parentId);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction buildDagData(efoId, efo, idToDisease) {\n  const dag = [];\n\n  if (!efo) return dag;\n\n  // find direct children of efoId\n  efo.forEach((disease) => {\n    if (disease.parentIds.includes(efoId)) {\n      dag.push({\n        id: disease.id,\n        name: disease.name,\n        parentIds: [efoId],\n        nodeType: \"child\",\n      });\n    }\n  });\n\n  const ancestors = getAncestors(efoId, idToDisease); // find ancestors\n\n  ancestors.forEach((ancestor) => {\n    dag.push(ancestor);\n  });\n\n  return dag;\n}\n\nconst layering = layeringLongestPath();\nconst decross = decrossTwoLayer();\nconst coord = coordCenter();\n\nconst helperLayout = sugiyama().layering(layering).decross(decross).coord(coord);\n\nfunction textWithEllipsis(text, threshold) {\n  return text.length <= threshold ? text : `${text.slice(0, threshold)}...`;\n}\n\nfunction getMaxLayerCount(dag) {\n  helperLayout(dag);\n\n  const counts = {};\n  let maxCount = Number.NEGATIVE_INFINITY;\n\n  dag.descendants().forEach((node) => {\n    const { layer } = node;\n\n    if (counts[layer]) {\n      counts[layer] += 1;\n    } else {\n      counts[layer] = 1;\n    }\n\n    if (counts[layer] > maxCount) {\n      maxCount = counts[layer];\n    }\n  });\n\n  dag.links().forEach((link) => {\n    link.points.forEach((_, i) => {\n      const index = link.source.layer + i;\n      counts[index] += 1;\n      if (counts[index] > maxCount) {\n        maxCount = counts[index];\n      }\n    });\n  });\n\n  return maxCount;\n}\n\nconst colorMap = {\n  anchor: \"#ff6350\",\n  ancestor: \"#3489ca\",\n  child: \"#85b8df\",\n};\nconst diameter = 12;\nconst radius = diameter / 2;\nconst yOffset = 100;\nconst line = d3Line().curve(curveMonotoneX);\n\nfunction OntologySubgraph({ efoId, efo, name, idToDisease, measureRef, contentRect }) {\n  const classes = useStyles();\n  const { width } = contentRect.bounds;\n  if (!efo) return null;\n  const dagData = buildDagData(efoId, efo, idToDisease);\n  const dag = dagStratify()(dagData);\n  const maxLayerCount = getMaxLayerCount(dag);\n  const height = maxLayerCount * 6;\n  const layout = sugiyama()\n    .layering(layering)\n    .decross(decross)\n    .coord(coord)\n    .nodeSize(() => {\n      const base = diameter + 3;\n      return [base, base];\n    })\n    .size([height, width]);\n\n  layout(dag);\n  const nodes = dag.descendants();\n  const links = dag.links();\n  const separation = width / (max(nodes, (d) => d.layer) + 1);\n  const xOffset = separation / 2 - radius;\n  const textLimit = separation / 8;\n\n  line.x((d) => d.y - xOffset).y((d) => d.x);\n\n  return (\n    <div ref={measureRef}>\n      {width ? (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          width={width}\n          height={height + yOffset}\n        >\n          <defs>\n            <marker\n              id=\"arrowhead\"\n              orient=\"auto\"\n              markerWidth=\"2\"\n              markerHeight=\"4\"\n              refX=\"0.1\"\n              refY=\"2\"\n            >\n              <path d=\"M0,0 V4 L2,2 Z\" fill=\"#5a5f5f\" />\n            </marker>\n          </defs>\n          <g transform=\"translate(0, 10)\">\n            <rect\n              x=\"4\"\n              y=\"11\"\n              width={diameter}\n              height={diameter}\n              fill=\"none\"\n              stroke=\"#e0e0e0\"\n              strokeWidth=\"2\"\n            />\n            <text x=\"20\" y=\"17\" fill=\"#5a5f5f\" dominantBaseline=\"middle\" fontSize=\"12\">\n              therapeutic area\n            </text>\n            <circle cx=\"10\" cy=\"34\" r={radius} fill=\"none\" stroke=\"#e0e0e0\" strokeWidth=\"2\" />\n            <text fill=\"#5a5f5f\" x=\"20\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              disease\n            </text>\n            <circle cx=\"150\" cy=\"0\" r={radius} fill={colorMap.child} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"0\" dominantBaseline=\"middle\" fontSize=\"12\">\n              descendants\n            </text>\n            <circle cx=\"150\" cy=\"17\" r={radius} fill={colorMap.ancestor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"17\" dominantBaseline=\"middle\" fontSize=\"12\">\n              ancestors\n            </text>\n            <circle cx=\"150\" cy=\"34\" r={radius} fill={colorMap.anchor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              {name}\n            </text>\n          </g>\n          <g transform={`translate(${width / 2}, 70)`}>\n            <text x=\"-160\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              GENERAL\n            </text>\n            <text x=\"100\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              SPECIFIC\n            </text>\n            <path\n              markerEnd=\"url(#arrowhead)\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n              stroke=\"#5a5f5f\"\n              d=\"M-80,0 L80,0\"\n            />\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {links.map(({ points, source, target }) => (\n              <path\n                key={`${source.id}-${target.id}`}\n                d={line(points)}\n                fill=\"none\"\n                strokeWidth=\"2\"\n                stroke=\"#eeeeee\"\n              />\n            ))}\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {nodes.map((node) => (\n              <Link to={`/disease/${node.data.id}`} className={classes.labelText} key={node.id}>\n                <OntologyTooltip title={`${node.data.name || \"No name\"} | ID: ${node.id}`}>\n                  <g>\n                    <text\n                      x={node.y - xOffset}\n                      y={node.x}\n                      dx=\"9\"\n                      fontSize=\"12\"\n                      dominantBaseline=\"middle\"\n                      fill=\"#5a5f5f\"\n                      style={{ cursor: \"pointer\" }}\n                    >\n                      <title>{node.data.name}</title>\n                      {textWithEllipsis(node.data.name || \"No name\", textLimit)}\n                    </text>\n\n                    {node.data.parentIds.length === 0 ? (\n                      <rect\n                        x={node.y - radius - xOffset}\n                        y={node.x - radius}\n                        width={diameter}\n                        height={diameter}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    ) : (\n                      <circle\n                        cx={node.y - xOffset}\n                        cy={node.x}\n                        r={radius}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    )}\n                  </g>\n                </OntologyTooltip>\n              </Link>\n            ))}\n          </g>\n        </svg>\n      ) : null}\n    </div>\n  );\n}\n\nexport default withContentRect(\"bounds\")(OntologySubgraph);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Ontology/OntologySubgraph.jsx" },
        "span": [2149, 2378],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { curveMonotoneX, line as d3Line, max } from \"d3\";\nimport { coordCenter, dagStratify, decrossTwoLayer, layeringLongestPath, sugiyama } from \"d3-dag\";\nimport { withContentRect } from \"react-measure\";\nimport { Link } from \"react-router-dom\";\nimport OntologyTooltip from \"./OntologyTooltip\";\n\nconst useStyles = makeStyles({\n  labelText: {\n    \"&:hover\": { fontWeight: \"700\" },\n  },\n});\n\nfunction getAncestors(efoId, idToDisease) {\n  const ancestors = [{ ...idToDisease[efoId], nodeType: \"anchor\" }];\n  const queue = [efoId];\n  const visited = new Set([efoId]);\n\n  while (queue.length > 0) {\n    const id = queue.shift();\n    const node = idToDisease[id];\n\n    node.parentIds.forEach((parentId) => {\n      if (!visited.has(parentId)) {\n        ancestors.push({ ...idToDisease[parentId], nodeType: \"ancestor\" });\n        queue.push(parentId);\n        visited.add(parentId);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction buildDagData(efoId, efo, idToDisease) {\n  const dag = [];\n\n  if (!efo) return dag;\n\n  // find direct children of efoId\n  efo.forEach((disease) => {\n    if (disease.parentIds.includes(efoId)) {\n      dag.push({\n        id: disease.id,\n        name: disease.name,\n        parentIds: [efoId],\n        nodeType: \"child\",\n      });\n    }\n  });\n\n  const ancestors = getAncestors(efoId, idToDisease); // find ancestors\n\n  ancestors.forEach((ancestor) => {\n    dag.push(ancestor);\n  });\n\n  return dag;\n}\n\nconst layering = layeringLongestPath();\nconst decross = decrossTwoLayer();\nconst coord = coordCenter();\n\nconst helperLayout = sugiyama().layering(layering).decross(decross).coord(coord);\n\nfunction textWithEllipsis(text, threshold) {\n  return text.length <= threshold ? text : `${text.slice(0, threshold)}...`;\n}\n\nfunction getMaxLayerCount(dag) {\n  helperLayout(dag);\n\n  const counts = {};\n  let maxCount = Number.NEGATIVE_INFINITY;\n\n  dag.descendants().forEach((node) => {\n    const { layer } = node;\n\n    if (counts[layer]) {\n      counts[layer] += 1;\n    } else {\n      counts[layer] = 1;\n    }\n\n    if (counts[layer] > maxCount) {\n      maxCount = counts[layer];\n    }\n  });\n\n  dag.links().forEach((link) => {\n    link.points.forEach((_, i) => {\n      const index = link.source.layer + i;\n      counts[index] += 1;\n      if (counts[index] > maxCount) {\n        maxCount = counts[index];\n      }\n    });\n  });\n\n  return maxCount;\n}\n\nconst colorMap = {\n  anchor: \"#ff6350\",\n  ancestor: \"#3489ca\",\n  child: \"#85b8df\",\n};\nconst diameter = 12;\nconst radius = diameter / 2;\nconst yOffset = 100;\nconst line = d3Line().curve(curveMonotoneX);\n\nfunction OntologySubgraph({ efoId, efo, name, idToDisease, measureRef, contentRect }) {\n  const classes = useStyles();\n  const { width } = contentRect.bounds;\n  if (!efo) return null;\n  const dagData = buildDagData(efoId, efo, idToDisease);\n  const dag = dagStratify()(dagData);\n  const maxLayerCount = getMaxLayerCount(dag);\n  const height = maxLayerCount * 6;\n  const layout = sugiyama()\n    .layering(layering)\n    .decross(decross)\n    .coord(coord)\n    .nodeSize(() => {\n      const base = diameter + 3;\n      return [base, base];\n    })\n    .size([height, width]);\n\n  layout(dag);\n  const nodes = dag.descendants();\n  const links = dag.links();\n  const separation = width / (max(nodes, (d) => d.layer) + 1);\n  const xOffset = separation / 2 - radius;\n  const textLimit = separation / 8;\n\n  line.x((d) => d.y - xOffset).y((d) => d.x);\n\n  return (\n    <div ref={measureRef}>\n      {width ? (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          width={width}\n          height={height + yOffset}\n        >\n          <defs>\n            <marker\n              id=\"arrowhead\"\n              orient=\"auto\"\n              markerWidth=\"2\"\n              markerHeight=\"4\"\n              refX=\"0.1\"\n              refY=\"2\"\n            >\n              <path d=\"M0,0 V4 L2,2 Z\" fill=\"#5a5f5f\" />\n            </marker>\n          </defs>\n          <g transform=\"translate(0, 10)\">\n            <rect\n              x=\"4\"\n              y=\"11\"\n              width={diameter}\n              height={diameter}\n              fill=\"none\"\n              stroke=\"#e0e0e0\"\n              strokeWidth=\"2\"\n            />\n            <text x=\"20\" y=\"17\" fill=\"#5a5f5f\" dominantBaseline=\"middle\" fontSize=\"12\">\n              therapeutic area\n            </text>\n            <circle cx=\"10\" cy=\"34\" r={radius} fill=\"none\" stroke=\"#e0e0e0\" strokeWidth=\"2\" />\n            <text fill=\"#5a5f5f\" x=\"20\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              disease\n            </text>\n            <circle cx=\"150\" cy=\"0\" r={radius} fill={colorMap.child} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"0\" dominantBaseline=\"middle\" fontSize=\"12\">\n              descendants\n            </text>\n            <circle cx=\"150\" cy=\"17\" r={radius} fill={colorMap.ancestor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"17\" dominantBaseline=\"middle\" fontSize=\"12\">\n              ancestors\n            </text>\n            <circle cx=\"150\" cy=\"34\" r={radius} fill={colorMap.anchor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              {name}\n            </text>\n          </g>\n          <g transform={`translate(${width / 2}, 70)`}>\n            <text x=\"-160\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              GENERAL\n            </text>\n            <text x=\"100\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              SPECIFIC\n            </text>\n            <path\n              markerEnd=\"url(#arrowhead)\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n              stroke=\"#5a5f5f\"\n              d=\"M-80,0 L80,0\"\n            />\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {links.map(({ points, source, target }) => (\n              <path\n                key={`${source.id}-${target.id}`}\n                d={line(points)}\n                fill=\"none\"\n                strokeWidth=\"2\"\n                stroke=\"#eeeeee\"\n              />\n            ))}\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {nodes.map((node) => (\n              <Link to={`/disease/${node.data.id}`} className={classes.labelText} key={node.id}>\n                <OntologyTooltip title={`${node.data.name || \"No name\"} | ID: ${node.id}`}>\n                  <g>\n                    <text\n                      x={node.y - xOffset}\n                      y={node.x}\n                      dx=\"9\"\n                      fontSize=\"12\"\n                      dominantBaseline=\"middle\"\n                      fill=\"#5a5f5f\"\n                      style={{ cursor: \"pointer\" }}\n                    >\n                      <title>{node.data.name}</title>\n                      {textWithEllipsis(node.data.name || \"No name\", textLimit)}\n                    </text>\n\n                    {node.data.parentIds.length === 0 ? (\n                      <rect\n                        x={node.y - radius - xOffset}\n                        y={node.x - radius}\n                        width={diameter}\n                        height={diameter}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    ) : (\n                      <circle\n                        cx={node.y - xOffset}\n                        cy={node.x}\n                        r={radius}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    )}\n                  </g>\n                </OntologyTooltip>\n              </Link>\n            ))}\n          </g>\n        </svg>\n      ) : null}\n    </div>\n  );\n}\n\nexport default withContentRect(\"bounds\")(OntologySubgraph);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/disease/Ontology/OntologySubgraph.jsx" },
        "span": [3510, 3681],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { curveMonotoneX, line as d3Line, max } from \"d3\";\nimport { coordCenter, dagStratify, decrossTwoLayer, layeringLongestPath, sugiyama } from \"d3-dag\";\nimport { withContentRect } from \"react-measure\";\nimport { Link } from \"react-router-dom\";\nimport OntologyTooltip from \"./OntologyTooltip\";\n\nconst useStyles = makeStyles({\n  labelText: {\n    \"&:hover\": { fontWeight: \"700\" },\n  },\n});\n\nfunction getAncestors(efoId, idToDisease) {\n  const ancestors = [{ ...idToDisease[efoId], nodeType: \"anchor\" }];\n  const queue = [efoId];\n  const visited = new Set([efoId]);\n\n  while (queue.length > 0) {\n    const id = queue.shift();\n    const node = idToDisease[id];\n\n    node.parentIds.forEach((parentId) => {\n      if (!visited.has(parentId)) {\n        ancestors.push({ ...idToDisease[parentId], nodeType: \"ancestor\" });\n        queue.push(parentId);\n        visited.add(parentId);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction buildDagData(efoId, efo, idToDisease) {\n  const dag = [];\n\n  if (!efo) return dag;\n\n  // find direct children of efoId\n  efo.forEach((disease) => {\n    if (disease.parentIds.includes(efoId)) {\n      dag.push({\n        id: disease.id,\n        name: disease.name,\n        parentIds: [efoId],\n        nodeType: \"child\",\n      });\n    }\n  });\n\n  const ancestors = getAncestors(efoId, idToDisease); // find ancestors\n\n  ancestors.forEach((ancestor) => {\n    dag.push(ancestor);\n  });\n\n  return dag;\n}\n\nconst layering = layeringLongestPath();\nconst decross = decrossTwoLayer();\nconst coord = coordCenter();\n\nconst helperLayout = sugiyama().layering(layering).decross(decross).coord(coord);\n\nfunction textWithEllipsis(text, threshold) {\n  return text.length <= threshold ? text : `${text.slice(0, threshold)}...`;\n}\n\nfunction getMaxLayerCount(dag) {\n  helperLayout(dag);\n\n  const counts = {};\n  let maxCount = Number.NEGATIVE_INFINITY;\n\n  dag.descendants().forEach((node) => {\n    const { layer } = node;\n\n    if (counts[layer]) {\n      counts[layer] += 1;\n    } else {\n      counts[layer] = 1;\n    }\n\n    if (counts[layer] > maxCount) {\n      maxCount = counts[layer];\n    }\n  });\n\n  dag.links().forEach((link) => {\n    link.points.forEach((_, i) => {\n      const index = link.source.layer + i;\n      counts[index] += 1;\n      if (counts[index] > maxCount) {\n        maxCount = counts[index];\n      }\n    });\n  });\n\n  return maxCount;\n}\n\nconst colorMap = {\n  anchor: \"#ff6350\",\n  ancestor: \"#3489ca\",\n  child: \"#85b8df\",\n};\nconst diameter = 12;\nconst radius = diameter / 2;\nconst yOffset = 100;\nconst line = d3Line().curve(curveMonotoneX);\n\nfunction OntologySubgraph({ efoId, efo, name, idToDisease, measureRef, contentRect }) {\n  const classes = useStyles();\n  const { width } = contentRect.bounds;\n  if (!efo) return null;\n  const dagData = buildDagData(efoId, efo, idToDisease);\n  const dag = dagStratify()(dagData);\n  const maxLayerCount = getMaxLayerCount(dag);\n  const height = maxLayerCount * 6;\n  const layout = sugiyama()\n    .layering(layering)\n    .decross(decross)\n    .coord(coord)\n    .nodeSize(() => {\n      const base = diameter + 3;\n      return [base, base];\n    })\n    .size([height, width]);\n\n  layout(dag);\n  const nodes = dag.descendants();\n  const links = dag.links();\n  const separation = width / (max(nodes, (d) => d.layer) + 1);\n  const xOffset = separation / 2 - radius;\n  const textLimit = separation / 8;\n\n  line.x((d) => d.y - xOffset).y((d) => d.x);\n\n  return (\n    <div ref={measureRef}>\n      {width ? (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          width={width}\n          height={height + yOffset}\n        >\n          <defs>\n            <marker\n              id=\"arrowhead\"\n              orient=\"auto\"\n              markerWidth=\"2\"\n              markerHeight=\"4\"\n              refX=\"0.1\"\n              refY=\"2\"\n            >\n              <path d=\"M0,0 V4 L2,2 Z\" fill=\"#5a5f5f\" />\n            </marker>\n          </defs>\n          <g transform=\"translate(0, 10)\">\n            <rect\n              x=\"4\"\n              y=\"11\"\n              width={diameter}\n              height={diameter}\n              fill=\"none\"\n              stroke=\"#e0e0e0\"\n              strokeWidth=\"2\"\n            />\n            <text x=\"20\" y=\"17\" fill=\"#5a5f5f\" dominantBaseline=\"middle\" fontSize=\"12\">\n              therapeutic area\n            </text>\n            <circle cx=\"10\" cy=\"34\" r={radius} fill=\"none\" stroke=\"#e0e0e0\" strokeWidth=\"2\" />\n            <text fill=\"#5a5f5f\" x=\"20\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              disease\n            </text>\n            <circle cx=\"150\" cy=\"0\" r={radius} fill={colorMap.child} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"0\" dominantBaseline=\"middle\" fontSize=\"12\">\n              descendants\n            </text>\n            <circle cx=\"150\" cy=\"17\" r={radius} fill={colorMap.ancestor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"17\" dominantBaseline=\"middle\" fontSize=\"12\">\n              ancestors\n            </text>\n            <circle cx=\"150\" cy=\"34\" r={radius} fill={colorMap.anchor} stroke=\"#e0e0e0\" />\n            <text fill=\"#5a5f5f\" x=\"160\" y=\"34\" dominantBaseline=\"middle\" fontSize=\"12\">\n              {name}\n            </text>\n          </g>\n          <g transform={`translate(${width / 2}, 70)`}>\n            <text x=\"-160\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              GENERAL\n            </text>\n            <text x=\"100\" fontWeight=\"bold\" fontSize=\"14\" fill=\"#5a5f5f\" dominantBaseline=\"middle\">\n              SPECIFIC\n            </text>\n            <path\n              markerEnd=\"url(#arrowhead)\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n              stroke=\"#5a5f5f\"\n              d=\"M-80,0 L80,0\"\n            />\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {links.map(({ points, source, target }) => (\n              <path\n                key={`${source.id}-${target.id}`}\n                d={line(points)}\n                fill=\"none\"\n                strokeWidth=\"2\"\n                stroke=\"#eeeeee\"\n              />\n            ))}\n          </g>\n          <g transform={`translate(0, ${yOffset})`}>\n            {nodes.map((node) => (\n              <Link to={`/disease/${node.data.id}`} className={classes.labelText} key={node.id}>\n                <OntologyTooltip title={`${node.data.name || \"No name\"} | ID: ${node.id}`}>\n                  <g>\n                    <text\n                      x={node.y - xOffset}\n                      y={node.x}\n                      dx=\"9\"\n                      fontSize=\"12\"\n                      dominantBaseline=\"middle\"\n                      fill=\"#5a5f5f\"\n                      style={{ cursor: \"pointer\" }}\n                    >\n                      <title>{node.data.name}</title>\n                      {textWithEllipsis(node.data.name || \"No name\", textLimit)}\n                    </text>\n\n                    {node.data.parentIds.length === 0 ? (\n                      <rect\n                        x={node.y - radius - xOffset}\n                        y={node.x - radius}\n                        width={diameter}\n                        height={diameter}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    ) : (\n                      <circle\n                        cx={node.y - xOffset}\n                        cy={node.x}\n                        r={radius}\n                        fill={colorMap[node.data.nodeType]}\n                        stroke=\"#e0e0e0\"\n                      />\n                    )}\n                  </g>\n                </OntologyTooltip>\n              </Link>\n            ))}\n          </g>\n        </svg>\n      ) : null}\n    </div>\n  );\n}\n\nexport default withContentRect(\"bounds\")(OntologySubgraph);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/drug/DrugWarnings/Body.jsx" },
        "span": [1714, 1952],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { Link, OtTable, SectionItem, TableDrawer, Tooltip } from \"ui\";\n\nimport { naLabel } from \"@ot/constants\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport DRUG_WARNINGS_QUERY from \"./DrugWarningsQuery.gql\";\n\nconst replaceSemicolonWithUnderscore = (id) => id.replace(\":\", \"_\");\n\nconst columns = [\n  {\n    id: \"warningType\",\n    label: \"Warning type\",\n  },\n  {\n    id: \"efoTerm\",\n    label: \"Adverse event\",\n    renderCell: ({ efoTerm, efoId, description }) => {\n      if (efoId)\n        return (\n          <Tooltip title={`Description: ${description}`} showHelpIcon>\n            <Link asyncTooltip to={`/disease/${replaceSemicolonWithUnderscore(efoId)}`}>\n              {efoTerm || efoId}\n            </Link>\n          </Tooltip>\n        );\n      return efoTerm || description || naLabel;\n    },\n  },\n  {\n    id: \"toxicityClass\",\n    label: \"ChEMBL warning class\",\n    enableHiding: false,\n    renderCell: ({ toxicityClass, efoIdForWarningClass, description }) => {\n      if (efoIdForWarningClass)\n        return (\n          <Link external to={`/disease/${replaceSemicolonWithUnderscore(efoIdForWarningClass)}`}>\n            {toxicityClass || efoIdForWarningClass}\n          </Link>\n        );\n      return toxicityClass || description || naLabel;\n    },\n  },\n  {\n    id: \"country\",\n    label: \"Country / region\",\n    renderCell: ({ country }) => country ?? naLabel,\n  },\n  { id: \"year\", label: \"Year\", renderCell: ({ year }) => year ?? naLabel },\n  {\n    id: \"references\",\n    label: \"References\",\n    renderCell: ({ references }) => {\n      const sources = new Set(); // used to collect unique sources\n      const refs = [];\n\n      references.forEach((ref) => {\n        sources.add(ref.source); // add source to set\n        refs.push({\n          // create new entry object\n          name: ref.id,\n          url: ref.url,\n          group: ref.source,\n        });\n      });\n\n      const message = Array.from(sources).join(\", \");\n\n      return <TableDrawer entries={refs} showSingle={false} message={message} />;\n    },\n  },\n];\n\nfunction Body({ id: chemblId, label: name, entity }) {\n  const variables = { chemblId };\n  const request = useQuery(DRUG_WARNINGS_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => (\n        <OtTable\n          showGlobalFilter\n          dataDownloader\n          columns={columns}\n          rows={request.data?.drug.drugWarnings}\n          query={DRUG_WARNINGS_QUERY.loc.source.body}\n          variables={variables}\n          loading={request.loading}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/drug/Indications/Body.jsx" },
        "span": [1412, 1677],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\n\nimport { phaseMap, sourceMap } from \"@ot/constants\";\nimport { referenceUrls } from \"@ot/utils\";\nimport { Link, OtTable, PaginationActionsComplete, SectionItem, TableDrawer } from \"ui\";\n\nimport Description from \"./Description\";\nimport TherapeuticAreasDrawer from \"./TherapeuticAreasDrawer\";\n\nimport { definition } from \".\";\nimport INDICATIONS_QUERY from \"./IndicationsQuery.gql\";\n\nconst columns = [\n  {\n    id: \"indication\",\n    label: \"Indication\",\n    enableHiding: false,\n    propertyPath: \"disease.name\",\n    renderCell: (d) => (\n      <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n        {d.disease.name}\n      </Link>\n    ),\n    width: \"38%\",\n  },\n  {\n    id: \"therapeuticAreas\",\n    label: \"Therapeutic Areas\",\n    renderCell: (d) => <TherapeuticAreasDrawer therapeuticAreas={d.disease.therapeuticAreas} />,\n    exportValue: (d) => d.disease.therapeuticAreas.map((therapeuticArea) => therapeuticArea.id),\n    width: \"38%\",\n  },\n  {\n    id: \"maxPhaseForIndication\",\n    label: \"Max Phase\",\n    sortable: true,\n    width: \"10%\",\n    renderCell: ({ maxPhaseForIndication }) => phaseMap(maxPhaseForIndication),\n    filterValue: ({ maxPhaseForIndication }) => phaseMap(maxPhaseForIndication),\n  },\n  {\n    id: \"references\",\n    label: \"Source\",\n    renderCell: ({ references }) => {\n      if (!references) return \"N/A\";\n\n      const referenceList = [];\n\n      references.forEach((reference) => {\n        reference.ids.forEach((id) => {\n          referenceList.push({\n            name: id,\n            url: referenceUrls[reference.source](id),\n            group: sourceMap[reference.source],\n          });\n        });\n      });\n\n      if (referenceList.length === 1) {\n        return (\n          <Link external to={referenceList[0].url}>\n            {referenceList[0].group}\n          </Link>\n        );\n      }\n\n      return <TableDrawer entries={referenceList} />;\n    },\n  },\n];\n\nfunction Body({ id: chemblId, label: name, entity }) {\n  const variables = { chemblId };\n  const request = useQuery(INDICATIONS_QUERY, { variables });\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        return (\n          <OtTable\n            columns={columns}\n            dataDownloader\n            dataDownloaderFileStem={`${chemblId}-indications`}\n            rows={request.data?.drug.indications.rows}\n            showGlobalFilter\n            sortBy=\"maxPhaseForIndication\"\n            order=\"desc\"\n            ActionsComponent={PaginationActionsComplete}\n            query={INDICATIONS_QUERY.loc.source.body}\n            variables={variables}\n            loading={request.loading}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/drug/Indications/Body.jsx" },
        "span": [1456, 1667],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\n\nimport { phaseMap, sourceMap } from \"@ot/constants\";\nimport { referenceUrls } from \"@ot/utils\";\nimport { Link, OtTable, PaginationActionsComplete, SectionItem, TableDrawer } from \"ui\";\n\nimport Description from \"./Description\";\nimport TherapeuticAreasDrawer from \"./TherapeuticAreasDrawer\";\n\nimport { definition } from \".\";\nimport INDICATIONS_QUERY from \"./IndicationsQuery.gql\";\n\nconst columns = [\n  {\n    id: \"indication\",\n    label: \"Indication\",\n    enableHiding: false,\n    propertyPath: \"disease.name\",\n    renderCell: (d) => (\n      <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n        {d.disease.name}\n      </Link>\n    ),\n    width: \"38%\",\n  },\n  {\n    id: \"therapeuticAreas\",\n    label: \"Therapeutic Areas\",\n    renderCell: (d) => <TherapeuticAreasDrawer therapeuticAreas={d.disease.therapeuticAreas} />,\n    exportValue: (d) => d.disease.therapeuticAreas.map((therapeuticArea) => therapeuticArea.id),\n    width: \"38%\",\n  },\n  {\n    id: \"maxPhaseForIndication\",\n    label: \"Max Phase\",\n    sortable: true,\n    width: \"10%\",\n    renderCell: ({ maxPhaseForIndication }) => phaseMap(maxPhaseForIndication),\n    filterValue: ({ maxPhaseForIndication }) => phaseMap(maxPhaseForIndication),\n  },\n  {\n    id: \"references\",\n    label: \"Source\",\n    renderCell: ({ references }) => {\n      if (!references) return \"N/A\";\n\n      const referenceList = [];\n\n      references.forEach((reference) => {\n        reference.ids.forEach((id) => {\n          referenceList.push({\n            name: id,\n            url: referenceUrls[reference.source](id),\n            group: sourceMap[reference.source],\n          });\n        });\n      });\n\n      if (referenceList.length === 1) {\n        return (\n          <Link external to={referenceList[0].url}>\n            {referenceList[0].group}\n          </Link>\n        );\n      }\n\n      return <TableDrawer entries={referenceList} />;\n    },\n  },\n];\n\nfunction Body({ id: chemblId, label: name, entity }) {\n  const variables = { chemblId };\n  const request = useQuery(INDICATIONS_QUERY, { variables });\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => {\n        return (\n          <OtTable\n            columns={columns}\n            dataDownloader\n            dataDownloaderFileStem={`${chemblId}-indications`}\n            rows={request.data?.drug.indications.rows}\n            showGlobalFilter\n            sortBy=\"maxPhaseForIndication\"\n            order=\"desc\"\n            ActionsComponent={PaginationActionsComplete}\n            query={INDICATIONS_QUERY.loc.source.body}\n            variables={variables}\n            loading={request.loading}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Summary/utils.js" },
        "span": [257, 517],
        "sourceCode": "import { gql } from \"@apollo/client\";\n\nexport function createSummaryFragment(sections, entity, fragmentName) {\n  const sectionFragments = [];\n  const sectionFragmentNames = [];\n  const fragmentNameStr = fragmentName || `${entity}ProfileSummaryFragment`;\n\n  sections.forEach((Summary) => {\n    if (!Summary.fragments) return;\n\n    const sectionFragmentName = Object.keys(Summary.fragments)[0];\n\n    sectionFragmentNames.push(sectionFragmentName);\n    sectionFragments.push(Summary.fragments[sectionFragmentName]);\n  });\n\n  // const idLookup = {\n  //   Gwas: \"studyId\",\n  //   credibleSet: \"studyLocusId\",\n  // };\n\n  return gql`\n    fragment ${fragmentNameStr} on ${entity} {\n      ${\n        sectionFragmentNames.length\n          ? sectionFragmentNames.map((sfn) => `...${sfn}`).join(\"\\n\")\n          : \"id\"\n      }\n    }\n    ${sectionFragments.reduce(\n      (acc, fragment) => gql`\n        ${acc}\n        ${fragment}\n      `,\n      \"\"\n    )}\n  `;\n\n  // return gql`\n  //   fragment ${fragmentNameStr} on ${entity} {\n  //     ${\n  //       sectionFragmentNames.length\n  //         ? sectionFragmentNames.map(sfn => `...${sfn}`).join(\"\\n\")\n  //         : idLookup[entity] || \"id\"\n  //     }\n  //   }\n  //   ${sectionFragments.reduce(\n  //     (acc, fragment) => gql`\n  //       ${acc}\n  //       ${fragment}\n  //     `,\n  //     \"\"\n  //   )}\n  // `;\n}\n\nexport function createShortName(definition) {\n  return (\n    definition.shortName ||\n    definition.name\n      .split(\" \")\n      .slice(0, 2)\n      .map((w) => w[0].toUpperCase())\n      .join(\"\")\n  );\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/drug/Pharmacogenomics/Body.jsx" },
        "span": [7355, 7361],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { makeStyles } from \"@mui/styles\";\nimport classNames from \"classnames\";\nimport { LabelChip, Link, OtTable, PublicationsDrawer, SectionItem, Tooltip } from \"ui\";\n\nimport { faCircleXmark } from \"@fortawesome/free-regular-svg-icons\";\nimport { faCircleCheck } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { PHARM_GKB_COLOR, naLabel, variantConsequenceSource } from \"@ot/constants\";\nimport { epmcUrl, identifiersOrgLink, sentenceCase } from \"@ot/utils\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PHARMACOGENOMICS_QUERY from \"./Pharmacogenomics.gql\";\n\nconst useStyles = makeStyles((theme) => ({\n  level: {\n    color: \"white\",\n    padding: theme.spacing(0.5),\n    borderRadius: theme.spacing(0.5),\n  },\n  green: {\n    background: PHARM_GKB_COLOR.green,\n  },\n  red: {\n    background: PHARM_GKB_COLOR.red,\n  },\n  yellow: {\n    background: PHARM_GKB_COLOR.yellow,\n  },\n  blue: {\n    background: theme.palette.primary.main,\n  },\n  blueIcon: {\n    color: theme.palette.primary.main,\n  },\n}));\n\nconst getLevelElementClassName = (level) => {\n  switch (level) {\n    case \"1\":\n      return \"green\";\n    case \"1A\":\n      return \"green\";\n    case \"1B\":\n      return \"green\";\n    case \"2\":\n      return \"blue\";\n    case \"2A\":\n      return \"blue\";\n    case \"2B\":\n      return \"blue\";\n    case \"3\":\n      return \"yellow\";\n    case \"4\":\n      return \"red\";\n    default:\n      return \"red\";\n  }\n};\n\nfunction Body({ id: chemblId, label: name, entity }) {\n  const variables = { chemblId };\n  const classes = useStyles();\n\n  const columns = [\n    {\n      id: \"gene\",\n      label: \"Gene\",\n      renderCell: ({ target }) => {\n        if (target) {\n          return (\n            <Link asyncTooltip to={`/target/${target.id}`}>\n              <span>{target.approvedSymbol}</span>\n            </Link>\n          );\n        }\n        return naLabel;\n      },\n      filterValue: ({ target }) => `${target}`,\n    },\n    {\n      id: \"variantRsId\",\n      label: \"rsID\",\n      enableHiding: false,\n      renderCell: ({ variantRsId }) =>\n        variantRsId ? (\n          <Link\n            external\n            to={`http://www.ensembl.org/Homo_sapiens/Variation/Explore?v=${variantRsId}`}\n          >\n            {variantRsId}\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"starAllele\",\n      label: \"Star Allele\",\n      renderCell: ({ haplotypeId, haplotypeFromSourceId }) => {\n        const displayId = haplotypeId || haplotypeFromSourceId || naLabel;\n        const LinkComponent = haplotypeFromSourceId && (\n          <Link external to={`https://www.pharmgkb.org/haplotype/${haplotypeFromSourceId}`}>\n            {displayId}\n          </Link>\n        );\n\n        return LinkComponent || displayId || naLabel;\n      },\n    },\n    {\n      id: \"genotypeId\",\n      label: \"Genotype ID\",\n      tooltip: (\n        <>\n          VCF-style(chr_pos_ref_allele1,allele2). See{\" \"}\n          <Link\n            external\n            to=\"https://github.com/apriltuesday/opentargets-pharmgkb/tree/issue-18#variant-coordinate-computation\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      renderCell: ({ genotypeId }) => genotypeId || naLabel,\n    },\n    {\n      id: \"variantConsequence\",\n      label: \"Variant Consequence\",\n      renderCell: ({ variantFunctionalConsequence, genotypeId }) => {\n        const pvparams = genotypeId?.split(\",\")[0].split(\"_\") || [];\n        return (\n          <div style={{ display: \"flex\", gap: \"5px\" }}>\n            {variantFunctionalConsequence ? (\n              <LabelChip\n                label={variantConsequenceSource.VEP.label}\n                value={sentenceCase(variantFunctionalConsequence.label)}\n                tooltip={variantConsequenceSource.VEP.tooltip}\n                to={identifiersOrgLink(\"SO\", variantFunctionalConsequence.id.slice(3))}\n              />\n            ) : (\n              naLabel\n            )}\n            {(variantFunctionalConsequence?.id === \"SO:0001583\" ||\n              variantFunctionalConsequence?.id === \"SO:0001587\") && (\n              <LabelChip\n                label={variantConsequenceSource.ProtVar.label}\n                to={`https://www.ebi.ac.uk/ProtVar/query?chromosome=${pvparams[0]}&genomic_position=${pvparams[1]}&reference_allele=${pvparams[2]}&alternative_allele=${pvparams[3]}`}\n                tooltip={variantConsequenceSource.ProtVar.tooltip}\n              />\n            )}\n          </div>\n        );\n      },\n      filterValue: ({ variantFunctionalConsequence }) =>\n        sentenceCase(variantFunctionalConsequence?.label),\n    },\n    {\n      id: \"drugResponse\",\n      label: \"Drug Response Phenotype\",\n      renderCell: ({ phenotypeText, phenotypeFromSourceId, genotypeAnnotationText }) => {\n        let phenotypeTextElement;\n\n        if (phenotypeText) {\n          phenotypeTextElement = phenotypeText;\n        } else phenotypeTextElement = naLabel;\n\n        if (phenotypeFromSourceId)\n          phenotypeTextElement = (\n            <Link asyncTooltip to={`/disease/${phenotypeFromSourceId}`}>\n              {phenotypeTextElement}\n            </Link>\n          );\n\n        if (genotypeAnnotationText)\n          phenotypeTextElement = (\n            <Tooltip title={genotypeAnnotationText} showHelpIcon>\n              {phenotypeTextElement}\n            </Tooltip>\n          );\n\n        return phenotypeTextElement;\n      },\n      filterValue: ({ phenotypeText }) => `${phenotypeText}`,\n    },\n    {\n      id: \"drugResponseCategory\",\n      label: \"Drug Response Category\",\n      renderCell: ({ pgxCategory }) => pgxCategory || naLabel,\n      filterValue: ({ pgxCategory }) => pgxCategory,\n    },\n    {\n      id: \"isDirectTarget\",\n      label: \"Direct Drug Target\",\n      renderCell: ({ isDirectTarget }) => {\n        const ICON_NAME = isDirectTarget ? faCircleCheck : faCircleXmark;\n        return <FontAwesomeIcon icon={ICON_NAME} size=\"lg\" className={classes.blueIcon} />;\n      },\n    },\n    {\n      id: \"evidenceLevel\",\n      label: \"Confidence Level\",\n      sortable: true,\n      tooltip: (\n        <>\n          As defined by\n          <Link external to={\"https://www.pharmgkb.org/page/clinAnnLevels\"}>\n            {\" \"}\n            PharmGKB ClinAnn Levels\n          </Link>\n        </>\n      ),\n      renderCell: ({ evidenceLevel }) => {\n        if (evidenceLevel) {\n          const levelClass = getLevelElementClassName(evidenceLevel);\n          return (\n            <span className={classNames(classes.level, classes[levelClass])}>\n              Level {evidenceLevel}\n            </span>\n          );\n        }\n        return naLabel;\n      },\n      filterValue: ({ evidenceLevel }) => `Level ${evidenceLevel}`,\n    },\n    {\n      id: \"source\",\n      label: \"Source\",\n      renderCell: ({ studyId }) =>\n        studyId ? (\n          <Link external to={`https://www.pharmgkb.org/clinicalAnnotation/${studyId}`}>\n            PharmGKB\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"literature\",\n      label: \"Literature\",\n      renderCell: ({ literature }) => {\n        const literatureList =\n          literature?.reduce((acc, id) => {\n            if (id === \"NA\") return acc;\n\n            return [\n              ...acc,\n              {\n                name: id,\n                url: epmcUrl(id),\n                group: \"literature\",\n              },\n            ];\n          }, []) || [];\n\n        return <PublicationsDrawer entries={literatureList} />;\n      },\n    },\n  ];\n\n  const request = useQuery(PHARMACOGENOMICS_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description name={name} />}\n      renderBody={() => (\n        <OtTable\n          sortBy=\"evidenceLevel\"\n          showGlobalFilter\n          dataDownloader\n          columns={columns}\n          rows={request.data?.drug.pharmacogenomics}\n          query={PHARMACOGENOMICS_QUERY.loc.source.body}\n          variables={variables}\n          loading={request.loading}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/CancerGeneCensus/Body.jsx" },
        "span": [3469, 3475],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { Box, List, ListItem, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { v1 } from \"uuid\";\n\nimport { ChipList, Link, OtTable, PublicationsDrawer, SectionItem } from \"ui\";\n\nimport { dataTypesMap, naLabel, sectionsBaseSizeQuery } from \"@ot/constants\";\nimport { epmcUrl, identifiersOrgLink, sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\n\nimport { definition } from \".\";\n\nimport CANCER_GENE_CENSUS_QUERY from \"./sectionQuery.gql\";\n\nconst samplePercent = (item) =>\n  (item.numberSamplesWithMutationType / item.numberSamplesTested) * 100;\n\nconst getMaxPercent = (row) => {\n  if (row.mutatedSamples) return Math.max(...row.mutatedSamples.map((item) => samplePercent(item)));\n  return null;\n};\n\nconst getColumns = (label) => [\n  {\n    id: \"disease.name\",\n    label: \"Disease/phenotype\",\n    enableHiding: false,\n    renderCell: ({ disease }) => (\n      <Link asyncTooltip to={`/disease/${disease.id}`}>\n        {disease.name}\n      </Link>\n    ),\n  },\n  {\n    id: \"mutationType\",\n    propertyPath: \"mutatedSamples.functionalConsequence\",\n    label: \"Mutation type\",\n    enableHiding: false,\n    renderCell: ({ mutatedSamples }) => {\n      if (!mutatedSamples) return naLabel;\n      const sortedMutatedSamples = mutatedSamples\n        .slice()\n        .sort((a, b) => samplePercent(b) - samplePercent(a));\n      return (\n        <List style={{ padding: 0 }}>\n          {sortedMutatedSamples.map((mutatedSample) => (\n            <ListItem key={mutatedSample.functionalConsequence.id} style={{ padding: \".25rem 0\" }}>\n              <Link\n                external\n                to={identifiersOrgLink(\"SO\", mutatedSample.functionalConsequence.id.slice(3))}\n              >\n                {sentenceCase(mutatedSample.functionalConsequence.label)}\n              </Link>\n            </ListItem>\n          ))}\n        </List>\n      );\n    },\n    filterValue: ({ mutatedSamples }) =>\n      (mutatedSamples || [])\n        .map((mutatedSample) => sentenceCase(mutatedSample.functionalConsequence.label))\n        .join(),\n  },\n  {\n    id: \"mutatedSamples\",\n    propertyPath: \"mutatedSamples.numberSamplesWithMutationType\",\n    sortable: true,\n    label: \"Mutated / Total samples\",\n    renderCell: ({ mutatedSamples }) => {\n      if (!mutatedSamples) return naLabel;\n      const sortedMutatedSamples = mutatedSamples\n        .slice()\n        .sort((a, b) => samplePercent(b) - samplePercent(a));\n      return (\n        <List style={{ padding: 0 }}>\n          {sortedMutatedSamples.map((item) => {\n            const percent = samplePercent(item);\n\n            return (\n              <ListItem key={v1()} style={{ padding: \".25rem 0\" }}>\n                {percent < 5\n                  ? Number.parseFloat(percent.toFixed(2)).toString()\n                  : Math.round(percent)}\n                %\n                <Typography variant=\"caption\" style={{ marginLeft: \".33rem\" }}>\n                  ({item.numberSamplesWithMutationType}/{item.numberSamplesTested})\n                </Typography>\n              </ListItem>\n            );\n          })}\n        </List>\n      );\n    },\n    comparator: (a, b) => getMaxPercent(a) - getMaxPercent(b),\n  },\n  {\n    id: \"literature\",\n    label: \"Literature\",\n    renderCell: ({ literature }) => {\n      const literatureList =\n        literature?.reduce((acc, id) => {\n          if (id === \"NA\") return acc;\n\n          return [\n            ...acc,\n            {\n              name: id,\n              url: epmcUrl(id),\n              group: \"literature\",\n            },\n          ];\n        }, []) || [];\n\n      return (\n        <PublicationsDrawer entries={literatureList} symbol={label.symbol} name={label.name} />\n      );\n    },\n  },\n];\n\nconst useStyles = makeStyles({\n  roleInCancerBox: {\n    display: \"flex\",\n    alignItems: \"center\",\n    marginBottom: \"2rem\",\n  },\n  roleInCancerTitle: { marginRight: \".5rem !important\" },\n});\n\nfunction Body({ id, label, entity }) {\n  const classes = useStyles();\n  const { ensgId, efoId } = id;\n\n  const variables = {\n    ensemblId: ensgId,\n    efoId,\n    size: sectionsBaseSizeQuery,\n  };\n\n  const request = useQuery(CANCER_GENE_CENSUS_QUERY, {\n    variables,\n  });\n\n  const columns = getColumns(label);\n\n  return (\n    <SectionItem\n      definition={definition}\n      chipText={dataTypesMap.somatic_mutation}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description symbol={label.symbol} diseaseName={label.name} />}\n      renderBody={() => {\n        const roleInCancerItems =\n          request.data?.target.hallmarks && request.data?.target.hallmarks.attributes.length > 0\n            ? request.data?.target.hallmarks.attributes\n                .filter((attribute) => attribute.name === \"role in cancer\")\n                .map((attribute) => ({\n                  label: attribute.description,\n                  url: epmcUrl(attribute.pmid),\n                }))\n            : [{ label: \"Unknown\" }];\n\n        return (\n          <>\n            <Box className={classes.roleInCancerBox}>\n              <Typography className={classes.roleInCancerTitle}>\n                <b>{label.symbol}</b> role in cancer:\n              </Typography>\n              <ChipList items={roleInCancerItems} />\n            </Box>\n            <OtTable\n              columns={columns}\n              dataDownloader\n              order=\"asc\"\n              rows={request.data?.disease.cancerGeneCensusSummary.rows}\n              showGlobalFilter\n              sortBy=\"mutatedSamples\"\n              query={CANCER_GENE_CENSUS_QUERY.loc.source.body}\n              variables={variables}\n              loading={request.loading}\n            />\n          </>\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/Chembl/Body.jsx" },
        "span": [2739, 2934],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { useState } from \"react\";\nimport {\n  ChipList,\n  DirectionOfEffectIcon,\n  DirectionOfEffectTooltip,\n  Link,\n  OtTableSSP,\n  SectionItem,\n  TableDrawer,\n  Tooltip,\n} from \"ui\";\n\nimport { dataTypesMap, naLabel, phaseMap, sourceMap } from \"@ot/constants\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\n\nimport { Box, Typography } from \"@mui/material\";\nimport CHEMBL_QUERY from \"./ChemblQuery.gql\";\n\nconst useStyles = makeStyles(() => ({\n  tooltipContainer: {\n    padding: \"0.3em\",\n  },\n  chipContainer: {\n    display: \"inline-block\",\n    marginTop: \"0.4em\",\n  },\n  chipStyle: {\n    fontSize: \"0.625rem\",\n  },\n}));\n\nconst exportColumns = [\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"targets\",\n    exportValue: (row) => row.target,\n  },\n  {\n    label: \"drug\",\n    exportValue: (row) => row.drug,\n  },\n  {\n    label: \"mechanismofAction\",\n    exportValue: (row) => row.drug.mechanismsOfAction,\n  },\n  {\n    label: \"clinicalPhase\",\n    exportValue: (row) => row.clinicalPhase,\n  },\n  {\n    label: \"clinicalStatus\",\n    exportValue: (row) => row.clinicalStatus,\n  },\n  {\n    label: \"studyStartDate\",\n    exportValue: (row) => row.studyStartDate,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls,\n  },\n];\n\nfunction getColumns(classes) {\n  return [\n    {\n      id: \"disease.name\",\n      label: \"Disease/phenotype\",\n      enableHiding: false,\n      renderCell: ({ disease, cohortPhenotypes }) => {\n        let displayElement = naLabel;\n        if (disease)\n          displayElement = (\n            <Link asyncTooltip to={`/disease/${disease.id}`}>\n              {disease.name}\n            </Link>\n          );\n        if (cohortPhenotypes?.length) {\n          displayElement = (\n            <Tooltip\n              showHelpIcon\n              title={\n                <Box>\n                  <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                    All reported phenotypes:\n                  </Typography>\n                  {cohortPhenotypes.map((e) => (\n                    <div key={e}>{e}</div>\n                  ))}\n                </Box>\n              }\n            >\n              {displayElement}\n            </Tooltip>\n          );\n        }\n        return displayElement;\n      },\n    },\n    {\n      label: \"Targets\",\n      renderCell: ({ target, drug, targetFromSourceId }) => {\n        const mechanismsOfAction = drug.mechanismsOfAction || {};\n        const { rows = [] } = mechanismsOfAction;\n\n        let symbol = \"\";\n\n        const otherTargets = rows.reduce((acc, { targets }) => {\n          targets.forEach(({ id, approvedSymbol }) => {\n            if (id !== target.id) {\n              acc.add(id);\n            } else {\n              symbol = approvedSymbol;\n            }\n          });\n          return acc;\n        }, new Set());\n\n        if (symbol === \"\") {\n          const { approvedSymbol: targetSymbol } = target;\n          symbol = targetSymbol;\n        }\n\n        return (\n          <>\n            <Tooltip\n              title={\n                <>\n                  Reported target:{\" \"}\n                  <Link external to={`https://identifiers.org/uniprot/${targetFromSourceId}`}>\n                    {targetFromSourceId}\n                  </Link>\n                </>\n              }\n              showHelpIcon\n            >\n              <Link to={`/target/${target.id}`}>{symbol}</Link>\n            </Tooltip>\n            {otherTargets.size > 0\n              ? ` and ${otherTargets.size} other target${otherTargets.size > 1 ? \"s\" : \"\"}`\n              : null}\n          </>\n        );\n      },\n    },\n    {\n      id: \"drug.name\",\n      label: \"Drug\",\n      enableHiding: false,\n      renderCell: ({ drug }) => <Link to={`/drug/${drug.id}`}>{drug.name}</Link>,\n    },\n    {\n      id: \"drug.drugType\",\n      label: \"Modality\",\n    },\n    {\n      label: \"Mechanism of action (MoA)\",\n      renderCell: ({ target, drug }) => {\n        const mechanismsOfAction = drug.mechanismsOfAction || {};\n        const { rows = [] } = mechanismsOfAction;\n\n        let anchorMa = null;\n\n        const mas = rows.reduce((acc, { mechanismOfAction, targets }) => {\n          if (anchorMa === null) {\n            let isAssociated = false;\n            for (let i = 0; i < targets.length; i++) {\n              if (targets[i].id === target.id) {\n                anchorMa = mechanismOfAction;\n                isAssociated = true;\n                break;\n              }\n            }\n\n            if (!isAssociated) {\n              acc.add(mechanismOfAction);\n            }\n          } else {\n            acc.add(mechanismOfAction);\n          }\n\n          return acc;\n        }, new Set());\n\n        return `${anchorMa || naLabel}${mas.size > 0 ? ` and ${mas.size} other MoA` : \"\"}`;\n      },\n    },\n    {\n      id: \"directionOfVariantEffect\",\n      label: (\n        <DirectionOfEffectTooltip docsUrl=\"https://platform-docs.opentargets.org/evidence#chembl\" />\n      ),\n      renderCell: ({ variantEffect, directionOnTrait }) => {\n        return (\n          <DirectionOfEffectIcon\n            variantEffect={variantEffect}\n            directionOnTrait={directionOnTrait}\n          />\n        );\n      },\n    },\n    {\n      id: \"clinicalPhase\",\n      label: \"Phase\",\n      sortable: true,\n      renderCell: ({ clinicalPhase }) => phaseMap(clinicalPhase),\n      filterValue: ({ clinicalPhase }) => phaseMap(clinicalPhase),\n    },\n    {\n      id: \"clinicalStatus\",\n      label: \"Status\",\n      renderCell: ({ studyStopReason, clinicalStatus, studyStopReasonCategories }) => {\n        if (clinicalStatus && studyStopReason)\n          return (\n            <Tooltip\n              showHelpIcon\n              title={\n                <div className={classes.tooltipContainer}>\n                  <div>\n                    <span>Study stop reason: {studyStopReason}</span>\n                  </div>\n                  <div className={classes.chipContainer}>\n                    {studyStopReasonCategories ? (\n                      <ChipList\n                        items={studyStopReasonCategories.map((reason) => ({\n                          label: reason,\n                          customClass: classes.chipStyle,\n                        }))}\n                      />\n                    ) : null}\n                  </div>\n                </div>\n              }\n            >\n              {clinicalStatus}\n            </Tooltip>\n          );\n        if (clinicalStatus) return clinicalStatus;\n        return naLabel;\n      },\n    },\n    {\n      id: \"studyStartDate\",\n      label: \"Start Date\",\n      numeric: true,\n      renderCell: ({ studyStartDate }) =>\n        studyStartDate ? new Date(studyStartDate).getFullYear() : naLabel,\n    },\n    {\n      label: \"Source\",\n      renderCell: ({ urls }) => {\n        const urlList = urls.map(({ niceName, url }) => ({\n          name: sourceMap[niceName] ? sourceMap[niceName] : niceName,\n          url,\n          group: \"sources\",\n        }));\n        return <TableDrawer entries={urlList} caption=\"Sources\" />;\n      },\n      filterValue: ({ urls }) => {\n        const labels = urls.map(({ niceName }) =>\n          sourceMap[niceName] ? sourceMap[niceName] : niceName\n        );\n        return labels.join();\n      },\n    },\n  ];\n}\n\nfunction Body({ id, label, entity }) {\n  const { ensgId: ensemblId, efoId } = id;\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  const classes = useStyles();\n  const columns = getColumns(classes);\n\n  return (\n    <SectionItem\n      definition={definition}\n      chipText={dataTypesMap.known_drug}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={label.symbol} name={label.name} />}\n      renderBody={() => (\n        <OtTableSSP\n          query={CHEMBL_QUERY}\n          columns={columns}\n          dataDownloader\n          dataDownloaderColumns={exportColumns}\n          dataDownloaderFileStem=\"chembl-evidence\"\n          entity={entity}\n          sectionName=\"chembl\"\n          showGlobalFilter={false}\n          setInitialRequestData={(req) => {\n            setRequest(req);\n          }}\n          variables={{\n            ensemblId,\n            efoId,\n          }}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noUnsafeOptionalChaining",
      "severity": "error",
      "description": "Unsafe usage of optional chaining.",
      "message": [{ "elements": [], "content": "Unsafe usage of optional chaining." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "If it short-circuits with 'undefined' the evaluation will throw TypeError here:"
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6950, 6986],
              "sourceCode": "import { Box, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { epmcUrl, sentenceCase } from \"@ot/utils\";\nimport { useState } from \"react\";\nimport {\n  ChipList,\n  ClinvarStars,\n  DirectionOfEffectIcon,\n  DirectionOfEffectTooltip,\n  Link,\n  OtTableSSP,\n  PublicationsDrawer,\n  SectionItem,\n  Tooltip,\n} from \"ui\";\n\nimport { clinvarStarMap, dataTypesMap, naLabel } from \"@ot/constants\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport EVA_SOMATIC_QUERY from \"./EvaSomaticQuery.gql\";\n\nconst getColumns = (label) => [\n  {\n    id: \"disease.name\",\n    label: \"Disease/phenotype\",\n    renderCell: ({ disease, diseaseFromSource, cohortPhenotypes }) => (\n      <Tooltip\n        title={\n          <>\n            <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n              Reported disease or phenotype:\n            </Typography>\n            <Typography variant=\"caption\" display=\"block\" align=\"center\" gutterBottom>\n              {diseaseFromSource}\n            </Typography>\n\n            {cohortPhenotypes?.length > 1 ? (\n              <>\n                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                  All reported phenotypes:\n                </Typography>\n                <Typography variant=\"caption\" display=\"block\">\n                  {cohortPhenotypes.map((cp) => (\n                    <div key={cp}>{cp}</div>\n                  ))}\n                </Typography>\n              </>\n            ) : (\n              \"\"\n            )}\n          </>\n        }\n        showHelpIcon\n      >\n        <Link asyncTooltip to={`/disease/${disease.id}`}>\n          {disease.name}\n        </Link>\n      </Tooltip>\n    ),\n  },\n  {\n    id: \"variantId\",\n    label: \"Variant\",\n    enableHiding: false,\n    renderCell: ({ variant: { id: variantId } }) =>\n      variantId ? (\n        <>\n          {variantId.substring(0, 20)}\n          {variantId.length > 20 ? \"\\u2026\" : \"\"}\n        </>\n      ) : (\n        naLabel\n      ),\n    filterValue: ({ variant: { id: variantId } }) => `${variantId}`,\n  },\n  {\n    id: \"variantRsId\",\n    label: \"rsID\",\n    renderCell: ({ variantRsId }) =>\n      variantRsId ? (\n        <Link\n          external\n          to={`http://www.ensembl.org/Homo_sapiens/Variation/Explore?v=${variantRsId}`}\n        >\n          {variantRsId}\n        </Link>\n      ) : (\n        naLabel\n      ),\n    filterValue: ({ variantRsId }) => `${variantRsId}`,\n  },\n  {\n    id: \"variantHgvsId\",\n    label: \"HGVS ID\",\n    renderCell: ({ variant }) => variant.hgvsId || naLabel,\n    filterValue: ({ variant }) => `${variant.hgvsId}`,\n  },\n  {\n    id: \"studyId\",\n    label: \"ClinVar ID\",\n    renderCell: ({ studyId }) => (\n      <Link external to={`https://identifiers.org/clinvar.record/${studyId}`}>\n        {studyId}\n      </Link>\n    ),\n  },\n  {\n    id: \"clinicalSignificances\",\n    label: \"Clinical significance\",\n    renderCell: ({ clinicalSignificances }) => {\n      if (!clinicalSignificances) return naLabel;\n\n      if (clinicalSignificances.length === 1) return sentenceCase(clinicalSignificances[0]);\n\n      if (clinicalSignificances.length > 1)\n        return (\n          <ul\n            style={{\n              margin: 0,\n              padding: 0,\n              listStyle: \"none\",\n            }}\n          >\n            {clinicalSignificances.map((clinicalSignificance) => (\n              <li key={clinicalSignificance}>{sentenceCase(clinicalSignificance)}</li>\n            ))}\n          </ul>\n        );\n\n      return naLabel;\n    },\n    filterValue: ({ clinicalSignificances }) => clinicalSignificances.join(),\n  },\n  {\n    id: \"directionOfVariantEffect\",\n    label: (\n      <DirectionOfEffectTooltip docsUrl=\"https://platform-docs.opentargets.org/evidence#clinvar-somatic\" />\n    ),\n    renderCell: ({ variantEffect, directionOnTrait }) => {\n      return (\n        <DirectionOfEffectIcon variantEffect={variantEffect} directionOnTrait={directionOnTrait} />\n      );\n    },\n  },\n  {\n    id: \"allelicRequirements\",\n    label: \"Allele origin\",\n    renderCell: ({ alleleOrigins, allelicRequirements }) => {\n      if (!alleleOrigins || alleleOrigins.length === 0) return naLabel;\n\n      if (allelicRequirements)\n        return (\n          <Tooltip\n            title={\n              <>\n                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                  Allelic requirements:\n                </Typography>\n                {allelicRequirements.map((r) => (\n                  <Typography variant=\"caption\" key={r}>\n                    {r}\n                  </Typography>\n                ))}\n              </>\n            }\n            showHelpIcon\n          >\n            {alleleOrigins.map((a) => sentenceCase(a)).join(\"; \")}\n          </Tooltip>\n        );\n\n      return alleleOrigins.map((a) => sentenceCase(a)).join(\"; \");\n    },\n    filterValue: ({ alleleOrigins }) => (alleleOrigins ? alleleOrigins.join() : \"\"),\n  },\n  {\n    label: \"Review status\",\n    renderCell: ({ confidence }) => (\n      <Tooltip title={confidence}>\n        <span>\n          <ClinvarStars num={clinvarStarMap[confidence]} />\n        </span>\n      </Tooltip>\n    ),\n  },\n  {\n    label: \"Literature\",\n    renderCell: ({ literature }) => {\n      const literatureList =\n        literature?.reduce((acc, id) => {\n          if (id !== \"NA\") {\n            acc.push({\n              name: id,\n              url: epmcUrl(id),\n              group: \"literature\",\n            });\n          }\n          return acc;\n        }, []) || [];\n\n      return (\n        <PublicationsDrawer entries={literatureList} symbol={label.symbol} name={label.name} />\n      );\n    },\n  },\n];\n\nconst exportColumns = [\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"variantId\",\n    exportValue: (row) => row.variantId,\n  },\n  {\n    label: \"variantRsId\",\n    exportValue: (row) => row.variantRsId,\n  },\n  {\n    label: \"variantHgvsId\",\n    exportValue: (row) => row.variantHgvsId,\n  },\n  {\n    label: \"clinicalSignificances\",\n    exportValue: (row) => row.clinicalSignificances,\n  },\n  {\n    label: \"allelicRequirements\",\n    exportValue: (row) => row.allelicRequirements,\n  },\n  {\n    label: \"reviewStatus\",\n    exportValue: (row) => row.confidence,\n  },\n\n  {\n    label: \"literature\",\n    exportValue: (row) => row.literature,\n  },\n];\n\nconst useStyles = makeStyles({\n  roleInCancerBox: {\n    display: \"flex\",\n    alignItems: \"center\",\n    marginBottom: \"2rem\",\n  },\n  roleInCancerTitle: { marginRight: \".5rem !important\" },\n});\n\nfunction Body({ id, label, entity }) {\n  const classes = useStyles();\n\n  const { ensgId: ensemblId, efoId } = id;\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  const columns = getColumns(label);\n\n  function getRoleInCancer() {\n    if (!request.data) return null;\n\n    const { hallmarks } = request.data?.target;\n    let roleInCancerItems = [{ label: \"Unknown\" }];\n    if (hallmarks && hallmarks.attributes.length > 0) {\n      roleInCancerItems = hallmarks.attributes\n        .filter((attribute) => attribute.name === \"role in cancer\")\n        .map((attribute) => ({\n          label: attribute.description,\n          url: epmcUrl(attribute.pmid),\n        }));\n    }\n\n    return (\n      <>\n        <Typography className={classes.roleInCancerTitle}>\n          <b>{label.symbol}</b> role in cancer:\n        </Typography>\n        <ChipList items={roleInCancerItems} />\n      </>\n    );\n  }\n\n  return (\n    <SectionItem\n      definition={definition}\n      chipText={dataTypesMap.somatic_mutation}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description symbol={label.symbol} name={label.name} />}\n      renderBody={() => (\n        <>\n          <Box className={classes.roleInCancerBox}>{getRoleInCancer()}</Box>\n\n          <OtTableSSP\n            query={EVA_SOMATIC_QUERY}\n            columns={columns}\n            dataDownloader\n            dataDownloaderColumns={exportColumns}\n            dataDownloaderFileStem=\"eva_somatic-evidence\"\n            entity={entity}\n            sectionName=\"eva_somatic\"\n            showGlobalFilter={false}\n            setInitialRequestData={(req) => {\n              setRequest(req);\n            }}\n            variables={{\n              ensemblId,\n              efoId,\n            }}\n          />\n        </>\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/EVASomatic/Body.jsx" },
        "span": [6978, 6980],
        "sourceCode": "import { Box, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { epmcUrl, sentenceCase } from \"@ot/utils\";\nimport { useState } from \"react\";\nimport {\n  ChipList,\n  ClinvarStars,\n  DirectionOfEffectIcon,\n  DirectionOfEffectTooltip,\n  Link,\n  OtTableSSP,\n  PublicationsDrawer,\n  SectionItem,\n  Tooltip,\n} from \"ui\";\n\nimport { clinvarStarMap, dataTypesMap, naLabel } from \"@ot/constants\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport EVA_SOMATIC_QUERY from \"./EvaSomaticQuery.gql\";\n\nconst getColumns = (label) => [\n  {\n    id: \"disease.name\",\n    label: \"Disease/phenotype\",\n    renderCell: ({ disease, diseaseFromSource, cohortPhenotypes }) => (\n      <Tooltip\n        title={\n          <>\n            <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n              Reported disease or phenotype:\n            </Typography>\n            <Typography variant=\"caption\" display=\"block\" align=\"center\" gutterBottom>\n              {diseaseFromSource}\n            </Typography>\n\n            {cohortPhenotypes?.length > 1 ? (\n              <>\n                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                  All reported phenotypes:\n                </Typography>\n                <Typography variant=\"caption\" display=\"block\">\n                  {cohortPhenotypes.map((cp) => (\n                    <div key={cp}>{cp}</div>\n                  ))}\n                </Typography>\n              </>\n            ) : (\n              \"\"\n            )}\n          </>\n        }\n        showHelpIcon\n      >\n        <Link asyncTooltip to={`/disease/${disease.id}`}>\n          {disease.name}\n        </Link>\n      </Tooltip>\n    ),\n  },\n  {\n    id: \"variantId\",\n    label: \"Variant\",\n    enableHiding: false,\n    renderCell: ({ variant: { id: variantId } }) =>\n      variantId ? (\n        <>\n          {variantId.substring(0, 20)}\n          {variantId.length > 20 ? \"\\u2026\" : \"\"}\n        </>\n      ) : (\n        naLabel\n      ),\n    filterValue: ({ variant: { id: variantId } }) => `${variantId}`,\n  },\n  {\n    id: \"variantRsId\",\n    label: \"rsID\",\n    renderCell: ({ variantRsId }) =>\n      variantRsId ? (\n        <Link\n          external\n          to={`http://www.ensembl.org/Homo_sapiens/Variation/Explore?v=${variantRsId}`}\n        >\n          {variantRsId}\n        </Link>\n      ) : (\n        naLabel\n      ),\n    filterValue: ({ variantRsId }) => `${variantRsId}`,\n  },\n  {\n    id: \"variantHgvsId\",\n    label: \"HGVS ID\",\n    renderCell: ({ variant }) => variant.hgvsId || naLabel,\n    filterValue: ({ variant }) => `${variant.hgvsId}`,\n  },\n  {\n    id: \"studyId\",\n    label: \"ClinVar ID\",\n    renderCell: ({ studyId }) => (\n      <Link external to={`https://identifiers.org/clinvar.record/${studyId}`}>\n        {studyId}\n      </Link>\n    ),\n  },\n  {\n    id: \"clinicalSignificances\",\n    label: \"Clinical significance\",\n    renderCell: ({ clinicalSignificances }) => {\n      if (!clinicalSignificances) return naLabel;\n\n      if (clinicalSignificances.length === 1) return sentenceCase(clinicalSignificances[0]);\n\n      if (clinicalSignificances.length > 1)\n        return (\n          <ul\n            style={{\n              margin: 0,\n              padding: 0,\n              listStyle: \"none\",\n            }}\n          >\n            {clinicalSignificances.map((clinicalSignificance) => (\n              <li key={clinicalSignificance}>{sentenceCase(clinicalSignificance)}</li>\n            ))}\n          </ul>\n        );\n\n      return naLabel;\n    },\n    filterValue: ({ clinicalSignificances }) => clinicalSignificances.join(),\n  },\n  {\n    id: \"directionOfVariantEffect\",\n    label: (\n      <DirectionOfEffectTooltip docsUrl=\"https://platform-docs.opentargets.org/evidence#clinvar-somatic\" />\n    ),\n    renderCell: ({ variantEffect, directionOnTrait }) => {\n      return (\n        <DirectionOfEffectIcon variantEffect={variantEffect} directionOnTrait={directionOnTrait} />\n      );\n    },\n  },\n  {\n    id: \"allelicRequirements\",\n    label: \"Allele origin\",\n    renderCell: ({ alleleOrigins, allelicRequirements }) => {\n      if (!alleleOrigins || alleleOrigins.length === 0) return naLabel;\n\n      if (allelicRequirements)\n        return (\n          <Tooltip\n            title={\n              <>\n                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                  Allelic requirements:\n                </Typography>\n                {allelicRequirements.map((r) => (\n                  <Typography variant=\"caption\" key={r}>\n                    {r}\n                  </Typography>\n                ))}\n              </>\n            }\n            showHelpIcon\n          >\n            {alleleOrigins.map((a) => sentenceCase(a)).join(\"; \")}\n          </Tooltip>\n        );\n\n      return alleleOrigins.map((a) => sentenceCase(a)).join(\"; \");\n    },\n    filterValue: ({ alleleOrigins }) => (alleleOrigins ? alleleOrigins.join() : \"\"),\n  },\n  {\n    label: \"Review status\",\n    renderCell: ({ confidence }) => (\n      <Tooltip title={confidence}>\n        <span>\n          <ClinvarStars num={clinvarStarMap[confidence]} />\n        </span>\n      </Tooltip>\n    ),\n  },\n  {\n    label: \"Literature\",\n    renderCell: ({ literature }) => {\n      const literatureList =\n        literature?.reduce((acc, id) => {\n          if (id !== \"NA\") {\n            acc.push({\n              name: id,\n              url: epmcUrl(id),\n              group: \"literature\",\n            });\n          }\n          return acc;\n        }, []) || [];\n\n      return (\n        <PublicationsDrawer entries={literatureList} symbol={label.symbol} name={label.name} />\n      );\n    },\n  },\n];\n\nconst exportColumns = [\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"variantId\",\n    exportValue: (row) => row.variantId,\n  },\n  {\n    label: \"variantRsId\",\n    exportValue: (row) => row.variantRsId,\n  },\n  {\n    label: \"variantHgvsId\",\n    exportValue: (row) => row.variantHgvsId,\n  },\n  {\n    label: \"clinicalSignificances\",\n    exportValue: (row) => row.clinicalSignificances,\n  },\n  {\n    label: \"allelicRequirements\",\n    exportValue: (row) => row.allelicRequirements,\n  },\n  {\n    label: \"reviewStatus\",\n    exportValue: (row) => row.confidence,\n  },\n\n  {\n    label: \"literature\",\n    exportValue: (row) => row.literature,\n  },\n];\n\nconst useStyles = makeStyles({\n  roleInCancerBox: {\n    display: \"flex\",\n    alignItems: \"center\",\n    marginBottom: \"2rem\",\n  },\n  roleInCancerTitle: { marginRight: \".5rem !important\" },\n});\n\nfunction Body({ id, label, entity }) {\n  const classes = useStyles();\n\n  const { ensgId: ensemblId, efoId } = id;\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  const columns = getColumns(label);\n\n  function getRoleInCancer() {\n    if (!request.data) return null;\n\n    const { hallmarks } = request.data?.target;\n    let roleInCancerItems = [{ label: \"Unknown\" }];\n    if (hallmarks && hallmarks.attributes.length > 0) {\n      roleInCancerItems = hallmarks.attributes\n        .filter((attribute) => attribute.name === \"role in cancer\")\n        .map((attribute) => ({\n          label: attribute.description,\n          url: epmcUrl(attribute.pmid),\n        }));\n    }\n\n    return (\n      <>\n        <Typography className={classes.roleInCancerTitle}>\n          <b>{label.symbol}</b> role in cancer:\n        </Typography>\n        <ChipList items={roleInCancerItems} />\n      </>\n    );\n  }\n\n  return (\n    <SectionItem\n      definition={definition}\n      chipText={dataTypesMap.somatic_mutation}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description symbol={label.symbol} name={label.name} />}\n      renderBody={() => (\n        <>\n          <Box className={classes.roleInCancerBox}>{getRoleInCancer()}</Box>\n\n          <OtTableSSP\n            query={EVA_SOMATIC_QUERY}\n            columns={columns}\n            dataDownloader\n            dataDownloaderColumns={exportColumns}\n            dataDownloaderFileStem=\"eva_somatic-evidence\"\n            entity={entity}\n            sectionName=\"eva_somatic\"\n            showGlobalFilter={false}\n            setInitialRequestData={(req) => {\n              setRequest(req);\n            }}\n            variables={{\n              ensemblId,\n              efoId,\n            }}\n          />\n        </>\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: name",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: name" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3148, 3152],
              "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/EuropePmc/Publication.jsx" },
        "span": [2973, 2982],
        "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: requestSummary",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: requestSummary"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3367, 3381],
              "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/EuropePmc/Publication.jsx" },
        "span": [2973, 2982],
        "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: symbol",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: symbol" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3132, 3138],
              "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/EuropePmc/Publication.jsx" },
        "span": [2973, 2982],
        "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: pmcId",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: pmcId" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3117, 3122],
              "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/EuropePmc/Publication.jsx" },
        "span": [2973, 2982],
        "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: summaryText",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: summaryText"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3442, 3453],
              "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/EuropePmc/Publication.jsx" },
        "span": [2973, 2982],
        "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: title",
      "message": [
        { "elements": [], "content": "This hook specifies more dependencies than necessary: title" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Outer scope values aren't valid dependencies because mutating them doesn't re-render the component."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3647, 3652],
              "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/EuropePmc/Publication.jsx" },
        "span": [3515, 3524],
        "sourceCode": "import { faCircleMinus, faCircleNodes, faCirclePlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\nimport { PublicationSummaryLabel, SummaryLoader, useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { publicationSummaryQuery } from \"@ot/utils\";\n\nimport { naLabel } from \"@ot/constants\";\nimport SimplePublication from \"../../common/Bibliography/SimplePublication\";\nimport SentenceMatch from \"./SentenceMatch\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    // margin: \"1rem !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    marginBottom: \"10px\",\n    padding: \"25px 20px\",\n    position: \"relative\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  btnsContainer: {\n    marginTop: \"1rem\",\n    marginBottom: \"1rem\",\n    display: \"flex\",\n    gap: \"2rem\",\n  },\n}));\n\nfunction Publication({\n  europePmcId,\n  title,\n  abstract,\n  textMiningSentences,\n  authors,\n  journal,\n  source = \"MED\",\n  patentDetails = null,\n  isOpenAccess,\n  symbol,\n  name,\n  pmcId,\n  fullTextOpen = false,\n}) {\n  const classes = useStyles();\n  const [showAbstract, setShowAbstract] = useState(false);\n  const [showMatches, setShowMatches] = useState(false);\n  const [showSummary, setShowSummary] = useState(false);\n  const [summaryText, setSummaryText] = useState(null);\n  const [error, setError] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract((current) => !current);\n  };\n\n  const handleShowMatchesClick = () => {\n    setShowMatches((current) => !current);\n  };\n\n  const handleShowSummaryClick = () => {\n    setShowSummary((current) => !current);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (showSummary && summaryText === null) {\n      fetchData();\n    }\n  }, [showSummary]);\n\n  useEffect(() => {\n    setShowAbstract(false);\n    setShowMatches(false);\n    setShowSummary(false);\n    setSummaryText(null);\n  }, [title]);\n\n  if (!title) {\n    return naLabel;\n  }\n\n  return (\n    <Box>\n      <SimplePublication\n        pmId={europePmcId}\n        titleHtml={title}\n        authors={authors}\n        source={source}\n        patentDetails={patentDetails}\n        journal={{\n          title: journal?.journal?.title,\n          date: journal?.yearOfPublication?.toString(),\n          ref: {\n            volume: journal.volume,\n            issue: journal.issue,\n            pgn: journal.page || naLabel,\n          },\n        }}\n      />\n      <div className={classes.btnsContainer}>\n        {fullTextOpen && isOpenAccess && urlAiApi && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n            onClick={handleShowSummaryClick}\n          >\n            {showSummary ? \"Hide summary\" : \"Show summary\"}\n          </Button>\n        )}\n        {abstract && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showAbstract ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowAbstractClick}\n          >\n            {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n          </Button>\n        )}\n        {textMiningSentences && (\n          <Button\n            className={classes.detailsButton}\n            variant=\"outlined\"\n            size=\"small\"\n            startIcon={\n              showMatches ? (\n                <FontAwesomeIcon icon={faCircleMinus} />\n              ) : (\n                <FontAwesomeIcon icon={faCirclePlus} />\n              )\n            }\n            onClick={handleShowMatchesClick}\n          >\n            {showMatches\n              ? \"Hide match details\"\n              : `Show ${textMiningSentences.length} match details`}\n          </Button>\n        )}\n      </div>\n      <Box>\n        {showSummary && (\n          <Box className={classes.detailPanel}>\n            {loading && <SummaryLoader />}\n            {!loading && error && (\n              <>\n                <span className={classes.abstractSpan}>\n                  <b>Error: </b>\n                  {error}\n                </span>\n                <br />\n                <br />\n                <button type=\"button\" onClick={onClickRetry}>\n                  Retry request\n                </button>\n              </>\n            )}\n            {!loading && !error && (\n              <>\n                <Typography variant=\"subtitle2\">Evidence summary</Typography>\n                <span className={classes.abstractSpan}>{summaryText}</span>\n              </>\n            )}\n            <PublicationSummaryLabel />\n          </Box>\n        )}\n        {showAbstract && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Abstract</Typography>\n            <span className={classes.abstractSpan}>{abstract}</span>\n          </Box>\n        )}\n        {showMatches && (\n          <Box className={classes.detailPanel}>\n            <Typography variant=\"subtitle2\">Matches</Typography>\n            <table className={classes.matchTable}>\n              <tbody>\n                {textMiningSentences.map((match) => (\n                  <SentenceMatch key={v1()} match={match} />\n                ))}\n              </tbody>\n            </table>\n          </Box>\n        )}\n      </Box>\n    </Box>\n  );\n}\n\nexport default Publication;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/GenomicsEngland/Body.jsx" },
        "span": [4498, 4504],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { faCheckSquare, faExclamationTriangle } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Typography } from \"@mui/material\";\nimport { Link, OtTable, PublicationsDrawer, SectionItem, Tooltip } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport { dataTypesMap, naLabel, sectionsBaseSizeQuery } from \"@ot/constants\";\nimport { epmcUrl, sentenceCase } from \"@ot/utils\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\n\nimport GENOMICS_ENGLAND_QUERY from \"./sectionQuery.gql\";\n\nconst geUrl = (id, approvedSymbol) =>\n  `https://panelapp.genomicsengland.co.uk/panels/${id}/gene/${approvedSymbol}`;\n\nconst confidenceCaption = (confidence) =>\n  ({\n    green: (\n      <span style={{ color: \"#3fad46\" }}>\n        <FontAwesomeIcon icon={faCheckSquare} size=\"sm\" /> {sentenceCase(confidence)}\n      </span>\n    ),\n    amber: (\n      <span style={{ color: \"#f0ad4e\" }}>\n        <FontAwesomeIcon icon={faExclamationTriangle} size=\"sm\" /> {sentenceCase(confidence)}\n      </span>\n    ),\n  })[confidence];\n\nconst confidenceMap = (confidence) =>\n  ({\n    green: 20,\n    amber: 10,\n  })[confidence?.toLowerCase()] || 0;\n\nconst allelicRequirementsCaption = (allelicRequirements) => {\n  const caption = sentenceCase(allelicRequirements.split(\" \", 1)[0].replace(/[;:,]*/g, \"\"));\n  const description =\n    allelicRequirements.split(\" \").slice(1).join(\" \") || \"No more information available\";\n\n  return [caption, description];\n};\n\nconst getColumns = (label) => [\n  {\n    id: \"disease\",\n    label: \"Disease/phenotype\",\n    enableHiding: false,\n    renderCell: ({ disease, diseaseFromSource, cohortPhenotypes }) => (\n      <Tooltip\n        title={\n          <>\n            <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n              Reported disease or phenotype:\n            </Typography>\n            <Typography variant=\"caption\" display=\"block\" align=\"center\" gutterBottom>\n              {sentenceCase(diseaseFromSource)}\n            </Typography>\n\n            {cohortPhenotypes?.length > 1 ? (\n              <>\n                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                  All reported phenotypes:\n                </Typography>\n                <Typography variant=\"caption\" display=\"block\">\n                  {cohortPhenotypes.map((cp) => (\n                    <div key={cp}>{cp}</div>\n                  ))}\n                </Typography>\n              </>\n            ) : (\n              \"\"\n            )}\n          </>\n        }\n        showHelpIcon\n      >\n        <Link asyncTooltip to={`/disease/${disease.id}`}>\n          {disease.name}\n        </Link>\n      </Tooltip>\n    ),\n    filterValue: ({ disease, diseaseFromSource }) => [disease.name, diseaseFromSource].join(),\n  },\n  {\n    id: \"allelicRequirements\",\n    label: \"Allelic Requirement\",\n    renderCell: ({ allelicRequirements }) =>\n      allelicRequirements\n        ? allelicRequirements.map((item) => {\n            const [caption, description] = allelicRequirementsCaption(item);\n\n            return (\n              <Tooltip key={v1()} placement=\"top\" title={description} showHelpIcon>\n                {caption}\n              </Tooltip>\n            );\n          })\n        : naLabel,\n  },\n  {\n    id: \"studyOverview\",\n    label: \"Genomics England Panel\",\n    enableHiding: false,\n    renderCell: ({ studyOverview, studyId, target: { approvedSymbol } }) =>\n      studyOverview && studyId && approvedSymbol ? (\n        <Link external to={geUrl(studyId, approvedSymbol)}>\n          {studyOverview}\n        </Link>\n      ) : (\n        naLabel\n      ),\n  },\n  {\n    id: \"confidence\",\n    label: \"Gene rating\",\n    sortable: true,\n    renderCell: ({ confidence }) => (\n      <Tooltip\n        title={\n          <Typography variant=\"caption\" display=\"block\" align=\"center\">\n            As defined by the{\" \"}\n            <Link external to=\"https://panelapp.genomicsengland.co.uk/#!Guidelines\">\n              Panel App Guidelines\n            </Link>\n          </Typography>\n        }\n        showHelpIcon\n      >\n        {confidenceCaption(confidence)}\n      </Tooltip>\n    ),\n    comparator: (a, b) => confidenceMap(a.confidence) - confidenceMap(b.confidence),\n  },\n  {\n    id: \"literature\",\n    renderCell: ({ literature }) => {\n      const literatureList =\n        literature?.reduce((acc, id) => {\n          if (id === \"NA\") return acc;\n\n          return [\n            ...acc,\n            {\n              name: id,\n              url: epmcUrl(id),\n              group: \"literature\",\n            },\n          ];\n        }, []) || [];\n\n      return (\n        <PublicationsDrawer symbol={label.symbol} name={label.name} entries={literatureList} />\n      );\n    },\n  },\n];\n\nexport function Body({ id, label, entity }) {\n  const { ensgId, efoId } = id;\n  const variables = {\n    ensemblId: ensgId,\n    efoId,\n    size: sectionsBaseSizeQuery,\n  };\n\n  const request = useQuery(GENOMICS_ENGLAND_QUERY, {\n    variables,\n  });\n\n  const columns = getColumns(label);\n\n  return (\n    <SectionItem\n      definition={definition}\n      chipText={dataTypesMap.genetic_association}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description symbol={label.symbol} name={label.name} />}\n      renderBody={() => (\n        <OtTable\n          columns={columns}\n          dataDownloader\n          dataDownloaderFileStem={`otgenetics-${ensgId}-${efoId}`}\n          order=\"desc\"\n          rows={request.data?.disease.genomicsEngland.rows}\n          showGlobalFilter\n          sortBy=\"confidence\"\n          query={GENOMICS_ENGLAND_QUERY.loc.source.body}\n          variables={variables}\n          loading={request.loading}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: location.pathname",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: location.pathname"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [200, 217],
              "sourceCode": "import { useEffect } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst ScrollToTop = () => {\n  const location = useLocation();\n\n  useEffect(() => {\n    window.scrollTo(0, 0);\n  }, [location.pathname]);\n\n  return null;\n};\n\nexport default ScrollToTop;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ScrollToTop.tsx" },
        "span": [149, 158],
        "sourceCode": "import { useEffect } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nconst ScrollToTop = () => {\n  const location = useLocation();\n\n  useEffect(() => {\n    window.scrollTo(0, 0);\n  }, [location.pathname]);\n\n  return null;\n};\n\nexport default ScrollToTop;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/evidence/Reactome/Body.jsx" },
        "span": [3492, 3698],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { Typography } from \"@mui/material\";\nimport {\n  EllsWrapper,\n  Link,\n  OtTable,\n  PublicationsDrawer,\n  SectionItem,\n  TableDrawer,\n  Tooltip,\n} from \"ui\";\n\nimport { epmcUrl, sentenceCase } from \"@ot/utils\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\n\nimport {\n  dataTypesMap,\n  defaultRowsPerPageOptions,\n  naLabel,\n  sectionsBaseSizeQuery,\n} from \"@ot/constants\";\nimport REACTOME_QUERY from \"./sectionQuery.gql\";\n\nconst getColumns = (label) => [\n  {\n    id: \"disease\",\n    label: \"Disease / phenotype\",\n    renderCell: ({ disease, diseaseFromSource }) => (\n      <Tooltip\n        title={\n          <>\n            <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n              Reported disease or phenotype:\n            </Typography>\n            <Typography variant=\"caption\" display=\"block\" align=\"center\">\n              {diseaseFromSource}\n            </Typography>\n          </>\n        }\n        showHelpIcon\n      >\n        <Link asyncTooltip to={`/disease/${disease.id}`}>\n          <EllsWrapper>{disease.name}</EllsWrapper>\n        </Link>\n      </Tooltip>\n    ),\n    width: \"18%\",\n  },\n  {\n    id: \"pathways\",\n    label: \"Pathway\",\n    renderCell: ({ pathways }) => {\n      if (!pathways || pathways.length === 0) {\n        return naLabel;\n      }\n      if (pathways.length === 1) {\n        return (\n          <Link external to={`http://www.reactome.org/PathwayBrowser/#${pathways[0].id}`}>\n            <EllsWrapper>{pathways[0].name}</EllsWrapper>\n          </Link>\n        );\n      }\n      const refs = pathways.map((p) => ({\n        url: `http://www.reactome.org/PathwayBrowser/#${p.id}`,\n        name: p.name,\n        group: \"Pathways\",\n      }));\n      return <TableDrawer entries={refs} message={`${refs.length} pathways`} />;\n    },\n    width: \"17%\",\n  },\n  {\n    id: \"reactionId\",\n    label: \"Reaction\",\n    enableHiding: false,\n    renderCell: ({ reactionName, reactionId }) => (\n      <Link external to={`https://identifiers.org/reactome/${reactionId}`}>\n        <EllsWrapper>{reactionName}</EllsWrapper>\n      </Link>\n    ),\n    width: \"17%\",\n  },\n  {\n    id: \"targetFromSourceId\",\n    label: \"Reported target\",\n    renderCell: ({ targetFromSourceId }) => (\n      <Link external to={`https://identifiers.org/uniprot/${targetFromSourceId}`}>\n        <EllsWrapper>{targetFromSourceId}</EllsWrapper>\n      </Link>\n    ),\n    width: \"12%\",\n  },\n  {\n    id: \"targetModulation\",\n    label: \"Target modulation\",\n    renderCell: ({ targetModulation }) =>\n      targetModulation ? <EllsWrapper>{sentenceCase(targetModulation)}</EllsWrapper> : naLabel,\n    filterValue: ({ targetModulation }) => sentenceCase(targetModulation),\n    width: \"12%\",\n  },\n  {\n    id: \"variantAminoacidDescriptions\",\n    label: \"Amino acid variation\",\n    renderCell: ({ variantAminoacidDescriptions }) => {\n      if (variantAminoacidDescriptions?.length === 1) {\n        return <EllsWrapper>{variantAminoacidDescriptions[0]}</EllsWrapper>;\n      }\n      if (variantAminoacidDescriptions?.length > 1) {\n        return (\n          <TableDrawer\n            entries={variantAminoacidDescriptions.map((d) => ({\n              name: d,\n              group: \"Amino acid variation\",\n            }))}\n          />\n        );\n      }\n      return naLabel;\n    },\n    width: \"12%\",\n  },\n  {\n    id: \"literature\",\n    label: \"Literature\",\n    renderCell: ({ literature = [] }) => {\n      const literatureList = [];\n      literature?.forEach((id) => {\n        if (id !== \"NA\") {\n          literatureList.push({\n            name: id,\n            url: epmcUrl(id),\n            group: \"literature\",\n          });\n        }\n      });\n      return (\n        <PublicationsDrawer entries={literatureList} symbol={label.symbol} name={label.name} />\n      );\n    },\n    width: \"12%\",\n  },\n];\n\nfunction Body({ id, label, entity }) {\n  const { ensgId, efoId } = id;\n\n  const variables = {\n    ensemblId: ensgId,\n    efoId,\n    size: sectionsBaseSizeQuery,\n  };\n\n  const request = useQuery(REACTOME_QUERY, {\n    variables,\n  });\n\n  const columns = getColumns(label);\n\n  return (\n    <SectionItem\n      definition={definition}\n      chipText={dataTypesMap.affected_pathway}\n      request={request}\n      entity={entity}\n      renderDescription={() => <Description symbol={label.symbol} name={label.name} />}\n      renderBody={() => {\n        return (\n          <OtTable\n            columns={columns}\n            rows={request.data?.disease.reactomeSummary.rows}\n            dataDownloader\n            showGlobalFilter\n            rowsPerPageOptions={defaultRowsPerPageOptions}\n            fixed\n            noWrapHeader={false}\n            query={REACTOME_QUERY.loc.source.body}\n            variables={variables}\n            loading={request.loading}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/study/SharedTraitStudies/Body.tsx" },
        "span": [1997, 2008],
        "sourceCode": "import { Box, Typography } from \"@mui/material\";\nimport { naLabel, table5HChunkSize } from \"@ot/constants\";\nimport { epmcUrl, getStudyCategory } from \"@ot/utils\";\nimport { Fragment, type ReactElement } from \"react\";\nimport { Link, OtTable, PublicationsDrawer, SectionItem, Tooltip, useBatchQuery } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport SHARED_TRAIT_STUDIES_QUERY from \"./SharedTraitStudiesQuery.gql\";\n\nfunction getColumns(diseaseIds: string[]) {\n  const diseaseIdsSet = new Set(diseaseIds);\n  return [\n    {\n      id: \"studyId\",\n      label: \"Study\",\n      enableHiding: false,\n      renderCell: ({ id }) => (\n        <Link asyncTooltip to={`/study/${id}`}>\n          {id}\n        </Link>\n      ),\n      exportValue: ({ id }) => id,\n    },\n    {\n      id: \"sharedDiseases\",\n      label: \"Shared disease/phenotype\",\n      renderCell: ({ diseases }) => {\n        const sharedTraits = diseases.filter((d) => diseaseIdsSet.has(d.id));\n        return (\n          <>\n            {sharedTraits.map(({ id, name }, index) => (\n              <Fragment key={id}>\n                {index > 0 ? \", \" : null}\n                <Link asyncTooltip to={`/disease/${id}`}>\n                  {name}\n                </Link>\n              </Fragment>\n            ))}\n          </>\n        );\n      },\n      exportValue: ({ diseases }) =>\n        diseases\n          .filter((d) => diseaseIdsSet.has(d.id))\n          .map(({ name }) => name)\n          .join(\", \"),\n    },\n    {\n      id: \"traitFromSource\",\n      label: \"Reported trait\",\n    },\n    {\n      id: \"nSamples\",\n      label: \"Sample size\",\n      numeric: true,\n      renderCell: ({ nSamples }) => {\n        return typeof nSamples === \"number\" ? nSamples.toLocaleString() : naLabel;\n      },\n      comparator: (a, b) => a?.nSamples - b?.nSamples,\n      sortable: true,\n    },\n    {\n      id: \"cohorts\",\n      label: \"Cohorts\",\n      renderCell: ({ projectId, cohorts, ldPopulationStructure }) => {\n        let displayText;\n        if (getStudyCategory(projectId) === \"FINNGEN\") displayText = \"FinnGen\";\n        else if (cohorts?.length) displayText = cohorts.join(\", \");\n        else return naLabel;\n        return ldPopulationStructure?.length ? (\n          <Tooltip\n            title={\n              <>\n                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\">\n                  LD populations and relative sample sizes\n                </Typography>\n                {ldPopulationStructure.map(({ ldPopulation, relativeSampleSize }) => (\n                  <Box key={ldPopulation}>\n                    <Typography variant=\"caption\">\n                      {ldPopulation}: {relativeSampleSize}\n                    </Typography>\n                  </Box>\n                ))}\n              </>\n            }\n            showHelpIcon\n          >\n            {displayText}\n          </Tooltip>\n        ) : (\n          displayText\n        );\n      },\n      exportValue: ({ projectId, cohorts }) =>\n        getStudyCategory(projectId) === \"FINNGEN\"\n          ? \"FinnGen\"\n          : cohorts?.length\n            ? cohorts.join(\", \")\n            : null,\n    },\n    {\n      id: \"publication\",\n      label: \"Publication\",\n      renderCell: ({ publicationFirstAuthor, publicationDate, pubmedId }) => {\n        if (!publicationFirstAuthor) return naLabel;\n        return (\n          <PublicationsDrawer\n            entries={[{ name: pubmedId, url: epmcUrl(pubmedId) }]}\n            customLabel={`${publicationFirstAuthor} et al. (${new Date(\n              publicationDate\n            ).getFullYear()})`}\n          />\n        );\n      },\n      filterValue: ({ publicationYear, publicationFirstAuthor }) =>\n        `${publicationYear} ${publicationFirstAuthor}`,\n      exportValue: ({ pubmedId }) => `${pubmedId}`,\n    },\n  ];\n}\n\ntype BodyProps = {\n  studyId: string;\n  diseaseIds: string[];\n};\n\nexport function Body({ studyId, diseaseIds }: BodyProps): ReactElement {\n  const variables = {\n    diseaseIds: diseaseIds,\n    size: table5HChunkSize,\n    index: 0,\n  };\n\n  const request = useBatchQuery({\n    query: SHARED_TRAIT_STUDIES_QUERY,\n    variables,\n    dataPath: \"studies\",\n    size: table5HChunkSize,\n  });\n\n  const columns = getColumns(diseaseIds);\n\n  const rows = request.data?.studies?.rows?.filter((row) => {\n    return row.id !== studyId;\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      request={request}\n      entity={\"studies\"}\n      showContentLoading\n      loadingMessage=\"Loading data. This may take some time...\"\n      renderDescription={() => <Description studyId={studyId} />}\n      renderBody={() => {\n        return (\n          <OtTable\n            columns={columns}\n            rows={rows}\n            loading={request.loading}\n            sortBy=\"nSamples\"\n            order=\"desc\"\n            dataDownloader\n            query={SHARED_TRAIT_STUDIES_QUERY.loc.source.body}\n            variables={variables}\n          />\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/ChimpanzeeIcon.tsx" },
        "span": [163, 204],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction ChimpanzeeIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1000 1032\">\n      <path\n        fill={theme.palette.text.primary}\n        transform=\"rotate(180, 500, 484)\"\n        d=\"M870.256 12.16c-10.528 7.872-13.152 47.264-13.152 57.744 0 10.496 5.216 97.168 15.744 123.424 10.496 26.24 15.744 168.032 7.872 186.4-7.872 18.384-115.504 202.192-118.16 223.184-2.592 20.992-47.216 86.64-52.496 112.896-5.216 26.272-36.752 47.28-55.12 60.4-18.4 13.12-42.032 23.632-42.032 23.632s13.152 57.76 5.28 84.016c-7.872 26.272-18.4 42.016-28.944 49.888-10.432 7.888-44.592-7.872-44.592-7.872s-36.8 34.128-97.168 34.128c-60.368 0-86.64-42-86.64-42s-31.504 15.728-49.872 10.496c-18.368-5.248-39.424-21.008-28.896-39.376s34.16-36.752 36.768-60.384c2.624-23.632 0-76.128 0-76.128s-60.368-115.536-65.632-136.544-76.16-133.904-76.16-133.904-42.032-52.496-44.64-76.144c-2.624-23.632 10.528-99.776 10.528-131.296 0-31.504 2.64-152.272 0-165.408-2.656-13.136 2.576-76.128 13.104-97.136s39.392-20.992 63.008-31.52c23.632-10.512 55.136-13.104 68.288 0 13.136 13.104 26.24 23.648 23.632 34.128-2.624 10.496-13.136 18.368-21.008 18.368-7.888 0-28.864 5.264-28.864 15.744 0 10.528 20.992 31.52 20.992 31.52s28.928 10.512 42.032 10.512c13.104 0 44.624-18.4 44.624-18.4s10.496-26.24 23.632-26.24c13.136 0-23.632-31.52-18.368-47.264s5.264-21.008 23.632-21.008c18.368 0 28.864 18.4 42 13.136s5.264-15.712 21.008-18.368c15.76-2.64 36.768 5.232 36.768 5.232s23.616-7.872 42-2.608c18.336 5.248 49.84 13.12 49.84 13.12s42.032-13.088 55.152 0c13.152 13.104 18.4 21.008 26.288 23.648 7.872 2.608 31.504-5.232 39.376-7.872 7.872-2.656 26.288-23.648 26.288-23.648s-13.12-34.16 5.216-36.768c18.384-2.624 34.128-7.888 57.76-7.888 23.664 0 44.624 2.64 57.744 13.136 13.152 10.48 20.976 15.744 23.632 31.504 2.624 15.76 0 23.648-10.464 31.52zM347.728 369.232c-7.872-36.784-7.872-94.528-23.632-86.656-15.744 7.872-68.272 31.52-70.896 44.656s18.368 60.368 26.256 68.256c7.872 7.872 55.136 97.168 55.136 97.168 34.128-52.512 21.024-86.656 13.136-123.424z\"\n      />\n    </svg>\n  );\n}\n\nexport default ChimpanzeeIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/FrogIcon.tsx" },
        "span": [157, 196],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction FrogIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 982 992\">\n      <path\n        transform=\"rotate(180, 491, 480)\"\n        fill={theme.palette.text.primary}\n        d=\"M979.008 149.504c-3.328 0.576-11.424 0.64-20.288 1.312-5.664 11.36 37.728 12.928 17.472 19.68-12.672 4.256-33.984-1.76-48.896-7.136 0 0.064-0.064 0.128-0.064 0.128-4.224 14.752 51.040 21.888 38.432 28.128-12.608 6.304-37.792 2.112-75.552-8.384s-86.048-62.944-109.152-75.552c-23.104-12.576-44.064-4.192-44.064-4.192s12.608 77.632 14.688 115.424c2.080 37.76-8.416 54.56-29.408 81.888-20.96 27.264-71.328 44.064-71.328 44.064s10.528 28.576 27.328 120.896c16.768 92.352-79.808 259.008-79.808 259.008s14.016 8.256 33.568 25.184c14.176 12.288 18.24 65.632 18.24 65.632s0.672 20.416 0.672 41.408c0 20.992-20.928 25.76-27.264 42.56-6.272 16.8 23.040 58.208 14.656 60.32-8.416 2.080-27.264-21.152-39.872-35.68-11.136-12.768-10.496-25.184-8.416-39.872s20.992-44.064 20.992-44.064-16.736-13.44-25.184-18.88c-7.072-4.576-18.912-16.8-18.912-16.8s-18.88 16.8-37.792 73.472c-0.256 0.736-0.544 1.504-0.8 2.272-0.384-0.576-0.672-1.152-1.152-1.728-16.736-19.552-43.264 31.936-21.088 43.296-14.176 16.192-34.88 26.624-67.2 25.408-25.6-0.96-44.672-15.040-57.536-30.624 0.992 0.704 1.6 1.088 1.6 1.088 22.4-11.2-4.192-62.976-20.96-43.36-0.512 0.576-0.8 1.184-1.216 1.792-4.576-17.792-43.616-84.192-43.616-84.192-11.136-18.368-37.76 19.392-54.592 29.344-10.848 6.4 0 44.064 2.080 50.368s0 46.176 0 46.176-3.424 13.856-16 23.648c-10.496 8.128 0-20.288 0-30.784s-11.2-26.592-23.84-51.616c-7.424-14.656-2.752-47.744-2.752-47.744s16.768-46.848 25.184-69.952 38.432-33.44 38.432-33.44-55.872-122.016-52.448-229.632c2.208-69.344 44.032-133.472 44.032-133.472s-31.488-6.304-71.36-56.672-14.688-100.736-10.496-128c4.224-27.328 46.176-94.496 46.176-94.496s-42.528-10.88-60.864-6.24c-30.016 7.552-48.224 20.128-48.224 20.128l-56.704 9.248c0 0-37.792-2.112-56.672-16.8-16.128-12.576 21.792-6.304 33.248-4.256-8.64-1.696-32.608-6.816-47.936-14.624-13.088-6.688 6.304-12.64 20.992-18.88 0.48-0.256 1.088-0.512 1.664-0.736-7.488-0.192-16.704-1.12-19.104-4.32-4.192-5.632 18.176-5.632 43.36-18.176 24.832-12.448 46.944-19.36 60.96-20.928 21.088-7.808 65.12-16.672 80.992-16.672 18.912 0 54.592-10.496 86.048-2.112 31.488 8.384 60.864 27.328 60.864 27.328s8.416 6.24 29.376 31.424c20.992 25.184 7.072 83.872 0.736 90.112-6.272 6.304-9.12 40.064-2.848 44.256 6.304 4.192 73.472 27.616 82.624 14.56 9.792-14.016 32.8 0.128 32.8 0.128s25.184-10.496 37.792-12.64c12.608-2.048 73.472-23.072 73.472-23.072s-8.384-90.24 14.688-121.76c23.104-31.488 90.272-31.488 111.264-27.264 20.992 4.192 62.976 14.688 94.464 27.264 31.456 12.64 88.16 60.864 102.848 73.504 14.688 12.576 27.296 18.88 44.064 23.072 16.832 4.096 25.984 29.856 17.6 31.232z\"\n      />\n    </svg>\n  );\n}\n\nexport default FrogIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/FlyIcon.tsx" },
        "span": [156, 196],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction FlyIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1027 872\">\n      <path\n        transform=\"rotate(180, 513, 442)\"\n        fill={theme.palette.text.primary}\n        d=\"M897.344 340.672c-7.744 7.104-14.72 13.472-20.416 18.976-22.912 22.24-85.536 71.936-143.84 117.152 3.616 0 17.888 0.16 24.96 1.344 8.128 1.344 31.232 25.824 35.296 35.328 4.096 9.504 21.76 13.568 27.168 17.632 5.44 4.064 4.096 14.944-10.848 8.16s-55.68-38.016-62.464-42.080c-4.96-2.976-25.888-1.312-37.824-2.016-30.048 23.168-56.8 43.52-74.176 56.672 0.352 4.768 0.672 9.888 0.672 11.872 0 4.064 4.096 43.456 4.096 43.456s12.224 16.288 23.072 19.008c10.88 2.72 13.6 17.664 20.384 36.672s2.72 33.952 8.16 43.424c5.44 9.504 0 32.608 0 32.608s10.848 6.048 17.664 20.352c25.792 54.304 73.312 96.416 84.16 107.264 10.88 10.848 2.72 16.288-8.128 12.224-10.88-4.064-95.072-100.48-97.792-107.264-2.688-6.784-13.568-17.632-16.288-32.576s-19.008-66.528-20.384-71.968c-1.344-5.408-25.92-13.568-25.92-13.568s0 5.472-0.448 13.44c2.112 2.816 4.608 7.68 7.488 15.744 12.224 33.952-28.544 63.136-35.328 70.592-3.392 3.776-11.648 6.304-18.976 7.936 6.912 4.64 17.344 12.16 24.256 19.936 10.88 12.224 14.944 20.352 20.384 29.856s-9.504 14.944-9.504 14.944-25.824-25.792-25.824-39.36c0-9.984-13.92-17.728-21.28-21.152-4.192 2.592-10.304 5.984-16.704 7.584-10.88 2.72-35.168-2.208-35.168-2.208-1.248-0.32-1.952-0.736-3.008-1.12-1.024 0.352-1.76 0.8-3.008 1.12 0 0-21.888 4.928-32.736 2.208-6.432-1.6-12.544-4.992-16.736-7.584-7.328 3.424-21.248 11.168-21.248 21.152 0 13.568-25.824 39.36-25.824 39.36s-14.944-5.408-9.504-14.944c5.44-9.504 9.504-17.632 20.384-29.856 7.008-7.872 17.632-15.52 24.512-20.096-7.136-1.632-14.912-4.128-18.176-7.744-6.784-7.456-47.52-36.672-35.328-70.592 2.56-7.072 4.736-11.648 6.656-14.56-0.352-7.84-0.32-13.28-0.32-13.28s-24.864 6.784-26.24 12.224c-1.344 5.44-17.632 57.024-20.352 71.968s-13.6 25.792-16.32 32.576c-2.72 6.784-86.88 103.2-97.76 107.264s-19.008-1.344-8.16-12.224c10.88-10.848 58.4-52.96 84.192-107.264 6.784-14.304 17.664-20.352 17.664-20.352s-5.44-23.072 0-32.608c5.44-9.504 1.344-24.448 8.16-43.424 6.784-19.008 9.504-33.952 20.352-36.672 10.88-2.688 23.104-19.008 23.104-19.008s4.064-39.36 4.064-43.456c0-1.984 0.352-7.072 0.672-11.872-17.376-13.184-44.128-33.504-74.176-56.672-11.936 0.704-32.8-0.96-37.792 2.016-6.816 4.064-47.52 35.296-62.464 42.080s-16.288-4.064-10.88-8.16c5.44-4.064 23.104-8.128 27.168-17.632 4.096-9.504 27.168-33.952 35.328-35.328 7.104-1.184 21.312-1.344 24.928-1.344-58.272-45.216-120.896-94.88-143.84-117.152-5.696-5.504-12.672-11.872-20.384-18.976-57.664-52.768-154.176-141.152-119.264-227.744 13.248-32.864 33.376-54.304 59.872-63.68 10.144-3.552 21.216-5.408 33.184-5.408 31.552 0 69.568 12.576 115.136 37.856 39.84 22.112 92.64 66.048 135.424 111.424-5.088-11.328-10.272-23.616-13.088-32.672-6.784-21.728-20.384-66.528-25.824-73.312-5.44-6.816-33.952-61.12-38.016-66.528-4.096-5.44 3.36-13.216 8.128-5.44 25.824 42.080 46.176 52.928 50.24 67.872s17.664 57.024 17.664 57.024 16.288 17.664 21.728 29.888c4.544 10.144 8.128 42.624 14.656 64.288 9.472 12.096 17.76 23.84 24.224 34.816 4.384-15.616 14.656-49.728 24.928-65.152 13.6-20.384 39.36-50.208 55.68-52.928 8.32-1.408 32.96-1.408 41.28 0 16.32 2.72 42.080 32.576 55.68 52.928 10.24 15.424 20.544 49.536 24.896 65.152 6.464-10.976 14.784-22.72 24.224-34.816 6.528-21.664 10.144-54.112 14.688-64.288 5.44-12.224 21.728-29.888 21.728-29.888s13.568-42.080 17.664-57.024c4.064-14.944 24.448-25.792 50.208-67.872 4.736-7.776 12.224 0 8.16 5.44-4.064 5.408-32.608 59.712-38.016 66.528-5.44 6.784-19.040 51.584-25.824 73.312-2.848 9.056-8.032 21.344-13.12 32.672 42.816-45.376 95.584-89.312 135.456-111.424 45.536-25.28 83.552-37.856 115.104-37.856 12 0 23.040 1.856 33.216 5.408 26.464 9.376 46.592 30.816 59.84 63.68 34.912 86.528-61.6 174.912-119.232 227.712zM852.512 348.192c5.824-5.696 12.928-12.192 20.832-19.424 44.8-41.024 135.456-108.224 139.808-171.52-10.528 11.712-30.464 33.76-39.296 42.56-12.224 12.224-59.744 48.864-92.32 71.968-28.288 20-234.080 220.64-288.288 273.632 2.752 2.016 5.76 3.52 8.992 4.096 4.288-3.136 205.312-157.728 250.272-201.312zM593.344 318.624c2.176-7.648 4.448-14.848 6.752-21.536-9.696-6.592-33.76-21.6-53.856-22.656-5.568-0.288-10.496-0.288-15.008-0.192-5.44 2.272-12.736 2.912-12.736 2.912s-2.24-0.608-6.496-1.248c-4.224 0.672-6.496 1.248-6.496 1.248s-7.296-0.64-12.736-2.912c-4.512-0.096-9.44-0.096-14.976 0.192-20.128 1.056-44.192 16.064-53.888 22.656 2.304 6.688 4.608 13.888 6.752 21.536 18.080-3.84 67.424-3.616 81.344-3.456 13.92-0.16 63.264-0.384 81.344 3.456zM411.936 671.296c7.296 4.192 34.688 20.384 38.208 27.456 3.168 6.336 28.256 29.76 23.552 49.184 15.168 5.376 27.232 4.896 28.544 4.832 1.6-2.304 5.504-2.784 8.576-1.728 3.072-1.056 6.976-0.576 8.576 1.728 1.408 0.064 15.040 0.608 31.744-5.728-3.744-19.232 20.672-42.080 23.776-48.288 3.36-6.72 28.448-21.728 36.96-26.72 1.376-5.056 5.472-10.592 3.616-16.032-11.008-32.128-193.856-43.936-206.976 0-1.568 5.28 2.176 10.432 3.424 15.296zM141.984 322.4c7.904 7.264 15.008 13.76 20.832 19.424 44.896 43.584 254.656 204.512 258.912 207.616 3.072-0.576 5.92-1.824 8.576-3.648-51.328-50.112-261.568-255.2-290.112-275.424-32.608-23.104-80.128-59.744-92.352-71.968-8.16-8.192-25.92-27.744-36.864-39.904 5.12 62.944 86.464 123.168 131.008 163.904zM16.128 121.024c-3.328 8.224-4.928 16.672-5.44 25.152 11.936 13.952 37.376 43.040 46.624 48.16 12.224 6.784 74.688 58.368 90.976 70.592 16.32 12.224 88.256 85.568 96.416 86.912s20.384-31.232 13.6-46.144c-6.816-14.944-33.984-42.080-43.456-52.96-9.504-10.848-84.192-69.248-97.76-81.472-13.6-12.224-52.96-50.208-59.744-59.712-4.16-5.856-11.904-17.248-17.248-25.248-10.208 10.624-19.168 22.784-23.968 34.72zM396.288 320.64c-18.912-52.992-101.376-175.648-174.688-216.384-15.52-8.64-29.92-15.488-43.328-20.928 6.432 8.384 8.096 9.248 12.128 13.28 5.44 5.408 61.088 69.248 65.184 77.376 4 8.064 54.016 54.208 61.952 71.136-18.528-19.424-57.984-61.216-64.672-65.696-8.16-5.44-58.368-62.464-69.248-76.032-8.128-10.144-29.664-23.072-41.632-34.4-23.136-5.952-42.656-6.176-58.816-0.48-9.76 3.424-25.376 0.832-36.8 11.488 3.2 8.64 9.408 22.208 19.136 30.144 14.944 12.224 52.928 58.368 63.808 63.808s77.408 65.184 92.32 76.032c14.944 10.88 39.36 36.672 43.456 48.896 4.064 12.224 12.224 38.016 6.784 44.768-5.44 6.816-12.224 8.16-2.72 24.448 9.504 16.32 62.464 73.344 67.904 74.688 5.408 1.376 5.408-6.784 8.128-20.384 2.72-13.568-9.504-32.576-14.944-46.144-5.408-13.568-31.232-61.088-39.36-70.592s-33.952-47.52-48.864-62.464-58.368-54.304-66.528-65.152c-8.128-10.88 0-4.096 5.44-2.72 5.44 1.344 6.784 4.064 21.728 17.664 14.944 13.568 35.328 38.016 46.144 48.864 10.88 10.848 46.176 55.648 52.96 65.152s38.016 61.088 43.424 78.752c5.44 17.664 13.6 31.264 10.88 42.080-2.72 10.88-5.44 23.104 2.72 29.888 8.128 6.784 46.144 51.584 61.088 63.808 6.592 5.408 12.32 11.808 16.736 17.344 12.064-19.904 4.512-40.768 3.168-54.016-0.64-6.368-1.184-13.504-1.44-19.744-4.576-32.992-24.832-96.352-42.048-144.48zM557.088 217.44c-8.416-7.584-26.144-5.248-38.496-2.368h-13.152c-12.352-2.88-30.080-5.216-38.528 2.368-9.696 8.704-45.44 56.992-49.76 63.36 2.24 4.544 2.112 2.88 2.24 3.168 0 0 47.52-51.584 92.608-34.016 45.088-17.568 92.64 34.016 92.64 34.016 0.096-0.288-0.032 1.376 2.208-3.168-4.288-6.368-40.064-54.656-49.76-63.36zM936.672 61.728c-17.152-3.104-40.608 0.96-64.256 7.264-11.392 10.784-25.92 25.216-34.336 35.744-10.848 13.6-61.088 70.624-69.248 76.032-6.688 4.48-46.112 46.24-64.672 65.696 7.904-16.896 57.952-63.072 61.952-71.104 4.096-8.16 59.744-71.968 65.184-77.408 4.128-4.16 3.296-4.512 9.472-12.576-12.928 5.344-26.72 12.032-41.568 20.288-73.28 40.672-152.256 157.44-171.168 210.4-17.216 48.192-37.792 116.064-42.336 149.088-0.288 6.24-0.8 13.376-1.472 19.744-1.312 12.992-8.608 33.472 2.688 53.088 4.128-4.96 9.216-10.4 14.912-15.072 14.944-12.224 52.96-57.024 61.088-63.84 8.16-6.784 5.44-19.008 2.72-29.856-2.72-10.88 5.44-24.448 10.88-42.080s36.672-69.248 43.424-78.752 42.080-54.304 52.96-65.184c10.848-10.848 31.232-35.328 46.144-48.864 14.944-13.6 16.288-16.288 21.728-17.664 5.44-1.344 13.6-8.16 5.44 2.72s-51.584 50.24-66.528 65.184-40.736 52.928-48.864 62.432c-8.16 9.504-33.952 57.024-39.36 70.624-5.44 13.568-17.664 32.576-14.944 46.144s2.72 21.728 8.16 20.384c5.408-1.376 58.368-58.4 67.872-74.688 9.504-16.32 2.72-17.664-2.72-24.448s2.72-32.608 6.784-44.8c4.096-12.224 28.544-38.016 43.456-48.864 14.944-10.88 81.472-70.624 92.32-76.032 10.88-5.44 48.864-51.584 63.808-63.808 10.784-8.832 17.248-24.608 20.064-32.768-11.008-10.048-29.6-15.232-39.584-17.024zM983.104 85.408c-5.28 7.904-14.112 21.024-18.72 27.456-6.784 9.504-46.144 47.52-59.744 59.744-13.568 12.224-88.256 70.592-97.76 81.472-9.504 10.848-36.672 38.016-43.424 52.928-6.816 14.944 5.408 47.52 13.568 46.144 8.16-1.344 80.096-74.656 96.416-86.88 16.288-12.224 78.752-63.808 90.976-70.624 9.952-5.504 38.336-38.432 48.768-50.72-0.608-8.096-2.112-16.096-5.28-23.936-4.992-12.224-14.272-24.736-24.8-35.584zM318.016 245.952c-0.064-0.224-0.384-0.608-0.512-0.832 4.064 4.288 7.2 7.52 8.672 8.992 8.128 8.096-1.376 8.096-8.16-8.16zM695.52 255.424c1.472-1.472 4.576-4.704 8.672-8.992-0.096 0.256-0.416 0.64-0.512 0.832-6.784 16.32-16.32 16.32-8.16 8.16z\"\n      />\n    </svg>\n  );\n}\n\nexport default FlyIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/DogIcon.tsx" },
        "span": [156, 196],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction DogIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 988 1027\">\n      <path\n        fill={theme.palette.text.primary}\n        transform=\"rotate(180, 502, 480)\"\n        d=\"M100.63 862.296c0 0-27.568-15.162-38.59-24.808-11.026-9.646-38.59-24.808-44.106-34.454-5.516-9.652 9.652-44.106 9.652-44.106s4.124-35.834 13.776-44.1c9.652-8.272 30.324-11.026 30.324-11.026s52.372-20.672 57.882-23.434c5.516-2.756 42.726-19.292 42.726-19.292l9.646-44.106c0 0-12.402-64.778-11.026-79.934s6.89-71.664 6.89-71.664 6.89-85.45 8.272-99.238c1.38-13.782 27.558-82.69 24.808-103.368-2.756-20.672 0-67.538 2.75-77.184 2.76-9.646-6.886-74.418-9.646-79.934-2.756-5.516-31.698-48.236-31.698-48.236s-26.182 0-30.318-11.026c-4.136-11.026-22.052-16.542-8.266-27.564 13.782-11.026 70.282-16.542 78.554-11.026s28.944 28.944 28.944 28.944l19.292 63.398c0 0 19.298 57.882 23.434 88.206 5.108 37.498 20.672 104.748 20.672 104.748l59.268-26.182c0 0 28.938-74.424 24.802-100.612-4.13-26.188-9.646-66.152-5.51-77.184 4.136-11.026-1.38-53.752-16.536-74.424-15.162-20.666-37.214-35.828-42.726-50.99-5.522-15.168 39.964-34.46 73.044-28.944 33.074 5.516 37.214 17.918 38.584 26.182 1.38 8.272 12.406 64.778 17.918 74.424 5.51 9.646 4.13 53.752 6.89 60.648 2.756 6.886 11.026 93.71 15.162 113.014 4.13 19.298 4.13 77.184 4.13 77.184s84.070 22.048 114.394 37.21c30.312 15.162 66.148 26.188 66.148 26.188s31.964-38.238 52.376-50.996c44.1-27.564 46.86-37.21 55.126-50.996 6.014-10.026 13.788-34.454 12.406-38.59-1.38-4.136-2.76-33.080-13.792-42.726-11.020-9.652-14.738-22.89-11.020-26.188 12.402-11.026 33.080-16.536 50.996-6.89 17.922 9.646 26.188 15.162 24.808 33.080-1.374 17.918-12.056 55.058-9.646 68.914 5.516 31.704-4.13 52.372-4.13 52.372s53.752-44.106 75.798-50.996 48.236-45.48 49.616-64.778c1.38-19.292-9.646-39.964-9.646-39.964s-16.536-20.666-11.020-28.944c5.51-8.266 38.584-27.558 63.392-15.162 24.814 12.406 15.162 33.084 15.162 33.084s-4.13 52.372-6.886 62.018c-2.76 9.652-22.052 53.752-20.672 66.152 1.374 12.406-5.516 31.704-13.788 37.214s-41.35 70.288-41.35 70.288-8.266 13.782-11.020 41.35c-2.756 27.564-1.38 46.856-15.162 84.070-13.788 37.21-53.752 62.022-55.132 78.56-1.38 16.542-12.396 50.99-5.516 60.636 6.896 9.646 26.188 100.612 16.542 150.228-18.884 97.116-53.752 132.306-71.664 148.848-21.080 19.45-53.758 35.84-64.778 27.568-11.026-8.266 2.438-24.004 26.182-56.506 26.188-35.834 52.376-79.934 45.48-154.358-6.886-74.424-28.938-97.858-38.59-103.368-9.646-5.51-107.498-2.76-121.284-2.76-13.782 0-79.94 1.38-90.966 11.026-11.020 9.652-28.938 22.052-48.236 28.944-19.292 6.89-41.344 17.918-41.344 17.918s-1.38 15.156-12.406 23.428c-11.020 8.272-17.912 23.434-17.912 23.434s26.182 22.052 22.052 56.506c-4.142 34.46-27.568 79.934-48.236 95.096-20.672 15.168-53.752 46.866-64.778 52.376-11.026 5.516-23.434 6.89-23.434 6.89s-9.646 9.652-30.318 11.026c-20.672 1.38-67.534 2.76-67.534 2.76s-34.454-1.38-42.726-5.516c-8.272-4.13-33.080-34.46-38.59-39.97-5.51-5.516-19.298-22.052-20.672-27.568-1.37-5.518 2.772-24.82 2.772-24.82z\"\n      />\n    </svg>\n  );\n}\n\nexport default DogIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/GuineaPigIcon.tsx" },
        "span": [162, 202],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction GuineaPigIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1028 591\">\n      <path\n        transform=\"rotate(180, 513, 357)\"\n        fill={theme.palette.text.primary}\n        d=\"M1023.328 432.384c-7.008 80.736-28.064 182.592-108.832 231.744-80.736 49.152-115.84 66.688-252.768 21.056 0 0-66.72-8.192-94.816-8.192s-133.408 15.232-164.992 15.232c-31.616 0-112.352-19.904-165.024-48s-102.976-67.904-117.024-74.912c-14.016-7.040-73.728 7.008-87.776-24.576-8.672-19.52 36.256-56.16 36.256-56.16s-80.736-101.824-66.688-189.632c14.048-87.744 80.736-84.256 98.304-94.752 17.536-10.56 169.184-15.008 179.072-14.048 37.44 3.488 80.736 21.056 115.872 21.056s77.248 0 87.776 0 9.696-17.824-12.864-24.576c-23.392-7.072-53.824-24.576-43.296-35.136s32.768 4.672 32.768 4.672-20.672-24.672-2.336-29.248c9.344-2.368 36.288 17.568 36.288 17.568s-12.864-25.76 8.192-18.752 44.48 32.736 44.48 32.736 45.664 31.616 77.248 52.672 87.776 42.112 112.352 38.624c24.608-3.488 108.832 24.576 126.4 35.136 17.568 10.496 52.672 21.056 52.672 21.056s-24.512-41.376-12.832-39.808c17.536 2.304 30.4 8.192 30.4 8.192s-2.304-19.872 11.712-19.872 26.912 19.872 26.912 19.872l7.040 56.192c-0.096 0.032 52.544 21.088 45.504 101.856zM169.024 387.936c-23.392 9.312-9.344 45.632-9.344 45.632 29.248 25.728 51.488-14.048 51.488-31.616s-18.752-23.392-42.144-14.016z\"\n      />\n    </svg>\n  );\n}\n\nexport default GuineaPigIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/HumanIcon.tsx" },
        "span": [158, 198],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction HumanIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 563 1032\">\n      <path\n        transform=\"rotate(180, 395, 484)\"\n        fill={theme.palette.text.primary}\n        d=\"M774.752 449.376c-1.76 3.104-3.616 6.464-4.896 8.832 2.016 0.256 4.448 1.088 5.376 2.88 0.672 1.152 0.576 2.496-0.192 3.68-0.864 1.312-5.536 7.84-8.736 13.472-2.432 4.288-3.648 8.096-4.672 9.824-2.72 4.544-11.040 11.008-17.056 13.28-7.296 2.784-14.496 9.312-15.392 10.144-1.248 1.472-14.144 17.088-17.056 22.848-2.912 5.824-16.448 34.752-24.48 56.48-7.232 19.488-25.088 32.8-28.992 36.064-0.32 5.184 0 28.128-4.32 42.368-2.272 7.648-6.656 17.824-10.144 25.952-2.368 5.376-5.984 9.984-6.272 11.456-0.288 1.536 1.248 9.888 2.016 16 0.992 8.32 2.816 16.704 2.624 21.408-0.416 9.024-8.032 29.12-18.944 40.064-8.864 8.864-27.648 13.6-35.712 15.648-1.184 0.288-2.432 0.608-2.592 0.672-1.44 0.704-21.952 11.424-25.984 14.016-3.584 2.336-15.776 8.192-19.36 10.304l-1.984 19.168c1.376 1.344 5.984 4.48 7.52 7.648 1.472 2.88 0.096 10.080 0.16 14.048 0.992-0.224 3.808-1.6 4.608-1.056 1.152 0.768 2.72 2.656 5.152 5.6 0.48 0.576 0.896 1.12 1.312 1.6 1.792 2.144 0.416 5.6 0.16 9.6-0.128 1.888-0.256 4 0 4.928 0.768 3.136 2.688 11.168 0 14.976-1.216 1.632-3.040 2.592-5.28 2.624 0.384 3.616 0.928 9.216 0.928 10.656l0.032 1.472c0.032 7.040 0.064 15.040-9.504 31.84-9.76 17.184-34.624 18.624-35.616 18.656h-0.288c-1.056-0.032-25.92-1.504-35.648-18.656-9.568-16.8-9.504-24.8-9.44-31.84v-1.472c0-1.44 0.512-7.040 0.864-10.656-2.176-0.032-4.032-0.992-5.184-2.624-2.72-3.808-1.088-11.552-0.32-14.688 0.256-0.928 0.096-3.072 0-4.96-0.256-3.968-1.376-7.712 0.384-9.856 0.448-0.48 0.864-1.024 1.344-1.6 2.432-2.976 3.968-4.832 5.152-5.6 0.8-0.544 3.328 0.672 4.352 0.928 0.096-3.936-1.28-10.752 0.16-13.632 1.568-3.2 5.888-6.432 7.264-7.808l-1.856-19.168c-3.648-2.048-15.36-7.744-19.328-10.464-3.936-2.688-23.872-13.088-25.536-13.952-0.288-0.096-1.536-0.416-2.72-0.704-8-2.048-26.816-6.784-35.68-15.648-10.976-10.944-18.56-31.040-18.976-40.064-0.224-4.704 0.832-13.312 1.856-21.6 0.736-6.144 2.624-13.856 2.336-15.392-0.32-1.44-3.424-6.464-5.792-11.84-3.488-8.128-7.872-18.304-10.176-25.952-4.32-14.208-4.192-36.576-4.48-41.76-3.968-3.264-21.6-17.184-28.832-36.672-8.032-21.728-21.568-50.656-24.512-56.48-2.88-5.76-15.84-21.376-17.024-22.848-0.896-0.832-8.064-7.328-15.392-10.144-6.048-2.304-14.336-8.736-17.056-13.28-1.024-1.728-3.328-5.728-5.76-10.016-3.2-5.632-6.816-12-7.68-13.312-0.768-1.184-0.864-2.528-0.224-3.68 0.96-1.824 3.328-2.624 5.376-2.88-1.248-2.368-3.136-5.728-4.864-8.832-10.016-17.472-13.216-23.776-12.672-26.464s2.656-4.512 5.888-5.184c-1.248-3.168-1.248-6.496 0.576-9.056 0.704-1.024 2.144-2.208 4.704-2.208 1.6 0 3.392 1.184 4.512 1.6 1.152-0.672 2.016-1.344 4.096-1.344 1.664 0 3.232 0.48 4.64 1.472 3.36 2.336 8.32 7.008 9.92 8.992 2.24 0.096 6.304-0.064 9.376 1.312 4.32 1.92 21.248 19.872 22.368 21.28 1.568 1.952 14.784 20.736 17.28 25.312 2.304 4.224 6.304 19.168 7.264 22.624 2.176 2.528 9.184 10.688 10.368 14.24 0.512 1.248 4.928 7.392 28.672 34.816l1.824 2.112c0.992 1.152 24.448 28.544 32.512 46.176 2.24 4.896 2.496 13.6 3.808 18.656 0.512 1.952 1.056 4.128 1.248 4.576 1.376 2.784 14.016 23.136 15.744 25.568 1.472 2.080 7.68 14.432 11.52 22.112 1.088-4.672 2.56-10.816 3.712-14.656 1.984-6.784 5.12-18.464 4.448-22.528-0.256-1.408-0.896-4.704-1.728-8.512-2.016-9.568-6.528-22.496-6.784-27.68-0.384-6.272 2.016-12.64 3.008-14.944-1.312-4.096-6.624-21.28-7.328-25.632-0.224-1.184-0.832-3.584-1.536-6.4-2.176-8.48-5.472-21.312-4.832-28.704 0.48-5.504 0.928-17.952 0.672-29.568-0.256-9.632-0.192-16.032 0-17.728 0.096-0.928-1.44-6.528-1.984-11.648-1.472-13.792-4.256-39.392-4.256-69.024 0-21.28 11.808-85.696 12.8-89.152 0.448-1.728 0.224-14.336-0.512-31.36-0.256-6.304 2.624-15.104 3.2-22.24 0.288-3.808 0.512-7.104 0.512-8.544 0-2.4-3.424-10.688-4.64-17.056-0.864-4.576-1.728-9.248-2.176-12.64-1.568-10.816-0.512-53.792 2.816-68.352 1.824-7.968 10.816-40.992 24.032-103.072l1.152-5.504c1.44-6.784 0.128-13.472-0.96-17.536-0.608-2.176-1.152-4.224-1.152-6.272 0-3.84-1.152-8.256-1.856-12.064-0.192-1.056-0.384-2.112-0.544-3.008-0.352-1.024-3.744-4.8-13.856-17.504-0.832-1.024-1.472-1.824-1.664-2.048-0.32-0.416-1.952-1.536-3.2-2.432-5.76-4.192-9.216-6.912-9.216-9.76 0-3.648 2.272-6.24 6.336-7.296 0.256-0.064 0.416-0.064 0.576-0.064 0.864-1.504 2.848-3.84 5.536-3.84 1.12 0 1.984 0.128 2.656 0.224 1.12-0.768 3.2-2.944 5.12-2.944 2.176 0 4.096 0.736 5.248 1.312 1.056-0.448 2.624-1.024 3.872-1.28 1.984-0.288 3.488 0.48 4.576 1.536 1.728-0.928 4.192-2.048 6.656-2.048 0.576 0 1.088 0.064 1.632 0.16l1.824 0.416c5.92 1.28 8.544 1.984 9.696 2.752l0.224 0.128c5.632 3.68 8.928 6.688 10.112 9.12 1.92 3.84 0.576 6.912 0.512 9.408-0.032 2.016-0.192 3.168 0.736 4.064 0.512 0.48 0.832 1.056 1.28 1.632 2.72 3.296 7.392 7.392 6.848 13.152-1.184 11.904-1.888 19.392-1.856 19.616 0.096 2.016 1.792 12.64-0.448 16.64-3.776 6.848-4.544 12.896-5.28 19.36-0.768 6.688-4.48 60.064-3.328 65.216 0.352 1.664 1.024 4.672 1.92 8.288 2.080 8.8 7.072 21.952 7.776 27.040 3.584 25.728-2.496 50.464-2.72 51.552-0.864 4.064-2.848 8.224-4.256 11.328-1.12 2.496-1.312 5.664-1.312 6.88 0 2.752 1.632 13.536 2.304 17.696 0.512 1.536 2.816 9.088 1.984 13.696-0.48 2.56 0.928 6.56 2.496 10.784 0.608 1.632 1.248 3.36 1.76 5.152 2.048 6.432 2.816 31.52 2.912 34.208 0.928 11.168 0.928 30.304 1.472 32.512 0.352 1.408 2.080 11.648 4.256 25.376 2.048 13.28 5.952 27.328 6.528 29.856 1.28 5.184 5.28 47.744 5.6 52.416 0.32 4.384 0.416 13.856 0.416 17.984l2.016 0.384 1.952-0.384c0.032-4.128 0.096-13.632 0.416-17.984 0.352-4.672 4.352-47.232 5.664-52.416 0.608-2.528 4.96-20 7.040-33.248 2.144-13.76 3.552-21.504 3.936-22.976 1.984-7.776 2.624-25.952 3.104-31.616 0.096-2.88-0.992-27.648 1.024-34.080 0.544-1.792 1.184-3.52 1.792-5.152 1.536-4.224 3.008-8.224 2.528-10.784-0.832-4.608 1.472-12.16 1.984-13.696 0.704-4.16 3.936-14.944 3.936-17.696 0-1.216-1.536-4.16-2.656-6.592-1.408-3.168-3.616-8.096-4.512-12.16-0.256-1.088-6.368-25.312-2.752-51.040 0.704-5.088 4.832-17.056 6.912-25.888 0.832-3.648 1.6-6.656 1.952-8.288 1.056-5.12-1.728-59.68-2.496-66.368-0.736-6.464-1.472-12.544-5.248-19.36-2.208-4-0.544-14.592-0.48-16.64 0.032-0.224-0.672-7.712-1.824-19.616-0.608-5.76 4.096-9.888 6.784-13.152 0.48-0.576 0.8-1.152 1.28-1.632 0.992-0.896 0.8-2.016 0.736-4.064-0.032-2.496-1.376-5.568 0.544-9.408 1.216-2.432 4.544-5.44 10.144-9.12l0.192-0.128c1.184-0.768 3.808-1.472 9.664-2.752l1.824-0.416c0.48-0.096 1.024-0.16 1.568-0.16 2.464 0 4.96 1.12 6.624 2.048 1.088-1.056 2.592-1.824 4.608-1.536 1.28 0.256 2.816 0.832 3.84 1.28 1.216-0.576 3.104-1.312 5.248-1.312 1.952 0 4.032 2.144 5.184 2.944 0.672-0.096 1.504-0.224 2.624-0.224 2.688 0 4.672 2.336 5.568 3.84 0.128 0 0.288 0 0.544 0.064 4.064 1.024 6.368 3.616 6.368 7.296 0 2.848-3.52 5.568-9.248 9.76-1.28 0.896-2.848 2.016-3.2 2.432-0.16 0.256-0.768 1.024-1.664 2.048-10.080 12.672-13.504 16.48-13.888 17.504-0.128 0.864-0.352 1.952-0.512 3.008-0.704 3.808-1.856 8.224-1.856 12.064 0 2.048-0.544 4.096-1.152 6.272-1.088 4.064-2.4 10.752-0.96 17.536l1.184 5.504-0.096-0.032c13.088 61.376 22.304 95.168 24.128 103.104 3.328 14.56 4.352 57.536 2.816 68.352-0.544 3.36-1.376 8.064-2.208 12.64-1.184 6.368-4.384 13.888-4.384 16.256 0 1.44 0.256 4.704 0.576 8.544 0.544 7.2 3.168 16.736 2.88 23.072-0.8 19.648-0.832 29.984-0.48 31.36 0.928 3.456 12.736 67.872 12.736 89.152 0 29.632-2.752 55.264-4.224 69.024-0.608 5.12-2.336 8.832-2.24 9.792 0.16 1.696 0.256 9.376 0 19.040-0.288 11.616 0.48 24.608 0.928 30.080 0.608 7.392-2.72 20.224-4.832 28.704-0.736 2.816-1.376 5.248-1.568 6.4-0.704 4.384-6.048 21.536-7.328 25.632 0.96 2.304 3.36 8.672 3.040 14.944-0.32 5.184-4.544 17.696-6.56 27.264-0.768 3.808-1.472 7.104-1.728 8.512-0.672 4.064 2.208 16.16 4.256 22.944 1.088 3.84 2.56 9.984 3.648 14.656 3.84-7.712 10.048-20.032 11.552-22.112 1.728-2.432 14.464-22.656 15.808-25.408 0.224-0.48 0.768-2.656 1.28-4.608 1.28-5.056 1.408-13.888 3.68-18.784 8.096-17.632 31.456-45.024 32.48-46.176l1.856-2.080c23.744-27.456 28.16-33.6 28.672-34.816 1.184-3.584 8.192-11.776 10.432-14.304 0.864-3.456 4.864-18.4 7.168-22.624 2.496-4.576 15.712-23.36 17.312-25.312 1.088-1.408 19.104-19.36 23.392-21.28 3.104-1.376 7.936-1.504 10.176-1.6 1.6-1.984 5.408-6.624 8.704-8.96 1.408-1.024 3.264-1.984 4.928-1.984 1.952 0 2.816 0.512 3.968 1.184 1.504-0.864 4.32-2.912 6.528-2.912 1.696 0 3.104 0.672 3.968 1.952 1.952 2.688-1.696 8.832-3.36 12.64 3.168 0.672 7.232 1.504 7.744 4.16 0.608 2.656-2.56 8.992-12.448 26.432z\"\n      />\n    </svg>\n  );\n}\n\nexport default HumanIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/MacaqueIcon.tsx" },
        "span": [160, 201],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction MacaqueIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1000 1036\">\n      <path\n        transform=\"rotate(180, 500, 484)\"\n        fill={theme.palette.text.primary}\n        d=\"M994.056 873.956c0 0-13.098 39.308-21.832 41.486-8.736 2.19-43.676 26.212-56.772 30.572-13.102 4.362-28.394 17.47-54.594 13.102-26.206-4.368-58.956-8.74-69.876-21.838-10.924-13.098-45.86-48.038-45.86-48.038s-10.918-50.226-17.464-58.962c-6.552-8.736-34.94-39.302-45.86-45.854-10.918-6.552-100.448-26.206-176.88-96.086-76.426-69.876-131.022-174.692-146.302-231.47-15.286-56.772-39.308-179.058-39.308-179.058s-15.286-133.204-4.368-161.588 6.552-54.594-4.368-76.432c-10.918-21.832-93.896-48.044-128.838-19.654-34.94 28.39-72.060 72.060-34.94 235.842 37.124 163.778 26.206 207.448-4.368 244.572-30.572 37.118-100.448 43.67-115.734 37.118-15.286-6.546-21.148-27.914 41.486-39.302 48.044-8.73 57.298-47.472 56.778-85.162-2.184-157.226-45.854-205.27-39.308-301.35 6.552-96.086 67.698-146.308 126.654-157.226s133.204 17.466 144.118 17.466c10.918 0 45.86-8.74 45.86-8.74s17.47-6.546 37.124-6.546 32.756-8.736 39.302-8.736c6.552 0-2.184-19.66 30.572-13.102s85.168 8.74 85.168 8.74 30.568 6.546 52.406 4.362c21.838-2.19 52.41 0 52.41 0s43.676 0 58.962-2.19c15.286-2.178 39.302-13.098 37.124 4.368s-15.286 43.676-15.286 43.676 15.286 17.47 8.736 39.302c-6.546 21.838-39.302 52.41-39.302 52.41l-8.736 21.832c0 0 10.918 21.844 4.362 50.232-6.546 28.39-4.362 82.978-4.362 82.978l15.286 37.124c0 0 19.654-17.47 24.016-17.47 4.368 0 10.924-26.2 13.102-32.752s-15.286-6.552-10.918-21.832c4.362-15.292 8.736-28.394 8.736-28.394s-15.286 21.838-26.206 19.654c-10.924-2.184-17.47-17.47-8.736-28.39s28.39-30.572 41.486-26.206c13.102 4.362 41.492 37.124 45.86 45.86 4.362 8.73-6.552 43.67-2.19 61.14 4.368 17.47 17.47 39.302 2.19 65.514-15.286 26.2-34.94 24.022-45.86 48.038 0 0-17.47 26.206 2.19 45.854 19.654 19.654 45.854 80.8 56.772 100.448 10.918 19.66 21.832 41.492 24.022 61.152 2.184 19.648 0 52.406 0 52.406l6.546 15.286 30.572 10.918c0 0 21.832 2.19 28.39 10.918 6.552 8.74 13.102 19.66 13.102 19.66s19.654 10.918 24.016 26.2c4.368 15.292 0 26.212 0 26.212s-6.546 26.206-4.362 37.124c2.184 10.918 8.736 43.67 8.736 43.67s19.654 4.362 19.654 19.66c-0.006 15.276-13.108 41.482-13.108 41.482zM932.914 784.426c-10.924 0-26.206 15.28-26.206 15.28s4.362 19.66 17.47 15.292c13.098-4.368 10.918-13.102 10.918-13.102s8.738-17.47-2.182-17.47z\"\n      />\n    </svg>\n  );\n}\n\nexport default MacaqueIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/MouseIcon.tsx" },
        "span": [158, 198],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction MouseIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1025 439\">\n      <path\n        transform=\"rotate(180, 511, 326)\"\n        fill={theme.palette.text.primary}\n        d=\"M1001.6 345.6c-25.6 9.6-80 9.6-112 6.4-25.6-3.2-83.2-12.8-108.8-12.8-28.8 0-67.2 3.2-92.8 22.4-12.8 9.6-28.8 25.6-38.4 38.4 0 12.8-3.2 22.4-3.2 25.6 0 12.8-28.8 99.2-54.4 128s-73.6 57.6-96 64c-25.6 6.4-105.6 12.8-121.6 6.4s-51.2-25.6-60.8-38.4c-9.6-12.8-32-22.4-32-22.4s9.6 25.6-12.8 54.4c-22.4 25.6-38.4 32-57.6 19.2-16-12.8-35.2-60.8-35.2-60.8h-38.4c0 0-12.8 12.8-25.6 28.8-9.6 16-16 48-22.4 44.8s-19.2-48-16-57.6c6.4-9.6 25.6-48 25.6-48s-16-28.8-19.2-35.2c-3.2-6.4-6.4-19.2-9.6-25.6 0 0-3.2 0-3.2 0-16 0-25.6-12.8-25.6-25.6 0-6.4 3.2-16 9.6-19.2-9.6-12.8-51.2-60.8-51.2-60.8s-6.4-19.2 3.2-19.2c9.6 0 35.2-6.4 35.2-6.4s67.2 0 76.8 0c12.8 0 48 0 57.6 0 9.6-3.2 44.8-22.4 51.2-28.8s32-44.8 32-44.8-19.2-22.4-28.8-28.8c-9.6-6.4-16-9.6-25.6-6.4s-22.4-3.2-25.6-9.6c-3.2-6.4-16-16-6.4-16s32 6.4 32 6.4 0-9.6 9.6-9.6c9.6 0 38.4 6.4 38.4 6.4s9.6 0 28.8 9.6c19.2 9.6 44.8 19.2 44.8 19.2s22.4 0 38.4 9.6c16 9.6 28.8 3.2 28.8 3.2s22.4-3.2 35.2 6.4c16 9.6 28.8 28.8 32 32 3.2 0 28.8 0 41.6-6.4s35.2-12.8 35.2-12.8 0-19.2-9.6-22.4c-9.6-3.2-16 0-25.6-3.2s-25.6-6.4-28.8-16c-3.2-9.6-3.2-19.2 0-16 3.2 0 12.8 9.6 12.8 9.6s-6.4-16 3.2-12.8c6.4 3.2 16 9.6 16 9.6h16c0 0-6.4-9.6 3.2-9.6s19.2 6.4 19.2 6.4 25.6 6.4 32 16c6.4 9.6 6.4 19.2 6.4 19.2s-16 16-6.4 16c9.6 3.2 32 3.2 48 9.6 16 9.6 32 25.6 32 35.2 16-6.4 32-16 44.8-19.2 25.6-6.4 86.4 0 108.8 6.4 25.6 6.4 76.8 16 86.4 16s80 6.4 102.4-3.2 22.4 0 22.4 0 9.6 12.8-16 22.4zM147.2 403.2c-19.2 0-35.2 16-35.2 35.2s16 35.2 35.2 35.2 35.2-16 35.2-35.2c0-19.2-16-35.2-35.2-35.2z\"\n      />\n    </svg>\n  );\n}\n\nexport default MouseIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/RabbitIcon.tsx" },
        "span": [159, 198],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction RabbitIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 963 754\">\n      <path\n        transform=\"rotate(180, 498, 434)\"\n        fill={theme.palette.text.primary}\n        d=\"M982.434 199.109c0 0 14.45 32.501 11.74 41.532s-12.644 0-12.644 0 1.806 16.245-5.419 27.985-18.051-0.903-18.051-0.903 1.806 20.76-9.934 26.179c-11.74 5.419-22.566 0.903-22.566 0.903s-16.245 86.664-23.47 110.134c-7.225 23.47-70.42 146.247-70.42 146.247s-68.614 74.935-116.456 76.742-68.41 13.784-85.761 14.45c-71.323 2.709-115.553-21.663-115.553-21.663s-31.597 1.806-50.551 5.419c-18.954 3.612-55.067-4.516-59.583-9.934s-32.501-9.031-32.501-6.322-4.516 10.837-20.76 11.74c-6.051 0.339 1.806 28.888 1.806 28.888s1.806 11.74 12.644 18.954c10.837 7.225 34.307 38.822 46.047 58.679s9.934 54.164 9.934 54.164 8.128 64.098-0.903 70.42c-9.031 6.322-16.245 18.051-34.307 12.644-18.051-5.419-57.776-15.353-64.098-26.179-6.322-10.837-30.694-26.179-37.016-64.098s-15.353-37.919-18.051-44.241c-2.709-6.322-3.612-15.353-8.128-28.888s-9.934-15.353-21.663-17.148c0 0-22.566-9.031-34.307-10.837s-62.292-23.47-71.323-29.791c-9.031-6.322-9.031-18.051-21.663-27.082-12.644-9.031-41.532-45.144-47.842-52.358s-27.082-28.888-27.082-53.261c0-24.373 12.644-18.051 12.644-18.051s-0.903-10.837 3.612-20.76c4.516-9.934 13.547-16.245 27.985-19.857s39.725-2.709 39.725-2.709 20.76-4.516 49.648-8.128 50.551-5.419 50.551-5.419-9.934-15.353-1.806-24.373c8.128-9.031 34.307-26.179 36.113-28.888s37.919-47.842 56.873-55.067c18.954-7.225 62.292-37.919 62.292-37.919s52.358-20.76 57.776-28.888c5.419-8.128 7.225-23.47 7.225-23.47s-23.47-1.806-32.501-11.74-11.74-23.47-11.74-23.47-5.419-14.45-3.612-18.051c1.806-3.612 15.353-3.612 15.353-3.612s-17.148-24.373-14.45-32.501c2.709-8.128 27.985-6.322 31.597-6.322s39.725-11.74 53.261-11.74c13.547 0 50.551 1.806 59.583 0s92.083-15.353 101.114-12.644c9.031 2.709 46.95-2.709 46.95-2.709s82.149 4.516 104.727 6.322c22.566 1.806 69.517 10.837 69.517 10.837s71.323-4.516 91.18 4.516c19.857 9.031 36.113 32.501 44.241 52.358 8.072 19.846-9.979 9.912-9.979 9.912zM206.044 590.008c-0.903-10.837-16.245-26.179-25.276-29.791s-24.373 1.806-24.373 1.806-9.031-2.709-17.148-2.709c-8.128 0-0.903 7.225-0.903 7.225s-0.903 10.837 0 17.148 15.353 20.76 15.353 20.76c8.128 4.516 22.566 7.225 33.404 5.419s19.835-9.020 18.943-19.857z\"\n      />\n    </svg>\n  );\n}\n\nexport default RabbitIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/PigIcon.tsx" },
        "span": [156, 196],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction PigIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1024 663\">\n      <path\n        transform=\"rotate(180, 512, 382)\"\n        fill={theme.palette.text.primary}\n        d=\"M1020.256 413.504c2.048 10.208 5.12 22.432 3.072 35.648-1.984 13.248-6.112 56-8.128 61.088-2.048 5.088-7.136 22.4-3.072 34.624 4.064 12.192 13.248 35.616 0.992 43.776-12.192 8.128-31.552-3.040-31.552-3.040s-52.928 46.816-61.056 54.944-68.192 36.672-68.192 36.672-95.68 53.952-151.616 61.056c-56 7.136-170.016 26.464-193.408 22.4s-23.392 2.016-23.392 2.016l-22.4-7.136-6.080 5.088-16.288-4.064h-12.224l-18.368-12.256h-13.248l-26.464-12.224-26.432-2.016-14.24-8.128-16.32-7.136c0 0-11.2-3.072-12.192-6.112-1.024-3.072-18.336-10.176-18.336-10.176l-15.264-13.248c0 0-31.552-15.264-34.624-22.368-3.040-7.136-57.984-60.064-62.048-66.176-4.096-6.112-32.608-19.328-35.616-33.568 0 0-59.072 2.016-73.312 10.176-14.24 8.128-20.352 5.088-30.528 12.224-10.176 7.104-19.328 20.352-25.44 18.304s-5.088-21.376-2.016-30.528c3.040-9.184 31.552-30.528 47.84-42.752s39.68-30.528 44.768-43.776 17.312-35.648 17.312-35.648-5.088-54.912-6.112-66.176c-0.992-11.2-4.064-33.568-8.128-43.744-4.096-10.176-16.32-14.24-19.328-25.44-3.072-11.2 7.136-35.616 13.216-42.752 6.112-7.136 14.24-9.184 14.24-9.184s9.152-8.128 19.328-13.184c10.176-5.12 30.528 0 35.616 0s21.376-6.112 21.376-6.112 21.376-7.136 38.688-3.072c17.28 4.064 32.576 11.2 32.576 11.2s-2.016-62.048-17.312-81.44c-15.264-19.328-24.448-32.576-32.576-37.632-8.16-5.056-21.376-14.24-21.376-14.24s9.152-8.128 16.288-7.136-2.016-7.136 6.080-9.184c8.16-1.984 21.408-3.008 31.552 1.056 10.176 4.064 23.392 11.2 28.512 12.192s6.112-9.184 13.248-2.048 0 17.312 0.992 21.376c1.024 4.128 7.136 33.632 11.232 41.76 4.064 8.128 32.576 72.256 34.592 78.368s16.288 33.632 16.288 33.632 65.152 33.568 77.376 36.64c12.192 3.072 30.496 12.192 40.672-5.12 10.176-17.248 14.24-48.8 17.312-62.048s6.080-57.984 4.064-68.192-8.128-34.624-18.304-46.816c-10.176-12.256-16.288-24.448-16.288-24.448l18.304-3.072c0 0-2.016-15.264 7.136-15.264s16.288 0 28.512 7.136 18.304 19.328 18.304 19.328 5.088-5.056 11.232-0.992c6.080 4.064 2.016 21.376 2.016 24.448s0 60.064 8.128 68.192c8.16 8.128 24.416 81.44 28.48 90.56 4.128 9.184 15.328 8.864 15.328 8.864s-1.056-14.24 6.048-16.32c7.136-1.984 6.112 13.248 6.112 13.248l30.112-9.12c0 0-3.552-13.76 6.496-15.328 4.064-0.64 4.128 13.376 4.128 13.376l11.072 0.064 26.56 3.872 6.112-11.2c0 0 4.576-3.36 7.136-0.992s0 14.24 0 14.24l21.376 5.056c0 0 4.8-10.048 7.136-10.176 2.24-0.064 5.056 2.048 5.056 2.048l-0.992 11.2 25.44-4.064c0 0 2.688-6.24 4.064-8.128s5.12 0 5.12 0l3.072 11.2c0 0 4.064 3.328 8.128-5.824 4.064-9.184 24.448-49.888 22.368-61.056s-19.328-34.624-20.384-42.752c-0.992-8.192-15.264-19.36-16.256-22.432-0.992-3.008-20.384-11.2-17.312-18.304s26.432-4.064 37.696-5.056c11.2-0.992 18.304 10.176 21.376 9.12 3.008-0.992 4.064 11.264 12.192 22.432s21.376 48.8 26.432 56.992c5.12 8.128 12.256 18.304 14.24 32.576 2.048 14.24-10.112 45.824-1.984 46.816s41.696-30.56 48.8-34.624c7.2-4.064 40.736-31.552 46.88-41.696 6.048-10.176 1.984-47.872 7.136-60.064 5.056-12.256 6.048-35.616 7.136-38.688 0.992-3.072 12.192-25.44 22.368-26.432 10.176-1.056 12.192 17.248 17.312 25.44 5.056 8.128 4.064 17.248 5.056 33.568s-15.264 28.512-11.2 43.744c4.064 15.328 0.992 36.672 0.992 40.736s-10.176 18.304-3.008 24.448c7.072 6.048 3.008 12.192 0 22.368-3.072 10.176 6.048 31.552 9.12 47.808 3.072 16.32 10.176 81.44 10.176 81.44s6.112-17.312 6.112-27.488c0-10.144-1.056-21.376 6.048-25.44s1.12 8.128 3.136 18.272zM101.728 300.736c-2.368-11.936-7.424-10.368-9.76-12.448 0 0-8.064 20.64 2.016 27.488 4.256 2.912 9.152-7.84 7.744-15.040zM133.6 278.24c-2.016-6.048-12.224 3.072-18.304 10.176-6.112 7.136 7.136 23.424 7.136 23.424 11.168-2.016 13.216-27.456 11.168-33.6zM232.448 420.64c-8.16-3.040-19.328-5.088-24.448-10.144 0 0 3.072 16.256 9.152 19.296 6.112 3.072 15.296 6.112 21.376 5.088 6.144-0.992 2.048-11.168-6.080-14.24zM996.864 546.848l-6.112 19.328 12.192 8.128c3.072-27.456-6.080-27.456-6.080-27.456z\"\n      />\n    </svg>\n  );\n}\n\nexport default PigIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/countHomologues.js" },
        "span": [109, 465],
        "sourceCode": "export default function countHomologues(homologues) {\n  let orthologueCount = 0;\n  let paralogueCount = 0;\n  homologues.forEach(({ homologyType }) => {\n    if (\n      homologyType === \"ortholog_one2one\" ||\n      homologyType === \"ortholog_one2many\" ||\n      homologyType === \"ortholog_many2many\"\n    ) {\n      orthologueCount += 1;\n    }\n\n    if (homologyType === \"within_species_paralog\" || homologyType === \"other_paralog\") {\n      paralogueCount += 1;\n    }\n  });\n  return { orthologueCount, paralogueCount };\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/RatIcon.tsx" },
        "span": [156, 196],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction RatIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1027 623\">\n      <path\n        transform=\"rotate(180, 513, 370)\"\n        fill={theme.palette.text.primary}\n        d=\"M1020.48 628.256c-3.52 6.944-14.176 12.896-28.704 16-4.8 1.024-10.144 2.496-11.904 3.232s-8.896 3.552-15.904 6.304c-7.008 2.784-15.936 6.656-19.872 8.8-47.104 25.376-60.64 29.28-106.528 30.4-42.56 1.024-47.616 2.656-50.272 16.608-3.136 16.288-16.928 29.344-29.472 29.376l0.032-0.32c-1.824 0-3.552-0.512-5.28-0.768-5.6-1.856-13.568-9.76-13.568-13.472 0-1.12-4.672-4.288-10.336-7.104s-11.168-6.688-12.16-8.608c-3.232-6.048-9.984-12.224-13.376-12.224-1.792 0-4.032-0.768-4.992-1.792-0.992-1.024-8.16-2.080-15.872-2.464-7.712-0.512-14.24-1.344-14.56-2.208-0.32-0.768-2.208-1.536-4.32-1.536-2.848 0-3.52-0.608-2.784-2.592 1.248-3.232-3.36-6.944-8.928-7.008-4.608 0-9.088-3.424-13.248-9.888-2.272-3.488-4-4.352-8.96-4.352-3.52 0-6.976-1.024-8.128-2.368-1.12-1.28-2.368-2.016-2.784-1.6-1.28 1.248-9.92-4.352-9.92-6.464 0-2.336-3.68-3.84-9.6-3.84-2.496 0-4.928-0.672-5.472-1.472-1.568-2.56-10.688-6.464-15.104-6.464-2.304 0-4.928-0.704-5.824-1.632-1.088-1.12-3.264-1.056-6.72 0-3.808 1.312-5.664 1.344-7.328 0-1.248-1.024-7.808-2.016-14.656-2.208-11.872-0.512-13.12 0-28.48 7.264-8.832 4.192-17.792 7.648-19.872 7.648s-9.792 1.44-17.056 3.136c-7.264 1.76-16 3.104-19.36 3.104-6.88 0-18.88 2.208-31.584 5.824-4.768 1.344-10.816 2.016-13.728 1.472-2.848-0.544-7.232-0.512-9.728 0.832-6.080 2.432-15.392 2.816-25.856 1.056-5.824-1.024-9.12-0.928-10.272 0.512-2.464 2.464-4.224 2.112-4.224-0.864 0-2.304-2.976-2.496-27.424-1.888-18.112 0.512-28.96 1.376-31.776 2.752-3.744 1.824-4.896 1.728-8.672-0.736-2.368-1.568-6.496-3.392-9.184-4.032-2.688-0.672-8.8-2.752-13.632-4.544-4.768-1.824-10.080-3.328-11.744-3.328-1.696 0-5.984-1.728-9.568-3.744-3.552-2.144-8.928-4.256-11.904-4.928-3.008-0.64-8.672-2.912-12.608-4.96-3.904-2.112-9.152-3.84-11.648-3.84s-4.544-0.672-4.544-1.376c0-0.768-1.504-1.792-3.328-2.304-2.432-0.64-3.072-1.728-2.336-3.936 1.184-3.744-0.608-5.184-12.128-9.728-4.96-1.952-10.272-4.896-11.776-6.624-1.536-1.664-3.488-3.040-4.448-3.040-0.896 0-4.192-2.368-7.296-5.28s-12.416-8.352-20.704-12.096c-16.704-7.552-19.168-9.12-18.656-11.744 0.192-1.024-1.792-2.848-4.416-4.192-7.808-4-19.872-12.768-19.872-14.4 0-0.864-2.688-2.656-5.984-4-6.656-2.784-15.040-11.968-11.872-13.024 3.648-1.216 1.984-3.456-6.816-9.056-4.8-3.040-8.704-6.56-8.704-7.744 0-1.152-3.328-4.48-7.328-7.328-6.016-4.288-7.104-5.856-6.304-8.96 0.704-2.848-0.032-4.384-3.008-6.304-2.112-1.376-3.488-3.52-3.072-4.672 0.48-1.152 0.032-2.592-0.928-3.168-0.96-0.608-1.376-2.368-0.896-3.936 0.512-1.568-0.128-3.712-1.472-4.832s-2.432-2.944-2.432-4.096-2.272-5.504-5.056-9.632c-3.584-5.312-4.512-7.712-3.072-8.192 1.248-0.512-2.24-4.928-8.864-11.328-6.016-5.856-11.936-12.928-13.12-15.744-1.952-4.672-1.888-5.376 0.832-7.36 2.912-2.112 2.944-2.368-0.8-6.304-2.080-2.272-4.032-5.664-4.256-7.648-0.16-2.016-0.384-4.096-0.448-4.64s-3.104-4.32-6.656-8.352c-6.464-7.328-6.464-7.392-2.4-7.392 5.088 0 5.44-3.616 0.672-7.008-6.304-4.448-1.696-4.512 5.824 0 4.032 2.4 7.712 3.936 8.192 3.424 0.512-0.544-2.816-5.408-7.392-10.912-6.88-8.256-7.936-10.272-5.952-11.52 2.080-1.28 2.048-2.112-0.448-6.4-3.136-5.472-5.568-16.8-3.616-16.768 0.672 0 3.648 1.376 6.496 3.136 4.704 2.88 5.312 2.944 6.208 0.576 0.576-1.376 0.192-3.936-0.832-5.504-2.592-4.192-2.304-4.864 1.76-4.32 2.848 0.512 3.424-0.512 2.976-2.688-3.072-16.864-2.304-47.744 1.216-49.952 1.376-0.8 1.728-2.56 0.96-4.864-1.024-3.264-0.672-3.424 3.616-2.432 4.704 0.992 4.704 0.992 4.256-5.824-0.64-8.864 0.416-12.448 3.328-11.328 1.6 0.576 2.4-0.544 2.528-2.944 0.096-2.016 0.384-5.952 0.576-8.576 0.192-2.56-0.192-5.472-0.8-6.336-0.608-0.832-1.184-4.256-1.28-7.584s-0.704-6.912-1.408-7.936c-0.672-1.056-1.344-9.12-1.472-17.888-0.384-24.448-0.48-25.952-2.176-27.008-2.464-1.568-0.192-3.936 2.688-2.816 2.016 0.736 2.24 0.512 1.28-2.816-0.672-2.112 15.456-18.432 20.064-23.488 3.584-3.936 6.624-18.88 84.928-26.016 519.872-39.584 835.136-5.312 851.456 3.712 17.312 3.2 15.424 8.064 0 8-1.568 0.64-157.248-21.696-572.448 7.008l-117.856 13.184c1.632 0 118.88-1.952 138.784-1.984 2.496 0 10.624-1.6 17.088 0 6.496 1.696 31.776 0 42.272 1.504 20.032 2.88 23.584 4.544 25.376 11.68 0.608 2.336 2.208 5.472 3.584 7.008 2.208 2.496 4.448 3.552 2.048 4.512-1.44 0.544-10.464 6.368-11.872 5.184-1.408-1.152-6.304 4.928-7.744 4.8-2.528-0.8-22.784 4.544-24.256 4.384-1.44 0-8.224-0.64-12.384-3.712-5.856-0.544-3.968-1.952-8.192-2.592-6.528 1.312-21.024-0.928-21.728 5.248-1.248 9.44-1.088 11.328 1.312 14.016 2.080 2.304 2.784 5.824 2.784 14.848-0.032 11.072 0.928 14.080 3.328 10.208 1.952-3.072 4.128 0.512 3.136 4.992-0.992 4.672 1.472 6.336 4.864 3.2 3.008-2.816 11.68 2.848 16.928 10.88 5.888 8.928 7.808 9.952 20.48 10.432 7.488 0.512 10.368 1.28 18.496 6.848 7.808 5.344 11.008 6.56 16.864 6.56 4 0 7.68 0.672 8.16 1.472 0.512 0.8 5.12 1.376 10.272 1.248 7.168-0.512 10.208 0.512 12.672 2.784 2.272 2.112 4.512 2.592 7.424 1.92 2.816-0.672 6.496 0 11.296 2.336 5.632 2.72 7.872 3.104 10.592 1.792 3.488-1.76 9.44-3.68 13.824-4.576 1.312-0.512 4.832-0.928 7.84-1.568 3.552-0.672 8.16-3.744 13.184-8.8 4.256-4.256 8.608-7.744 9.696-7.744 1.056 0 3.2-2.112 4.704-4.608 1.504-2.528 4.768-6.336 7.296-8.48 2.528-2.112 5.472-5.568 6.56-7.68 3.872-7.424 18.496-28.928 23.456-29.664 7.264-5.088 23.008-26.208 31.776-31.968 6.112-4 20.128-0.736 30.368-3.36l6.016-6.304c4.64-4.8 3.136 4.448 6.016 1.728 6.976-2.912 11.552-13.44 18.368-13.472 10.496 0 20.512 0 30.016 0 17.952 0 29.536-2.304 43.936 0 11.712 1.952-1.824 13.504-13.024 15.936-15.936 3.488-27.104 23.136-31.84 25.216-42.464 18.656-34.4 11.712-46.336 38.464-3.392 5.248-8.384 14.016-11.008 19.36s-5.472 10.624-6.304 11.712c-1.92 2.4-3.616 9.472-4.384 17.856-1.088 12.448-3.616 31.904-4.736 37.056-0.672 2.912-0.352 10.368 0.736 16.672 1.024 6.304 2.048 12.672 2.272 14.144 0.192 1.472 1.536 4.032 3.040 5.664 1.472 1.632 2.72 3.424 2.72 3.936s2.336 5.056 5.216 10.176 6.176 12.32 7.392 16.064c1.536 4.672 3.072 6.752 5.12 6.752 2.016 0 2.912 1.152 2.912 3.968 0 2.208 0.704 4 1.6 4s1.6 1.568 1.6 3.36c0 2.592 0.736 3.136 3.2 2.496 2.304-0.608 3.2 0 3.2 2.112 0 1.6 0.8 6.528 1.856 10.976 1.408 6.080 2.56 8.064 4.736 8.064 1.92 0 2.944 1.216 2.944 3.36 0 1.856 1.792 5.44 3.936 8 3.232 3.84 3.616 5.376 2.368 8.704-2.048 5.44-2.080 5.344 2.624 5.344 3.584 0 4 0.512 3.072 3.552-2.624 8.352-2.016 9.984 3.648 9.536 4.256-0.512 6.208 0.576 9.568 4.352 4.672 5.344 15.392 11.328 18.272 10.24 0.992-0.512 5.76 0.864 10.56 2.752 5.664 2.208 13.248 3.648 21.472 4 7.008 0.512 14.272 1.344 16.224 2.304 1.92 0.992 5.12 1.248 7.168 0.736 2.592-0.704 4.384 0 6.080 2.208 1.888 2.464 4.8 3.36 12.704 3.936 20.672 1.376 20.768 5.664 25.184 7.36 10.976 3.744 21.664 4.544 25.056 10.72 0.576 2.88-1.344 5.44-0.384 5.728 0.96 0.512 9.216 1.376 14.464 2.496 5.216 1.12 11.328 3.232 13.6 4.8 2.24 1.568 5.952 3.296 8.256 3.84 2.304 0.576 5.056 2.112 6.048 3.328 1.024 1.248 2.56 2.208 3.424 2.208 2.944 0 27.424 13.184 27.072 30.656-0.096 3.936 4.768 8.384 6.784 10.88l3.616 4.48c1.44 4.32 1.248 20.992-2.688 28.672zM897.408 622.976c-0.704-1.408-1.408-1.088-3.552-1.408-2.144-0.384-4.992-12.128-25.664-13.568-15.328-1.056-29.632 7.84-26.528 19.392 7.296 27.488 32.928 19.808 39.328 16.608 6.432-3.2 10.816-15.456 14.24-16.384 5.408-1.44 2.176-4.64 2.176-4.64z\"\n      />\n    </svg>\n  );\n}\n\nexport default RatIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/ZebrafishIcon.tsx" },
        "span": [162, 202],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction ZebrafishIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 1016 317\">\n      <path\n        transform=\"rotate(180, 512, 294)\"\n        fill={theme.palette.text.primary}\n        d=\"M659.328 587.488c-8.448-0.096-44.736-9.28-49.632-11.552-4.832-2.24-64.704-22.432-72.768-26.752-13.344-7.232-49.984-8.992-77.792-3.776-65.152 7.936-170.56 1.632-227.424-9.6-8.864-1.76-47.488-8.544-54.56-10.4-17.472-4.512-52.512-12.64-69.056-16.064-19.136-3.968-49.856-12.704-58.080-16.448-3.808-1.76-36-19.68-38.88-23.84-3.456-4.96-3.84-19.488-0.512-20.768 1.312-0.48 3.68-4.928 5.28-9.856 3.008-9.248 10.944-20.384 21.44-30.112 10.144-9.504 47.168-28.512 68.416-35.2 61.472-19.264 131.456-37.984 141.312-41.152 33.472-10.944 87.136-17.856 138.688-17.856l33.92-0.096c0 0 44.8-22.976 57.152-25.984 12.352-3.072 21.888 4.128 23.2 14.176s3.744 24.768 0.672 25.888c-1.44 0.576-0.928 1.888 1.632 4.16 2.624 2.336 28.48 6.56 31.776 7.968 5.696 2.336 6.144 2.272 10.848-2.016 2.752-2.528 44.288-47.168 45.856-50.080 23.936-23.392 41.056-14.944 42.528-14.944s7.84 2.944 14.112 6.624 15.648 8.512 20.768 10.816 62.112 49.6 65.184 51.616c6.56 4.512 16.576 17.952 16.672 22.432 0.032 1.696 1.12 4.576 2.496 6.4 3.072 4.032 3.264 11.392 0.448 14.24-1.568 1.568 7.584-1.024 12.224-1.152 4.672-0.128 34.784-3.008 68.672-18.048 4.64-2.368 20.448-10.56 38.016-19.328 5.6-2.816 20.416-11.36 32.96-18.88 12.544-7.68 27.424-15.936 31.36-18.464 24.8-14.4 33.792-19.040 53.056-13.664 19.328 5.376 31.488 47.872-3.36 75.36-48.576 38.368-24 51.776-20.192 56.16 9.824 11.456 34.848 34.944 39.008 39.136 12.064 12.032 21.568 33.984 18.592 42.912-4 12-29.92 34.848-95.52 9.216-2.656-1.024-15.328-7.2-28.16-13.664s-27.808-12.864-33.28-14.24c-5.376-1.344-38.016-14.336-64.416-10.496-58.656 7.296-121.216 17.024-123.584 17.664-4.864 1.376-6.688 6.912-3.2 9.6 1.376 1.024 3.904 6.656 5.696 12.64 7.328 24.448 0.288 59.936-13.088 66.336-1.504 0.832-4.576 1.12-8.48 1.088v0zM373.344 514.944c20.608 0 38.816-0.32 50.208-1.216 13.12-1.024 41.152-2.272 62.24-2.752 37.6-0.864 60.96-3.488 67.52-7.456 2.56-1.568 1.184-1.728-6.944-0.672-16.352 2.080-282.56 1.184-298.432-1.024-7.488-1.056-20.928-2.976-29.856-4.352-13.056-2.016-33.76-5.152-46.048-8.192-4.896 3.968-14.624 13.184-16.416 13.696-1.184 3.136 11.328-1.312 21.248-1.312 4.384 0 12.96 1.248 19.072 2.72s17.6 2.944 25.568 3.168c7.968 0.288 20.64 1.344 28.128 2.368 21.632 2.976 78.432 4.992 123.712 5.024v0zM100.48 479.040c0.992 0 2.144-0.608 4.128-1.92 2.336-1.536 5.024-4.32 6.048-6.208 1.536-2.88 1.312-9.504-1.536-9.504-1.888 0-3.904-1.184-4.512-0.128-0.64 0.992-6.304-11.872-4.512-10.752 1.6 1.024-3.68 24.736-12.96 21.824-2.176 1.6 3.232 1.984 4.704 1.984 1.312 0 3.68 1.28 5.408 2.784 1.408 1.312 2.272 1.92 3.232 1.92v0zM388.928 478.848c28.96 0 59.52-0.352 85.792-0.96 71.104-1.632 103.072-3.392 148.32-8.256 8.448-0.896 17.984-1.76 21.312-1.824 9.632-0.192 52.192-5.024 71.616-8.064 9.888-1.568 22.336-3.136 27.808-3.52 5.504-0.384 15.808-1.952 23.008-3.456s16.928-3.072 21.664-3.52c4.672-0.416 9.344-1.504 10.336-2.336 1.088-0.832 5.408-1.088 9.632-0.48 7.488 0.992 18.56-1.344 23.072-4.928 1.632-1.28 1.696-2.304 0.256-4.032-2.368-2.816-4.16-2.752-11.2 0.32-3.072 1.312-16.64 3.52-30.272 4.896-13.696 1.344-25.472 2.848-26.208 3.36-0.768 0.48-13.312 2.080-27.744 3.552-14.464 1.472-27.424 3.136-28.832 3.616-6.592 2.464-52.32 6.016-86.112 6.784-20.672 0.448-39.040 1.28-40.896 1.792-1.888 0.576-16.768 1.6-33.216 2.336s-35.584 2.56-42.656 4c-10.336 2.112-15.68 2.304-27.712 0.928-8.192-0.992-15.584-1.344-16.512-0.736-0.896 0.544-34.912 1.472-75.584 1.984-54.144 0.704-77.376 0.416-86.656-1.12-18.208-2.976-76.224-6.272-84.256-4.8-3.712 0.704-25.408-1.696-31.552-1.664-2.048 4-2.272 10.592-4.992 14.304-1.984 2.688 11.584-1.216 33.6-3.104 19.328-1.664 41.44-0.736 74.592 3.008 11.392 1.312 55.104 1.984 103.392 1.92v0zM71.712 475.168c0.864 0 1.76-0.128 2.56-0.416 1.536-0.352 3.136-0.288 4.672-0.416 0.448-0.128 0.992-0.416 0.864-0.992-1.408 0.096-3.072-0.16-4.096-1.248-1.792-1.344-4.096-2.016-5.344-4-1.952-1.984-3.488-4.672-3.488-7.488-0.224-1.056 0.576-2.176-0.032-3.168-0.832-0.768-1.376 0.8-1.152 1.568 0.128 1.312-1.248 2.080-1.696 3.2-0.416 1.152-0.224 2.432-0.064 3.616 0.512 2.016 1.056 4.096 2.304 5.824 0.8 1.152 1.632 2.4 2.976 2.976 0.8 0.384 1.632 0.544 2.496 0.544v0zM907.328 466.144c1.408 0 3.072-0.064 5.088-0.448 3.968-0.768 10.976-1.44 15.392-1.504 4.448 0 8.064-0.864 8.064-1.792 0-2.176-23.264-2.080-28.672 0.064-4.704 1.92-3.904 3.616 0.128 3.68v0zM108.512 454.112c1.632-1.984 5.632-7.2 3.2-9.92-1.664-1.856-3.488-4.992-4.736-4.992-4.384-2.336-17.12-9.696-15.648 0.544 4.928 0.224 9.344 6.016 8.928 12.128 4.832-1.696 6.976 1.856 8.256 2.24zM75.904 443.52c2.848-0.704 10.464-2.912 9.92-3.584l0.576-3.296c-1.024-3.072-10.176-5.312-11.296-2.368-0.576 1.536-0.544 8.416-0.096 8.864 0.16 0.192 0.448 0.32 0.896 0.384v0zM904.48 440.064c20.704 0.128 28.128-0.352 30.528-2.112 3.104-2.272 3.168-2.432-0.096-4.16-1.824-0.992-4.512-1.184-5.888-0.448s-10.944 1.856-21.216 2.432c-32.352 1.92-34.016 4.096-3.328 4.288v0zM250.912 434.304c4.992 0 11.104 0 18.56 0 39.328-0.192 109.856-3.392 129.376-5.856 6.080-0.768 38.688-1.024 72.448-0.64 176 2.112 195.488 1.504 231.872-7.136 5.632-1.344 22.016-3.264 36.448-4.192 14.336-0.992 30.048-2.944 34.944-4.288 4.8-1.344 16.48-3.296 25.824-4.384 18.56-2.080 22.432-3.872 17.184-7.712-3.808-2.88-8.064-2.784-29.088 0.288-8.48 1.28-26.080 3.104-39.232 4.16s-28.512 3.328-34.112 4.992c-9.088 2.752-17.248 4.256-34.048 6.24-54.4 6.4-153.984 8.64-162.176 3.616-5.024-3.136-100.384-1.504-132.8 2.176-8.416 0.96-22.624 2.080-31.52 2.528-8.928 0.384-25.824 1.44-37.504 2.368-19.648 1.536-77.632 0.8-80.608-1.024-2.016-1.248-6.816 4.416-5.888 6.88 0.416 1.312 5.344 1.856 20.32 1.984v0zM860.512 412.928c1.856 0 4.704-0.16 9.024-0.576 12.672-1.152 37.536-8.672 48.896-14.72l6.4-3.328-5.12 0.192c-2.816 0.064-8.96 1.248-13.632 2.624-4.736 1.312-14.656 3.552-22.176 4.928-24.224 4.352-25.504 4.672-26.112 8.16-0.384 1.952-0.256 2.688 2.72 2.72v0zM706.24 397.504c11.456 0.096 15.488-1.28 13.152-4.064-1.12-1.376-7.072-2.656-15.072-3.232-7.2-0.48-24.992-1.728-39.52-2.752-14.528-1.056-31.776-2.080-38.336-2.368-6.592-0.256-22.688-1.76-35.808-3.328s-27.648-3.232-32.352-3.584c-11.616-0.928-21.536-2.688-25.632-4.512-1.888-0.8-9.952-2.112-17.92-2.944s-40.96-1.568-73.344-1.728c-47.936-0.288-60.704 0.224-69.056 2.336-5.6 1.44-11.936 2.944-14.048 3.392-2.112 0.416-3.84 1.504-3.84 2.4 0 0.864 1.696 2.784 3.84 4.128 3.36 2.176 4.992 2.176 13.216-0.128 5.824-1.504 15.488-2.304 25.568-2.112 8.896 0.224 23.488-0.192 32.384-0.864 14.816-1.152 31.2-0.384 82.88 3.872 9.472 0.8 17.984 1.888 18.912 2.4 4.704 2.976 37.856 5.856 109.632 9.664 17.344 0.896 40.448 2.112 51.328 2.816 5.504 0.352 10.144 0.512 13.984 0.544v0.064zM867.104 376.96c3.136 0.128 8.32-1.12 16.384-3.776 9.056-3.040 11.136-4.288 9.536-5.92-2.4-2.368-2.144-2.368-16.768 0.8-11.68 2.496-14.688 4.192-12.864 7.264 0.64 1.024 1.792 1.568 3.712 1.632v0zM723.648 358.176c0.672 0 0.576-0.576-0.128-1.6-0.576-0.928-5.824-3.936-11.552-6.656-5.792-2.656-14.368-5.344-19.072-5.92l-8.48-0.928 7.648 2.24c4.224 1.248 12.736 4.736 19.072 7.648 7.776 3.712 11.328 5.216 12.512 5.216v0zM677.216 342.56l-6.816-2.528c-3.744-1.344-51.872-11.488-57.92-11.36-14.976-0.384-30.944 2.944-19.52 4.672 4.192 0.64 68.448 7.552 73.984 8.128l10.272 1.088zM452 319.040c0.288 0 0.608 0 0.96 0 3.712-0.128 23.424-12.32 23.424-14.496 0-4.032-10.752-2.048-19.968 3.744-6.432 4.128-8.704 10.208-4.416 10.752v0z\"\n      />\n    </svg>\n  );\n}\n\nexport default ZebrafishIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ComparativeGenomics/WormIcon.tsx" },
        "span": [157, 196],
        "sourceCode": "import type { Theme } from \"@mui/material\";\nimport { useTheme } from \"@mui/styles\";\n\nfunction WormIcon() {\n  const theme: Theme = useTheme();\n  return (\n    <svg height=\"13\" viewBox=\"0 0 972 922\">\n      <path\n        transform=\"rotate(180, 502, 465)\"\n        fill={theme.palette.text.primary}\n        d=\"M940.32 865.92c0 0-201.952 110.944-331.008 37.536-129.088-73.376-154.4-227.776-126.56-323.936 27.84-96.192 118.976-364.448-20.256-435.328-21.12-10.752-92.832-50.272-214.496-17.28-45.536 17.728-84 52.352-99.328 110.944-23.008 88.064-31.008 221.408-78.464 334.080-25.888 61.472-43.328 14.016-34.24-16.416-1.056-3.36 10.72-71.776 16.352-120.256 7.392-63.616 4.928-86.336 20.416-194.88 32.512-227.84 256.896-238.432 323.968-230.272 169.504 20.608 232.992 125.696 253.088 197.408 35.424 126.528-46.784 341.44-68.352 425.184-22.752 88.608 4.32 211.744 124.032 232.832 108.192 19.072 226.528-43.296 254.848-51.584 63.68-18.72 53.376 8.928-20 51.968z\"\n      />\n    </svg>\n  );\n}\n\nexport default WormIcon;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: client" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1809, 1815],
              "sourceCode": "import { Tab, Tabs } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\n\nimport { definition } from \".\";\nimport AtlasTab from \"./AtlasTab\";\nimport Description from \"./Description\";\nimport GtexTab, { getData as getGtexData } from \"./GtexTab\";\nimport SummaryTab, { getData as getSummaryData } from \"./SummaryTab\";\n\nfunction Section({ id: ensgId, label: symbol, entity }) {\n  const defaultTab = \"summary\";\n  const [tab, setTab] = useState(defaultTab);\n  const [requestSummary, setRequestSummary] = useState({ loading: true });\n  const [requestGtex, setRequestGtex] = useState({ loading: true });\n  const client = useApolloClient();\n  // TODO:\n  // the part about requests (see below) will need rethinking / refactoring\n  // SectionItem checks for data based on these requests, but only works for data coming from the target object\n  // the widget displays based on the summary tab only.\n  // Atlas and gTex tab should always be there is the widget is visible, hence the hack of using requestSummary for Atlas\n  // the request for gTex wraps the data in a structure similar to that from the target object:\n  // this can be probably be rewritten differently, but that's a wider scope than the MUI migration we're currently doing\n  const [request, setRequest] = {\n    summary: [requestSummary, setRequestSummary],\n    atlas: [requestSummary, setRequestSummary], // [{ loading: false, data: true }, undefined],\n    gtex: [requestGtex, setRequestGtex],\n  }[tab];\n\n  const getData = {\n    summary: getSummaryData,\n    gtex: getGtexData,\n  }[tab];\n\n  const handleChangeTab = (_, tabChange) => {\n    setTab(tabChange);\n  };\n\n  useEffect(() => {\n    let isCurrent = true;\n\n    async function updateData() {\n      const newRequest = await getData(ensgId, client);\n      if (isCurrent) setRequest(newRequest);\n    }\n\n    if (!request.data && getData) {\n      setRequest({ loading: true });\n      updateData();\n    }\n\n    return () => {\n      isCurrent = false;\n    };\n  }, [tab, ensgId, request.data, getData, setRequest]);\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading={true}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => (\n        <>\n          <Tabs value={tab} onChange={handleChangeTab} style={{ marginBottom: \"1rem\" }}>\n            <Tab value=\"summary\" label=\"Summary\" />\n            <Tab value=\"atlas\" label=\"Experiments (Expression Atlas)\" />\n            <Tab value=\"gtex\" label=\"Variation (GTEx)\" />\n          </Tabs>\n          {tab === \"summary\" && <SummaryTab symbol={symbol} data={request.data} />}\n          {tab === \"atlas\" && <AtlasTab ensgId={ensgId} symbol={symbol} />}\n          {tab === \"gtex\" && <GtexTab symbol={symbol} data={request.data} />}\n        </>\n      )}\n    />\n  );\n}\n\nexport default Section;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/Body.jsx" },
        "span": [1683, 1692],
        "sourceCode": "import { Tab, Tabs } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\n\nimport { definition } from \".\";\nimport AtlasTab from \"./AtlasTab\";\nimport Description from \"./Description\";\nimport GtexTab, { getData as getGtexData } from \"./GtexTab\";\nimport SummaryTab, { getData as getSummaryData } from \"./SummaryTab\";\n\nfunction Section({ id: ensgId, label: symbol, entity }) {\n  const defaultTab = \"summary\";\n  const [tab, setTab] = useState(defaultTab);\n  const [requestSummary, setRequestSummary] = useState({ loading: true });\n  const [requestGtex, setRequestGtex] = useState({ loading: true });\n  const client = useApolloClient();\n  // TODO:\n  // the part about requests (see below) will need rethinking / refactoring\n  // SectionItem checks for data based on these requests, but only works for data coming from the target object\n  // the widget displays based on the summary tab only.\n  // Atlas and gTex tab should always be there is the widget is visible, hence the hack of using requestSummary for Atlas\n  // the request for gTex wraps the data in a structure similar to that from the target object:\n  // this can be probably be rewritten differently, but that's a wider scope than the MUI migration we're currently doing\n  const [request, setRequest] = {\n    summary: [requestSummary, setRequestSummary],\n    atlas: [requestSummary, setRequestSummary], // [{ loading: false, data: true }, undefined],\n    gtex: [requestGtex, setRequestGtex],\n  }[tab];\n\n  const getData = {\n    summary: getSummaryData,\n    gtex: getGtexData,\n  }[tab];\n\n  const handleChangeTab = (_, tabChange) => {\n    setTab(tabChange);\n  };\n\n  useEffect(() => {\n    let isCurrent = true;\n\n    async function updateData() {\n      const newRequest = await getData(ensgId, client);\n      if (isCurrent) setRequest(newRequest);\n    }\n\n    if (!request.data && getData) {\n      setRequest({ loading: true });\n      updateData();\n    }\n\n    return () => {\n      isCurrent = false;\n    };\n  }, [tab, ensgId, request.data, getData, setRequest]);\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading={true}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => (\n        <>\n          <Tabs value={tab} onChange={handleChangeTab} style={{ marginBottom: \"1rem\" }}>\n            <Tab value=\"summary\" label=\"Summary\" />\n            <Tab value=\"atlas\" label=\"Experiments (Expression Atlas)\" />\n            <Tab value=\"gtex\" label=\"Variation (GTEx)\" />\n          </Tabs>\n          {tab === \"summary\" && <SummaryTab symbol={symbol} data={request.data} />}\n          {tab === \"atlas\" && <AtlasTab ensgId={ensgId} symbol={symbol} />}\n          {tab === \"gtex\" && <GtexTab symbol={symbol} data={request.data} />}\n        </>\n      )}\n    />\n  );\n}\n\nexport default Section;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: tab",
      "message": [
        { "elements": [], "content": "This hook specifies more dependencies than necessary: tab" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2027, 2030],
              "sourceCode": "import { Tab, Tabs } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\n\nimport { definition } from \".\";\nimport AtlasTab from \"./AtlasTab\";\nimport Description from \"./Description\";\nimport GtexTab, { getData as getGtexData } from \"./GtexTab\";\nimport SummaryTab, { getData as getSummaryData } from \"./SummaryTab\";\n\nfunction Section({ id: ensgId, label: symbol, entity }) {\n  const defaultTab = \"summary\";\n  const [tab, setTab] = useState(defaultTab);\n  const [requestSummary, setRequestSummary] = useState({ loading: true });\n  const [requestGtex, setRequestGtex] = useState({ loading: true });\n  const client = useApolloClient();\n  // TODO:\n  // the part about requests (see below) will need rethinking / refactoring\n  // SectionItem checks for data based on these requests, but only works for data coming from the target object\n  // the widget displays based on the summary tab only.\n  // Atlas and gTex tab should always be there is the widget is visible, hence the hack of using requestSummary for Atlas\n  // the request for gTex wraps the data in a structure similar to that from the target object:\n  // this can be probably be rewritten differently, but that's a wider scope than the MUI migration we're currently doing\n  const [request, setRequest] = {\n    summary: [requestSummary, setRequestSummary],\n    atlas: [requestSummary, setRequestSummary], // [{ loading: false, data: true }, undefined],\n    gtex: [requestGtex, setRequestGtex],\n  }[tab];\n\n  const getData = {\n    summary: getSummaryData,\n    gtex: getGtexData,\n  }[tab];\n\n  const handleChangeTab = (_, tabChange) => {\n    setTab(tabChange);\n  };\n\n  useEffect(() => {\n    let isCurrent = true;\n\n    async function updateData() {\n      const newRequest = await getData(ensgId, client);\n      if (isCurrent) setRequest(newRequest);\n    }\n\n    if (!request.data && getData) {\n      setRequest({ loading: true });\n      updateData();\n    }\n\n    return () => {\n      isCurrent = false;\n    };\n  }, [tab, ensgId, request.data, getData, setRequest]);\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading={true}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => (\n        <>\n          <Tabs value={tab} onChange={handleChangeTab} style={{ marginBottom: \"1rem\" }}>\n            <Tab value=\"summary\" label=\"Summary\" />\n            <Tab value=\"atlas\" label=\"Experiments (Expression Atlas)\" />\n            <Tab value=\"gtex\" label=\"Variation (GTEx)\" />\n          </Tabs>\n          {tab === \"summary\" && <SummaryTab symbol={symbol} data={request.data} />}\n          {tab === \"atlas\" && <AtlasTab ensgId={ensgId} symbol={symbol} />}\n          {tab === \"gtex\" && <GtexTab symbol={symbol} data={request.data} />}\n        </>\n      )}\n    />\n  );\n}\n\nexport default Section;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/Body.jsx" },
        "span": [1683, 1692],
        "sourceCode": "import { Tab, Tabs } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient } from \"ui\";\n\nimport { definition } from \".\";\nimport AtlasTab from \"./AtlasTab\";\nimport Description from \"./Description\";\nimport GtexTab, { getData as getGtexData } from \"./GtexTab\";\nimport SummaryTab, { getData as getSummaryData } from \"./SummaryTab\";\n\nfunction Section({ id: ensgId, label: symbol, entity }) {\n  const defaultTab = \"summary\";\n  const [tab, setTab] = useState(defaultTab);\n  const [requestSummary, setRequestSummary] = useState({ loading: true });\n  const [requestGtex, setRequestGtex] = useState({ loading: true });\n  const client = useApolloClient();\n  // TODO:\n  // the part about requests (see below) will need rethinking / refactoring\n  // SectionItem checks for data based on these requests, but only works for data coming from the target object\n  // the widget displays based on the summary tab only.\n  // Atlas and gTex tab should always be there is the widget is visible, hence the hack of using requestSummary for Atlas\n  // the request for gTex wraps the data in a structure similar to that from the target object:\n  // this can be probably be rewritten differently, but that's a wider scope than the MUI migration we're currently doing\n  const [request, setRequest] = {\n    summary: [requestSummary, setRequestSummary],\n    atlas: [requestSummary, setRequestSummary], // [{ loading: false, data: true }, undefined],\n    gtex: [requestGtex, setRequestGtex],\n  }[tab];\n\n  const getData = {\n    summary: getSummaryData,\n    gtex: getGtexData,\n  }[tab];\n\n  const handleChangeTab = (_, tabChange) => {\n    setTab(tabChange);\n  };\n\n  useEffect(() => {\n    let isCurrent = true;\n\n    async function updateData() {\n      const newRequest = await getData(ensgId, client);\n      if (isCurrent) setRequest(newRequest);\n    }\n\n    if (!request.data && getData) {\n      setRequest({ loading: true });\n      updateData();\n    }\n\n    return () => {\n      isCurrent = false;\n    };\n  }, [tab, ensgId, request.data, getData, setRequest]);\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading={true}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => (\n        <>\n          <Tabs value={tab} onChange={handleChangeTab} style={{ marginBottom: \"1rem\" }}>\n            <Tab value=\"summary\" label=\"Summary\" />\n            <Tab value=\"atlas\" label=\"Experiments (Expression Atlas)\" />\n            <Tab value=\"gtex\" label=\"Variation (GTEx)\" />\n          </Tabs>\n          {tab === \"summary\" && <SummaryTab symbol={symbol} data={request.data} />}\n          {tab === \"atlas\" && <AtlasTab ensgId={ensgId} symbol={symbol} />}\n          {tab === \"gtex\" && <GtexTab symbol={symbol} data={request.data} />}\n        </>\n      )}\n    />\n  );\n}\n\nexport default Section;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/DepMap/DepmapPlot.jsx" },
        "span": [403, 536],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport * as Plot from \"@observablehq/plot\";\nimport { sentenceCase } from \"@ot/utils\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader } from \"ui\";\n\nconst prepareData = (data = []) => {\n  const flatData = data.reduce((accumulator, currentValue) => {\n    currentValue.screens.forEach((dot) => {\n      accumulator.push({ ...dot, tissueName: sentenceCase(currentValue.tissueName) });\n    });\n    return accumulator;\n  }, []);\n  return flatData;\n};\n\nfunction Wrapper({ data, query, variables }) {\n  const [ref, { width }] = useMeasure();\n  const parsedData = prepareData(data);\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\" }}>\n      <Box sx={{ width: \"95%\" }} ref={ref}>\n        <ChartControls data={parsedData} query={query} variables={variables} />\n        <DepmapPlot data={parsedData} width={width} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export data\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={[\n          { exportValue: (row) => row.depmapId, id: \"depmapId\" },\n          { exportValue: (row) => row.cellLineName, id: \"cellLineName\" },\n          { exportValue: (row) => row.diseaseFromSource, id: \"diseaseFromSource\" },\n          { exportValue: (row) => row.geneEffect, id: \"geneEffect\" },\n          { exportValue: (row) => row.expression, id: \"expression\" },\n          { exportValue: (row) => row.tissueName, id: \"tissueName\" },\n        ]}\n      />\n    </Box>\n  );\n}\n\nfunction DepmapPlot({ data, width }) {\n  const headerRef = useRef();\n  useEffect(() => {\n    if (data === undefined || width === null) return;\n    const chart = Plot.plot({\n      width: width,\n      marginLeft: 200,\n      style: {\n        background: \"transparent\",\n        fontSize: \"12px\",\n      },\n      x: {\n        type: \"symlog\",\n        domain: [-6, -1, 6],\n        grid: true,\n        label: null,\n      },\n      color: {\n        domain: [\"Dependency\", \"Neutral\"],\n        range: [\"#EC2846\", \"#08519C\"],\n        type: \"ordinal\",\n        label: \"Gene effect - log(x)\",\n        legend: true,\n      },\n      marks: [\n        Plot.ruleX([-1], { strokeDasharray: 4, stroke: \"#EC2846\" }),\n        Plot.boxX(data, {\n          r: 0,\n          x: \"geneEffect\",\n          y: \"tissueName\",\n          opacity: 0.5,\n        }),\n        Plot.dot(data, {\n          x: \"geneEffect\",\n          y: \"tissueName\",\n          channels: {\n            cellLineName: {\n              value: \"cellLineName\",\n              label: \"\",\n            },\n            geneEffect: {\n              value: \"geneEffect\",\n              label: \"Gene effect:\",\n            },\n            tissueName: {\n              value: \"tissueName\",\n              label: \"Tissue:\",\n            },\n            expression: {\n              value: \"expression\",\n              label: \"Expression:\",\n            },\n            diseaseFromSource: {\n              value: \"diseaseFromSource\",\n              label: \"Disease:\",\n            },\n          },\n          tip: {\n            fontSize: 14,\n            textPadding: 10,\n            format: {\n              fill: false,\n              cellLineName: true,\n              diseaseFromSource: true,\n              x: false,\n              y: false,\n            },\n          },\n          fill: (d) => (d.geneEffect < -1 ? \"#EC2846\" : \"#08519C\"),\n          fillOpacity: 0.5,\n        }),\n        Plot.axisY({\n          label: \"Tissue name\",\n        }),\n        Plot.axisX({\n          label: \"Gene Effect\",\n        }),\n        Plot.crosshair(data, { x: \"geneEffect\", y: \"tissueName\" }),\n      ],\n    });\n    headerRef.current.append(chart);\n    return () => chart.remove();\n  }, [data, width]);\n\n  return <Box ref={headerRef} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: theme.boxShadow.default",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: theme.boxShadow.default"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5381, 5404],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/sections/src/target/ComparativeGenomics/ComparativeGenomicsPlot.tsx"
        },
        "span": [4388, 4397],
        "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: theme.palette.primary.main",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: theme.palette.primary.main"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [10043, 10069],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [9488, 9514],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [11676, 11702],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [10635, 10661],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/sections/src/target/ComparativeGenomics/ComparativeGenomicsPlot.tsx"
        },
        "span": [4388, 4397],
        "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: theme.typography.body2.fontSize",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: theme.typography.body2.fontSize"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5321, 5352],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/sections/src/target/ComparativeGenomics/ComparativeGenomicsPlot.tsx"
        },
        "span": [4388, 4397],
        "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: y",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: y" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7782, 7783],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [9874, 9875],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [9273, 9274],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/sections/src/target/ComparativeGenomics/ComparativeGenomicsPlot.tsx"
        },
        "span": [4388, 4397],
        "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: theme.typography.body2.fontFamily",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: theme.typography.body2.fontFamily"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5260, 5293],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/sections/src/target/ComparativeGenomics/ComparativeGenomicsPlot.tsx"
        },
        "span": [4388, 4397],
        "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: theme.palette.primary.dark",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: theme.palette.primary.dark"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [10093, 10119],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [9538, 9564],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [11849, 11875],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [10809, 10835],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/sections/src/target/ComparativeGenomics/ComparativeGenomicsPlot.tsx"
        },
        "span": [4388, 4397],
        "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: theme.palette.text.primary",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: theme.palette.text.primary"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12238, 12264],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [11199, 11225],
              "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/sections/src/target/ComparativeGenomics/ComparativeGenomicsPlot.tsx"
        },
        "span": [4388, 4397],
        "sourceCode": "import { Box, Skeleton, Typography, useTheme } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { useMeasure } from \"@uidotdev/usehooks\";\nimport * as d3 from \"d3\";\nimport { useEffect, useRef } from \"react\";\nimport { DataDownloader, Link } from \"ui\";\n\nconst content = {\n  mouseOrthologMaxIdentityPercentage:\n    \"The Mouse Ortholog Identity visualization highlights the maximum sequence identity (%) of mouse orthologs for a given target, providing insight into its potential for in vivo assays. Data is sourced from the Ensembl Compara widget, and only orthologs with at least 80% identity are considered. Scores range from 0 to 1, where 1 indicates a mouse gene with 100% identity to the target, and 0 means no gene meets the 80% threshold. If multiple orthologs exist, the highest identity percentage is displayed.\",\n  paralogMaxIdentityPercentage:\n    \"The Paralogues visualization displays the maximum sequence identity (%) of paralogues within the human genome, offering insights into functional redundancy or diversity. Data is sourced from the Ensembl Compara widget, focusing on paralogues with at least 60% identity to the target. Scores range from 0 to -1, where -1 represents paralogues with higher identity (≥60%), and 0 indicates paralogues with lower identity.\",\n};\nconst contentURL = {\n  mouseOrthologMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#mouse-ortholog-identity\",\n  paralogMaxIdentityPercentage:\n    \"https://platform-docs.opentargets.org/web-interface/target-prioritisation#paralogues\",\n};\n\nfunction getTooltipContent(homolog) {\n  return `<div>\n    ${getPropText(homolog, \"homologyType\", \"Type\")}\n    ${getPropText(homolog, \"targetGeneSymbol\", \"Homolog\")}\n    ${getPropText(homolog, \"queryPercentageIdentity\", \"Query Percentage\")}\n    ${getPropText(homolog, \"targetPercentageIdentity\", \"Target Percentage\")}\n  </div>`;\n}\n\nfunction getPropText(homolog, prop, label) {\n  return `<div>\n  <b> ${label}:</b> ${homolog[prop]}\n</div>`;\n}\n\nconst yAxisValues = [\n  \"6239\",\n  \"7227\",\n  \"7955\",\n  \"8364\",\n  \"9823\",\n  \"9615\",\n  \"10141\",\n  \"9986\",\n  \"10116\",\n  \"10090\",\n  \"9544\",\n  \"9598\",\n  \"9606\",\n];\n\nconst TOOLTIP_ID = \"tolltip-template-comp-genomic\";\nconst dotDefaultRadious = 6;\nconst dotDefaultOpacity = 0.7;\n\nfunction Wrapper({ homologues, viewMode, loading, query, variables, columns }) {\n  const [ref, { width }] = useMeasure();\n  if (loading)\n    return (\n      <Box>\n        <Skeleton height={400} />\n      </Box>\n    );\n  return (\n    <Box sx={{ display: \"flex\", flexDirection: \"column\" }}>\n      <ChartControls data={homologues} query={query} variables={variables} columns={columns} />\n      {viewMode !== \"default\" && (\n        <Typography sx={{ width: \"85%\", my: 2, ml: 4 }} variant=\"body2\">\n          {content[viewMode]}\n          <Link external to={contentURL[viewMode]}>\n            Documentation\n          </Link>\n        </Typography>\n      )}\n      <Box sx={{ width: \"95%\", margin: \"0 auto\", position: \"relative\" }} ref={ref}>\n        <div style={{ height: 0 }} id={TOOLTIP_ID} />\n        <Visualisation homologues={homologues} width={width} viewMode={viewMode} />\n      </Box>\n    </Box>\n  );\n}\n\nfunction ChartControls({ data, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={data}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nconst labels = {\n  6239: \"Caenorhabditis elegans (Nematode, N2)\",\n  7227: \"Drosophila melanogaster (Fruit fly)\",\n  7955: \"Zebrafish\",\n  8364: \"Tropical clawed frog\",\n  9823: \"Pig\",\n  9615: \"Dog\",\n  10141: \"Guinea Pig\",\n  9986: \"Rabbit\",\n  10116: \"Rat\",\n  10090: \"Mouse\",\n  9544: \"Macaque\",\n  9598: \"Chimpanzee\",\n  9606: \"Human\",\n};\n\nfunction Visualisation({ homologues, width, viewMode }) {\n  const theme = useTheme();\n  const containerReference = useRef();\n  const height = 400;\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  // Declare the y (vertical position) scale.\n  const y = d3\n    .scalePoint()\n    .domain(yAxisValues)\n    .range([height - marginBottom * 2, marginTop]);\n\n  useEffect(() => {\n    if (!homologues) return;\n    const chartWidth = (width - marginRight) * 0.4;\n\n    // Declare the x (horizontal position) scale.\n    const queryScale = d3.scaleLinear().domain([0, 100]).range([marginLeft, chartWidth]);\n    const targetScale = d3\n      .scaleLinear()\n      .domain([100, 0])\n      .range([width - chartWidth, width - marginRight]);\n\n    // Create the SVG container.\n    const svg = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n    const tooltip = d3\n      .select(`#${TOOLTIP_ID}`)\n      .append(\"div\")\n      .style(\"opacity\", 0)\n      .attr(\"class\", \"tooltip\")\n      .style(\"position\", \"absolute\")\n      .style(\"background-color\", \"white\")\n      .style(\"border\", `1px solid ${grey[400]}`)\n      .style(\"border-radius\", \"3px\")\n      .style(\"padding\", \"5px\")\n      .style(\"width\", \"175px\")\n      .style(\"font-family\", theme.typography.body2.fontFamily)\n      .style(\"font-size\", theme.typography.body2.fontSize)\n      .style(\"box-shadow\", theme.boxShadow.default);\n\n    const mouseover = function (d) {\n      tooltip.style(\"opacity\", 1);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", 1)\n        .attr(\"r\", dotDefaultRadious * 2);\n    };\n    const mousemove = function (d) {\n      const mouseX = d3.mouse(this)[0];\n      const mouseY = d3.mouse(this)[1];\n      const bottom = mouseY > height / 2 ? `${height - mouseY + 8}px` : \"initial\";\n      const left = mouseX < width / 2 ? `${mouseX + 8}px` : \"initial\";\n      const right = mouseX > width / 2 ? `${width - mouseX + 8}px` : \"initial\";\n      const top = mouseY < height / 2 ? `${mouseY + 8}px` : \"initial\";\n      tooltip\n        .style(\"top\", top)\n        .style(\"right\", right)\n        .style(\"bottom\", bottom)\n        .style(\"left\", left)\n        .html(getTooltipContent(d));\n    };\n    const mouseleave = function (d) {\n      tooltip.style(\"opacity\", 0);\n      const classId = `.${d.targetGeneId}_${d.speciesId}`;\n      d3.selectAll(classId)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n      d3.select(this)\n        .transition()\n        .duration(300)\n        .attr(\"fill-opacity\", dotDefaultOpacity)\n        .attr(\"r\", dotDefaultRadious);\n    };\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(queryScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", marginLeft)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"Query Percentage Identity →\")\n      );\n\n    // Add the x-axis.\n    svg\n      .append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(targetScale))\n      .call((g) =>\n        g\n          .append(\"text\")\n          .attr(\"x\", width - marginRight)\n          .attr(\"y\", marginBottom - 1)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"end\")\n          .text(\"← Target Percentage Identity\")\n      );\n\n    const yAxis = d3\n      .axisLeft(y)\n      .tickFormat((d) => labels[d])\n      .tickSize(0);\n    // Add the y-axis.\n    svg\n      .append(\"g\")\n      .attr(\"class\", \"queryContainer\")\n      .attr(\"transform\", `translate(${width / 2},0)`)\n      .style(\"text-anchor\", \"middle\")\n      .style(\"font-size\", \"0.85rem\")\n      .style(\"font-weight\", 400)\n      .call(yAxis)\n      .call((g) => g.select(\".domain\").remove());\n\n    svg\n      .append(\"g\")\n      .attr(\"stroke\", \"currentColor\")\n      .attr(\"stroke-opacity\", 0.1)\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(queryScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => queryScale(d))\n          .attr(\"x2\", (d) => queryScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      )\n      .call((g) =>\n        g\n          .append(\"g\")\n          .selectAll(\"line\")\n          .data(targetScale.ticks())\n          .join(\"line\")\n          .attr(\"x1\", (d) => targetScale(d))\n          .attr(\"x2\", (d) => targetScale(d))\n          .attr(\"y1\", marginTop)\n          .attr(\"y2\", height - marginBottom)\n      );\n\n    // Create the grid\n    const queryContainer = svg.append(\"g\").attr(\"class\", \"queryContainer\");\n    const targetContainer = svg.append(\"g\").attr(\"class\", \"targetContainer\");\n\n    queryContainer\n      .selectAll(\".query\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => queryScale(d.queryPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"id\", (_d, i) => i)\n      .attr(\"fill-opacity\", dotDefaultOpacity)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    targetContainer\n      .selectAll(\".target\")\n      .data(homologues)\n      .enter()\n      .append(\"circle\")\n      .attr(\"cx\", (d) => targetScale(d.targetPercentageIdentity))\n      .attr(\"cy\", (d) => y(d.speciesId))\n      .attr(\"r\", dotDefaultRadious)\n      .attr(\"class\", (d) => `${d.targetGeneId}_${d.speciesId}`)\n      .attr(\"fill-opacity\", 0.7)\n      .attr(\"fill\", theme.palette.primary.main)\n      .attr(\"stroke\", theme.palette.primary.dark)\n      .on(\"mouseover\", mouseover)\n      .on(\"mousemove\", mousemove)\n      .on(\"mouseleave\", mouseleave);\n\n    if (viewMode === \"mouseOrthologMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 80 && d.speciesId === \"10090\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(80))\n        .attr(\"x2\", queryScale(80))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#2e5943\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"10090\" ? theme.palette.text.primary : grey[400]));\n    }\n    if (viewMode === \"paralogMaxIdentityPercentage\") {\n      queryContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n      targetContainer.selectAll(\"circle\").attr(\"fill\", grey[300]).attr(\"stroke\", grey[300]);\n\n      queryContainer\n        .selectAll(\"circle\")\n        // .transition(300)\n        .attr(\"fill\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.main\n            : grey[300]\n        )\n        .attr(\"stroke\", (d) =>\n          d.queryPercentageIdentity > 60 && d.speciesId === \"9606\"\n            ? theme.palette.primary.dark\n            : grey[300]\n        );\n      queryContainer\n        .append(\"line\")\n        .attr(\"x1\", queryScale(60))\n        .attr(\"x2\", queryScale(60))\n        .attr(\"y1\", marginTop)\n        .attr(\"y2\", height - marginBottom)\n        .attr(\"stroke\", \"#e3a772\");\n\n      svg\n        .selectAll(\".queryContainer text\")\n        .attr(\"color\", (d) => (d === \"9606\" ? theme.palette.text.primary : grey[400]));\n    }\n\n    // Append the SVG element.\n    containerReference.current.append(svg.node());\n    return () => {\n      tooltip.remove();\n      svg.remove();\n    };\n  }, [homologues, width, viewMode]);\n\n  return <div ref={containerReference} />;\n}\n\nexport default Wrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/GtexTab.jsx" },
        "span": [610, 787],
        "sourceCode": "import { median as d3Median, quantile } from \"d3\";\nimport { useRef } from \"react\";\nimport { DownloadSvgPlot } from \"ui\";\n\nimport GtexVariability from \"./GtexVariability\";\n\nconst transformData = (data) =>\n  data.map((d) => {\n    // d3 requires for the array of values to be sorted before using median and quantile\n    d.data.sort((a, b) => a - b);\n    const median = d3Median(d.data);\n    const q1 = quantile(d.data, 0.25);\n    const q3 = quantile(d.data, 0.75);\n    const outliers = [];\n    const notoutliers = [];\n    const iqr = q3 - q1; // interquartile range\n\n    // find the outliers and not outliers\n    d.data.forEach((item) => {\n      if (item < q1 - 1.5 * iqr || item > q3 + 1.5 * iqr) {\n        outliers.push(item);\n      } else {\n        notoutliers.push(item);\n      }\n    });\n\n    return {\n      tissueSiteDetailId: d.tissueSiteDetailId,\n      median,\n      q1,\n      q3,\n      lowerLimit: notoutliers[0],\n      upperLimit: notoutliers[notoutliers.length - 1],\n      outliers,\n    };\n  });\n\nexport async function getData(symbol) {\n  try {\n    const urlGene = `https://gtexportal.org/api/v2/reference/gene?format=json&geneId=${symbol}`;\n    const resGene = await fetch(urlGene);\n    const rawGene = await resGene.json();\n    const { gencodeId } = rawGene.data[0];\n    const urlData = `https://gtexportal.org/api/v2/expression/geneExpression?gencodeId=${gencodeId}`;\n    const resData = await fetch(urlData);\n    const rawData = await resData.json();\n    // TODO:\n    // in order for the SectionItem null check to work, the data needs to match the target object format.\n    // Ideally when switching tabs we don't want to check and hide the widget, so this should be handled differently\n    const data = {\n      target: {\n        expressions: transformData(rawData.data),\n      },\n    };\n\n    return { loading: false, data };\n  } catch (error) {\n    return { loading: false, error };\n  }\n}\n\nfunction GtexTab({ symbol, data }) {\n  const gtexVariability = useRef();\n\n  return (\n    <DownloadSvgPlot svgContainer={gtexVariability} filenameStem={`${symbol}-gtex`}>\n      <GtexVariability data={data.target.expressions} ref={gtexVariability} />\n    </DownloadSvgPlot>\n  );\n}\n\nexport default GtexTab;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/SummaryTable.jsx" },
        "span": [947, 1715],
        "sourceCode": "import {\n  Grid,\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  ToggleButton,\n  ToggleButtonGroup,\n  Typography,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport classNames from \"classnames\";\nimport maxBy from \"lodash/maxBy\";\nimport { useState } from \"react\";\n\nimport SummaryRow from \"./SummaryRow\";\n\nconst getMaxRnaValue = (expressions) => {\n  if (expressions.length <= 0) return 0;\n  return maxBy(expressions, (expression) => (expression?.rna ? expression.rna.value : 0)).rna.value;\n};\n\n// function that transforms tissue data into an array of objects\n// where each object has the following shape and where tissues is\n// an array of tissues that belong to the parent category\n// {\n//   parentLabel: string\n//   tissues: []\n//   maxRnaValue: number\n//   maxRnaLevel: number\n//   maxProteinLevel: number\n// }\nconst groupTissues = (expressions, groupBy) => {\n  const groupedTissues = {};\n\n  expressions.forEach((expression) => {\n    const parentLabels = expression.tissue[groupBy];\n    parentLabels.forEach((label) => {\n      if (!groupedTissues[label]) {\n        groupedTissues[label] = {\n          parentLabel: label,\n          tissues: [],\n          maxRnaValue: Number.NEGATIVE_INFINITY,\n          maxRnaLevel: Number.NEGATIVE_INFINITY,\n          maxProteinLevel: Number.NEGATIVE_INFINITY,\n        };\n      }\n\n      const parent = groupedTissues[label];\n\n      parent.tissues.push(expression);\n      parent.maxRnaValue = Math.max(parent.maxRnaValue, expression.rna.value);\n      parent.maxRnaLevel = Math.max(parent.maxRnaLevel, expression.rna.level);\n      parent.maxProteinLevel = Math.max(parent.maxProteinLevel, expression.protein.level);\n    });\n  });\n\n  return Object.values(groupedTissues);\n};\n\nconst tissueComparator = (sortBy) => {\n  if (sortBy === \"rna\") {\n    return (a, b) => b.rna.value - a.rna.value;\n  }\n\n  return (a, b) => b.protein.level - a.protein.level;\n};\n\nconst parentComparator = (sortBy) => {\n  if (sortBy === \"rna\") {\n    return (a, b) => b.maxRnaValue - a.maxRnaValue;\n  }\n\n  return (a, b) => b.maxProteinLevel - a.maxProteinLevel;\n};\n\nconst sort = (parents, sortBy) => {\n  parents.forEach((parent) => {\n    parent.tissues.sort(tissueComparator(sortBy));\n  });\n  return parents.sort(parentComparator(sortBy));\n};\n\nconst useStyles = makeStyles({\n  groupBy: {\n    marginBottom: \"20px\",\n    marginTop: \"40px\",\n  },\n  groupByText: {\n    marginRight: \"7px !important\",\n  },\n  headerCell: {\n    textAlign: \"center !important\",\n  },\n  rnaCell: {\n    paddingRight: \"8px\",\n  },\n  proteinCell: {\n    paddingLeft: \"8px\",\n  },\n  highLow: {\n    border: \"none !important\",\n  },\n});\n\nfunction SummaryTable({ data }) {\n  const [groupBy, setGroupBy] = useState(\"organs\");\n  const [sortBy, setSortBy] = useState(\"rna\");\n\n  const classes = useStyles();\n  const maxRnaValue = getMaxRnaValue(data);\n  const parents = sort(groupTissues(data, groupBy), sortBy);\n\n  // handlers\n  const handleChange = (_e, group) => {\n    if (group) {\n      setGroupBy(group);\n    }\n  };\n\n  const handleSort = (sort) => {\n    setSortBy(sort);\n  };\n\n  return (\n    <>\n      <Grid className={classes.groupBy} container justifyContent=\"center\" alignItems=\"center\">\n        <Typography className={classes.groupByText} variant=\"body2\">\n          Group by\n        </Typography>\n        <ToggleButtonGroup size=\"small\" value={groupBy} exclusive onChange={handleChange}>\n          <ToggleButton value=\"organs\">Organs</ToggleButton>\n          <ToggleButton value=\"anatomicalSystems\">Anatomical Systems</ToggleButton>\n        </ToggleButtonGroup>\n      </Grid>\n      <Grid container justifyContent=\"center\">\n        <Table size=\"small\">\n          <TableHead>\n            <TableRow>\n              <TableCell className={classes.headerCell}>Tissue</TableCell>\n              <TableCell className={classes.headerCell} onClick={() => handleSort(\"rna\")}>\n                <TableSortLabel direction=\"desc\" active={sortBy === \"rna\"}>\n                  RNA (Expression Atlas)\n                </TableSortLabel>\n              </TableCell>\n              <TableCell className={classes.headerCell} onClick={() => handleSort(\"protein\")}>\n                <TableSortLabel direction=\"desc\" active={sortBy === \"protein\"}>\n                  Protein (HPA)\n                </TableSortLabel>\n              </TableCell>\n            </TableRow>\n            <TableRow>\n              <TableCell className={classes.highLow} />\n              <TableCell className={classNames(classes.highLow, classes.rnaCell)}>\n                <Grid container justifyContent=\"space-between\">\n                  <Grid item>High</Grid>\n                  <Grid item>Low</Grid>\n                </Grid>\n              </TableCell>\n              <TableCell className={classNames(classes.highLow, classes.proteinCell)}>\n                <Grid container justifyContent=\"space-between\">\n                  <Grid item>Low</Grid>\n                  <Grid item>High</Grid>\n                </Grid>\n              </TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {parents.map((parent) => (\n              <SummaryRow key={parent.parentLabel} maxRnaValue={maxRnaValue} parent={parent} />\n            ))}\n          </TableBody>\n        </Table>\n      </Grid>\n    </>\n  );\n}\n\nexport default SummaryTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/SummaryTable.jsx" },
        "span": [1042, 1709],
        "sourceCode": "import {\n  Grid,\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  ToggleButton,\n  ToggleButtonGroup,\n  Typography,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport classNames from \"classnames\";\nimport maxBy from \"lodash/maxBy\";\nimport { useState } from \"react\";\n\nimport SummaryRow from \"./SummaryRow\";\n\nconst getMaxRnaValue = (expressions) => {\n  if (expressions.length <= 0) return 0;\n  return maxBy(expressions, (expression) => (expression?.rna ? expression.rna.value : 0)).rna.value;\n};\n\n// function that transforms tissue data into an array of objects\n// where each object has the following shape and where tissues is\n// an array of tissues that belong to the parent category\n// {\n//   parentLabel: string\n//   tissues: []\n//   maxRnaValue: number\n//   maxRnaLevel: number\n//   maxProteinLevel: number\n// }\nconst groupTissues = (expressions, groupBy) => {\n  const groupedTissues = {};\n\n  expressions.forEach((expression) => {\n    const parentLabels = expression.tissue[groupBy];\n    parentLabels.forEach((label) => {\n      if (!groupedTissues[label]) {\n        groupedTissues[label] = {\n          parentLabel: label,\n          tissues: [],\n          maxRnaValue: Number.NEGATIVE_INFINITY,\n          maxRnaLevel: Number.NEGATIVE_INFINITY,\n          maxProteinLevel: Number.NEGATIVE_INFINITY,\n        };\n      }\n\n      const parent = groupedTissues[label];\n\n      parent.tissues.push(expression);\n      parent.maxRnaValue = Math.max(parent.maxRnaValue, expression.rna.value);\n      parent.maxRnaLevel = Math.max(parent.maxRnaLevel, expression.rna.level);\n      parent.maxProteinLevel = Math.max(parent.maxProteinLevel, expression.protein.level);\n    });\n  });\n\n  return Object.values(groupedTissues);\n};\n\nconst tissueComparator = (sortBy) => {\n  if (sortBy === \"rna\") {\n    return (a, b) => b.rna.value - a.rna.value;\n  }\n\n  return (a, b) => b.protein.level - a.protein.level;\n};\n\nconst parentComparator = (sortBy) => {\n  if (sortBy === \"rna\") {\n    return (a, b) => b.maxRnaValue - a.maxRnaValue;\n  }\n\n  return (a, b) => b.maxProteinLevel - a.maxProteinLevel;\n};\n\nconst sort = (parents, sortBy) => {\n  parents.forEach((parent) => {\n    parent.tissues.sort(tissueComparator(sortBy));\n  });\n  return parents.sort(parentComparator(sortBy));\n};\n\nconst useStyles = makeStyles({\n  groupBy: {\n    marginBottom: \"20px\",\n    marginTop: \"40px\",\n  },\n  groupByText: {\n    marginRight: \"7px !important\",\n  },\n  headerCell: {\n    textAlign: \"center !important\",\n  },\n  rnaCell: {\n    paddingRight: \"8px\",\n  },\n  proteinCell: {\n    paddingLeft: \"8px\",\n  },\n  highLow: {\n    border: \"none !important\",\n  },\n});\n\nfunction SummaryTable({ data }) {\n  const [groupBy, setGroupBy] = useState(\"organs\");\n  const [sortBy, setSortBy] = useState(\"rna\");\n\n  const classes = useStyles();\n  const maxRnaValue = getMaxRnaValue(data);\n  const parents = sort(groupTissues(data, groupBy), sortBy);\n\n  // handlers\n  const handleChange = (_e, group) => {\n    if (group) {\n      setGroupBy(group);\n    }\n  };\n\n  const handleSort = (sort) => {\n    setSortBy(sort);\n  };\n\n  return (\n    <>\n      <Grid className={classes.groupBy} container justifyContent=\"center\" alignItems=\"center\">\n        <Typography className={classes.groupByText} variant=\"body2\">\n          Group by\n        </Typography>\n        <ToggleButtonGroup size=\"small\" value={groupBy} exclusive onChange={handleChange}>\n          <ToggleButton value=\"organs\">Organs</ToggleButton>\n          <ToggleButton value=\"anatomicalSystems\">Anatomical Systems</ToggleButton>\n        </ToggleButtonGroup>\n      </Grid>\n      <Grid container justifyContent=\"center\">\n        <Table size=\"small\">\n          <TableHead>\n            <TableRow>\n              <TableCell className={classes.headerCell}>Tissue</TableCell>\n              <TableCell className={classes.headerCell} onClick={() => handleSort(\"rna\")}>\n                <TableSortLabel direction=\"desc\" active={sortBy === \"rna\"}>\n                  RNA (Expression Atlas)\n                </TableSortLabel>\n              </TableCell>\n              <TableCell className={classes.headerCell} onClick={() => handleSort(\"protein\")}>\n                <TableSortLabel direction=\"desc\" active={sortBy === \"protein\"}>\n                  Protein (HPA)\n                </TableSortLabel>\n              </TableCell>\n            </TableRow>\n            <TableRow>\n              <TableCell className={classes.highLow} />\n              <TableCell className={classNames(classes.highLow, classes.rnaCell)}>\n                <Grid container justifyContent=\"space-between\">\n                  <Grid item>High</Grid>\n                  <Grid item>Low</Grid>\n                </Grid>\n              </TableCell>\n              <TableCell className={classNames(classes.highLow, classes.proteinCell)}>\n                <Grid container justifyContent=\"space-between\">\n                  <Grid item>Low</Grid>\n                  <Grid item>High</Grid>\n                </Grid>\n              </TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {parents.map((parent) => (\n              <SummaryRow key={parent.parentLabel} maxRnaValue={maxRnaValue} parent={parent} />\n            ))}\n          </TableBody>\n        </Table>\n      </Grid>\n    </>\n  );\n}\n\nexport default SummaryTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/SummaryTable.jsx" },
        "span": [2160, 2245],
        "sourceCode": "import {\n  Grid,\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableRow,\n  TableSortLabel,\n  ToggleButton,\n  ToggleButtonGroup,\n  Typography,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport classNames from \"classnames\";\nimport maxBy from \"lodash/maxBy\";\nimport { useState } from \"react\";\n\nimport SummaryRow from \"./SummaryRow\";\n\nconst getMaxRnaValue = (expressions) => {\n  if (expressions.length <= 0) return 0;\n  return maxBy(expressions, (expression) => (expression?.rna ? expression.rna.value : 0)).rna.value;\n};\n\n// function that transforms tissue data into an array of objects\n// where each object has the following shape and where tissues is\n// an array of tissues that belong to the parent category\n// {\n//   parentLabel: string\n//   tissues: []\n//   maxRnaValue: number\n//   maxRnaLevel: number\n//   maxProteinLevel: number\n// }\nconst groupTissues = (expressions, groupBy) => {\n  const groupedTissues = {};\n\n  expressions.forEach((expression) => {\n    const parentLabels = expression.tissue[groupBy];\n    parentLabels.forEach((label) => {\n      if (!groupedTissues[label]) {\n        groupedTissues[label] = {\n          parentLabel: label,\n          tissues: [],\n          maxRnaValue: Number.NEGATIVE_INFINITY,\n          maxRnaLevel: Number.NEGATIVE_INFINITY,\n          maxProteinLevel: Number.NEGATIVE_INFINITY,\n        };\n      }\n\n      const parent = groupedTissues[label];\n\n      parent.tissues.push(expression);\n      parent.maxRnaValue = Math.max(parent.maxRnaValue, expression.rna.value);\n      parent.maxRnaLevel = Math.max(parent.maxRnaLevel, expression.rna.level);\n      parent.maxProteinLevel = Math.max(parent.maxProteinLevel, expression.protein.level);\n    });\n  });\n\n  return Object.values(groupedTissues);\n};\n\nconst tissueComparator = (sortBy) => {\n  if (sortBy === \"rna\") {\n    return (a, b) => b.rna.value - a.rna.value;\n  }\n\n  return (a, b) => b.protein.level - a.protein.level;\n};\n\nconst parentComparator = (sortBy) => {\n  if (sortBy === \"rna\") {\n    return (a, b) => b.maxRnaValue - a.maxRnaValue;\n  }\n\n  return (a, b) => b.maxProteinLevel - a.maxProteinLevel;\n};\n\nconst sort = (parents, sortBy) => {\n  parents.forEach((parent) => {\n    parent.tissues.sort(tissueComparator(sortBy));\n  });\n  return parents.sort(parentComparator(sortBy));\n};\n\nconst useStyles = makeStyles({\n  groupBy: {\n    marginBottom: \"20px\",\n    marginTop: \"40px\",\n  },\n  groupByText: {\n    marginRight: \"7px !important\",\n  },\n  headerCell: {\n    textAlign: \"center !important\",\n  },\n  rnaCell: {\n    paddingRight: \"8px\",\n  },\n  proteinCell: {\n    paddingLeft: \"8px\",\n  },\n  highLow: {\n    border: \"none !important\",\n  },\n});\n\nfunction SummaryTable({ data }) {\n  const [groupBy, setGroupBy] = useState(\"organs\");\n  const [sortBy, setSortBy] = useState(\"rna\");\n\n  const classes = useStyles();\n  const maxRnaValue = getMaxRnaValue(data);\n  const parents = sort(groupTissues(data, groupBy), sortBy);\n\n  // handlers\n  const handleChange = (_e, group) => {\n    if (group) {\n      setGroupBy(group);\n    }\n  };\n\n  const handleSort = (sort) => {\n    setSortBy(sort);\n  };\n\n  return (\n    <>\n      <Grid className={classes.groupBy} container justifyContent=\"center\" alignItems=\"center\">\n        <Typography className={classes.groupByText} variant=\"body2\">\n          Group by\n        </Typography>\n        <ToggleButtonGroup size=\"small\" value={groupBy} exclusive onChange={handleChange}>\n          <ToggleButton value=\"organs\">Organs</ToggleButton>\n          <ToggleButton value=\"anatomicalSystems\">Anatomical Systems</ToggleButton>\n        </ToggleButtonGroup>\n      </Grid>\n      <Grid container justifyContent=\"center\">\n        <Table size=\"small\">\n          <TableHead>\n            <TableRow>\n              <TableCell className={classes.headerCell}>Tissue</TableCell>\n              <TableCell className={classes.headerCell} onClick={() => handleSort(\"rna\")}>\n                <TableSortLabel direction=\"desc\" active={sortBy === \"rna\"}>\n                  RNA (Expression Atlas)\n                </TableSortLabel>\n              </TableCell>\n              <TableCell className={classes.headerCell} onClick={() => handleSort(\"protein\")}>\n                <TableSortLabel direction=\"desc\" active={sortBy === \"protein\"}>\n                  Protein (HPA)\n                </TableSortLabel>\n              </TableCell>\n            </TableRow>\n            <TableRow>\n              <TableCell className={classes.highLow} />\n              <TableCell className={classNames(classes.highLow, classes.rnaCell)}>\n                <Grid container justifyContent=\"space-between\">\n                  <Grid item>High</Grid>\n                  <Grid item>Low</Grid>\n                </Grid>\n              </TableCell>\n              <TableCell className={classNames(classes.highLow, classes.proteinCell)}>\n                <Grid container justifyContent=\"space-between\">\n                  <Grid item>Low</Grid>\n                  <Grid item>High</Grid>\n                </Grid>\n              </TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {parents.map((parent) => (\n              <SummaryRow key={parent.parentLabel} maxRnaValue={maxRnaValue} parent={parent} />\n            ))}\n          </TableBody>\n        </Table>\n      </Grid>\n    </>\n  );\n}\n\nexport default SummaryTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: europePmcId",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: europePmcId"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Outer scope values aren't valid dependencies because mutating them doesn't re-render the component."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1696, 1707],
              "sourceCode": "import { faFileAlt, faMinusCircle, faPlusCircle } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport Link from \"../Link\";\nimport LongText from \"../LongText\";\n\nimport { useConfigContext } from \"../../providers/ConfigurationProvider\";\nimport PublicationSummary from \"./PublicationSummary\";\n\nconst pmUrl = \"https://europepmc.org/\";\nconst pmTitleUrlMED = \"abstract/med/\";\nconst pmTitleUrlPAT = \"abstract/pat/\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    margin: \"1rem !important\",\n    marginLeft: \"0 !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    padding: \"20px\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  fileLabel: {\n    color: \"#5a5f5f\",\n    fontSize: \"0.875rem\",\n    fontFamily: '\"Inter\", \"sans-serif\"',\n    fontWeight: \"500\",\n  },\n}));\n\nfunction PublicationWrapper({\n  europePmcId,\n  title,\n  titleHtml,\n  authors,\n  journal,\n  variant = \"regular\",\n  abstract,\n  fullTextOpen = false,\n  source = \"MED\",\n  patentDetails,\n  symbol = null,\n  name = null,\n  pmcId = null,\n  isOpenAccess = false,\n  inPMC = false,\n}) {\n  const [showAbstract, setShowAbstract] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract(!showAbstract);\n  };\n\n  useEffect(() => {\n    setShowAbstract(false);\n  }, [europePmcId]);\n\n  const classes = useStyles();\n\n  const isSourcePAT = source === \"PAT\";\n  const sourceScope = isSourcePAT ? pmTitleUrlPAT : pmTitleUrlMED;\n  const externalURL = pmUrl + sourceScope + europePmcId;\n\n  return (\n    <Box mb={2}>\n      {/* paper title */}\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <Typography variant={variant === \"small\" ? \"subtitle2\" : \"subtitle1\"}>\n          <Link external to={externalURL}>\n            {titleHtml ? (\n              <span\n                dangerouslySetInnerHTML={{ __html: titleHtml }}\n                style={{ whiteSpace: \"normal\" }}\n              />\n            ) : (\n              title\n            )}\n          </Link>\n        </Typography>\n      </Box>\n\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <LongText lineLimit={1} variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n          {authors\n            .reduce((acc, author) => {\n              if (author.lastName)\n                acc.push(author.lastName + (author.initials ? ` ${author.initials}` : \"\"));\n              return acc;\n            }, [])\n            .join(\", \")}\n        </LongText>\n      </Box>\n\n      {isSourcePAT ? (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {patentDetails.typeDescription}\n            {\" - \"}\n            <span>{patentDetails.country}</span>\n          </Typography>\n        </Box>\n      ) : (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {/* journal, year, reference */}\n            {journal.journal?.title || \"\"}{\" \"}\n            <span>\n              <b>\n                {journal.dateOfPublication && (journal.dateOfPublication.substring(0, 4) || \"\")}\n              </b>\n            </span>{\" \"}\n            <span>{journal.volume || \"\"}</span>\n            <span>{journal.issue && `(${journal.issue})`}</span>\n            <span>{journal.page && `:${journal.page}`}</span>\n          </Typography>\n        </Box>\n      )}\n\n      <Box style={{ display: \"flex\", alignItems: \"center\" }}>\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          disabled={!abstract}\n          onClick={handleShowAbstractClick}\n          startIcon={\n            showAbstract ? (\n              <FontAwesomeIcon icon={faMinusCircle} size=\"sm\" />\n            ) : (\n              <FontAwesomeIcon icon={faPlusCircle} size=\"sm\" />\n            )\n          }\n        >\n          {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n        </Button>\n        {fullTextOpen && (\n          <span className={classes.fileLabel}>\n            <FontAwesomeIcon icon={faFileAlt} style={{ marginRight: \"8px\" }} size=\"lg\" />\n            {isOpenAccess ? \"Full text free to use/read\" : \"Full text free to read\"}\n          </span>\n        )}\n      </Box>\n\n      {showAbstract && (\n        <Box className={classes.detailPanel}>\n          <Typography variant=\"subtitle2\">Abstract</Typography>\n          <span className={classes.abstractSpan} dangerouslySetInnerHTML={{ __html: abstract }} />\n        </Box>\n      )}\n\n      {symbol && name && fullTextOpen && isOpenAccess && urlAiApi && (\n        <PublicationSummary name={name} symbol={symbol} pmcId={pmcId} />\n      )}\n    </Box>\n  );\n}\n\nexport default PublicationWrapper;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationWrapper.jsx"
        },
        "span": [1644, 1653],
        "sourceCode": "import { faFileAlt, faMinusCircle, faPlusCircle } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport Link from \"../Link\";\nimport LongText from \"../LongText\";\n\nimport { useConfigContext } from \"../../providers/ConfigurationProvider\";\nimport PublicationSummary from \"./PublicationSummary\";\n\nconst pmUrl = \"https://europepmc.org/\";\nconst pmTitleUrlMED = \"abstract/med/\";\nconst pmTitleUrlPAT = \"abstract/pat/\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    margin: \"1rem !important\",\n    marginLeft: \"0 !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    padding: \"20px\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  fileLabel: {\n    color: \"#5a5f5f\",\n    fontSize: \"0.875rem\",\n    fontFamily: '\"Inter\", \"sans-serif\"',\n    fontWeight: \"500\",\n  },\n}));\n\nfunction PublicationWrapper({\n  europePmcId,\n  title,\n  titleHtml,\n  authors,\n  journal,\n  variant = \"regular\",\n  abstract,\n  fullTextOpen = false,\n  source = \"MED\",\n  patentDetails,\n  symbol = null,\n  name = null,\n  pmcId = null,\n  isOpenAccess = false,\n  inPMC = false,\n}) {\n  const [showAbstract, setShowAbstract] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract(!showAbstract);\n  };\n\n  useEffect(() => {\n    setShowAbstract(false);\n  }, [europePmcId]);\n\n  const classes = useStyles();\n\n  const isSourcePAT = source === \"PAT\";\n  const sourceScope = isSourcePAT ? pmTitleUrlPAT : pmTitleUrlMED;\n  const externalURL = pmUrl + sourceScope + europePmcId;\n\n  return (\n    <Box mb={2}>\n      {/* paper title */}\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <Typography variant={variant === \"small\" ? \"subtitle2\" : \"subtitle1\"}>\n          <Link external to={externalURL}>\n            {titleHtml ? (\n              <span\n                dangerouslySetInnerHTML={{ __html: titleHtml }}\n                style={{ whiteSpace: \"normal\" }}\n              />\n            ) : (\n              title\n            )}\n          </Link>\n        </Typography>\n      </Box>\n\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <LongText lineLimit={1} variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n          {authors\n            .reduce((acc, author) => {\n              if (author.lastName)\n                acc.push(author.lastName + (author.initials ? ` ${author.initials}` : \"\"));\n              return acc;\n            }, [])\n            .join(\", \")}\n        </LongText>\n      </Box>\n\n      {isSourcePAT ? (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {patentDetails.typeDescription}\n            {\" - \"}\n            <span>{patentDetails.country}</span>\n          </Typography>\n        </Box>\n      ) : (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {/* journal, year, reference */}\n            {journal.journal?.title || \"\"}{\" \"}\n            <span>\n              <b>\n                {journal.dateOfPublication && (journal.dateOfPublication.substring(0, 4) || \"\")}\n              </b>\n            </span>{\" \"}\n            <span>{journal.volume || \"\"}</span>\n            <span>{journal.issue && `(${journal.issue})`}</span>\n            <span>{journal.page && `:${journal.page}`}</span>\n          </Typography>\n        </Box>\n      )}\n\n      <Box style={{ display: \"flex\", alignItems: \"center\" }}>\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          disabled={!abstract}\n          onClick={handleShowAbstractClick}\n          startIcon={\n            showAbstract ? (\n              <FontAwesomeIcon icon={faMinusCircle} size=\"sm\" />\n            ) : (\n              <FontAwesomeIcon icon={faPlusCircle} size=\"sm\" />\n            )\n          }\n        >\n          {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n        </Button>\n        {fullTextOpen && (\n          <span className={classes.fileLabel}>\n            <FontAwesomeIcon icon={faFileAlt} style={{ marginRight: \"8px\" }} size=\"lg\" />\n            {isOpenAccess ? \"Full text free to use/read\" : \"Full text free to read\"}\n          </span>\n        )}\n      </Box>\n\n      {showAbstract && (\n        <Box className={classes.detailPanel}>\n          <Typography variant=\"subtitle2\">Abstract</Typography>\n          <span className={classes.abstractSpan} dangerouslySetInnerHTML={{ __html: abstract }} />\n        </Box>\n      )}\n\n      {symbol && name && fullTextOpen && isOpenAccess && urlAiApi && (\n        <PublicationSummary name={name} symbol={symbol} pmcId={pmcId} />\n      )}\n    </Box>\n  );\n}\n\nexport default PublicationWrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/security/noDangerouslySetInnerHtml",
      "severity": "error",
      "description": "Avoid passing content using the dangerouslySetInnerHTML prop.",
      "message": [
        { "elements": [], "content": "Avoid passing content using the " },
        { "elements": ["Emphasis"], "content": "dangerouslySetInnerHTML" },
        { "elements": [], "content": " prop." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "warn",
              [
                {
                  "elements": [],
                  "content": "Setting content using code can expose users to cross-site scripting (XSS) attacks"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationWrapper.jsx"
        },
        "span": [2193, 2216],
        "sourceCode": "import { faFileAlt, faMinusCircle, faPlusCircle } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport Link from \"../Link\";\nimport LongText from \"../LongText\";\n\nimport { useConfigContext } from \"../../providers/ConfigurationProvider\";\nimport PublicationSummary from \"./PublicationSummary\";\n\nconst pmUrl = \"https://europepmc.org/\";\nconst pmTitleUrlMED = \"abstract/med/\";\nconst pmTitleUrlPAT = \"abstract/pat/\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    margin: \"1rem !important\",\n    marginLeft: \"0 !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    padding: \"20px\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  fileLabel: {\n    color: \"#5a5f5f\",\n    fontSize: \"0.875rem\",\n    fontFamily: '\"Inter\", \"sans-serif\"',\n    fontWeight: \"500\",\n  },\n}));\n\nfunction PublicationWrapper({\n  europePmcId,\n  title,\n  titleHtml,\n  authors,\n  journal,\n  variant = \"regular\",\n  abstract,\n  fullTextOpen = false,\n  source = \"MED\",\n  patentDetails,\n  symbol = null,\n  name = null,\n  pmcId = null,\n  isOpenAccess = false,\n  inPMC = false,\n}) {\n  const [showAbstract, setShowAbstract] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract(!showAbstract);\n  };\n\n  useEffect(() => {\n    setShowAbstract(false);\n  }, [europePmcId]);\n\n  const classes = useStyles();\n\n  const isSourcePAT = source === \"PAT\";\n  const sourceScope = isSourcePAT ? pmTitleUrlPAT : pmTitleUrlMED;\n  const externalURL = pmUrl + sourceScope + europePmcId;\n\n  return (\n    <Box mb={2}>\n      {/* paper title */}\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <Typography variant={variant === \"small\" ? \"subtitle2\" : \"subtitle1\"}>\n          <Link external to={externalURL}>\n            {titleHtml ? (\n              <span\n                dangerouslySetInnerHTML={{ __html: titleHtml }}\n                style={{ whiteSpace: \"normal\" }}\n              />\n            ) : (\n              title\n            )}\n          </Link>\n        </Typography>\n      </Box>\n\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <LongText lineLimit={1} variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n          {authors\n            .reduce((acc, author) => {\n              if (author.lastName)\n                acc.push(author.lastName + (author.initials ? ` ${author.initials}` : \"\"));\n              return acc;\n            }, [])\n            .join(\", \")}\n        </LongText>\n      </Box>\n\n      {isSourcePAT ? (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {patentDetails.typeDescription}\n            {\" - \"}\n            <span>{patentDetails.country}</span>\n          </Typography>\n        </Box>\n      ) : (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {/* journal, year, reference */}\n            {journal.journal?.title || \"\"}{\" \"}\n            <span>\n              <b>\n                {journal.dateOfPublication && (journal.dateOfPublication.substring(0, 4) || \"\")}\n              </b>\n            </span>{\" \"}\n            <span>{journal.volume || \"\"}</span>\n            <span>{journal.issue && `(${journal.issue})`}</span>\n            <span>{journal.page && `:${journal.page}`}</span>\n          </Typography>\n        </Box>\n      )}\n\n      <Box style={{ display: \"flex\", alignItems: \"center\" }}>\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          disabled={!abstract}\n          onClick={handleShowAbstractClick}\n          startIcon={\n            showAbstract ? (\n              <FontAwesomeIcon icon={faMinusCircle} size=\"sm\" />\n            ) : (\n              <FontAwesomeIcon icon={faPlusCircle} size=\"sm\" />\n            )\n          }\n        >\n          {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n        </Button>\n        {fullTextOpen && (\n          <span className={classes.fileLabel}>\n            <FontAwesomeIcon icon={faFileAlt} style={{ marginRight: \"8px\" }} size=\"lg\" />\n            {isOpenAccess ? \"Full text free to use/read\" : \"Full text free to read\"}\n          </span>\n        )}\n      </Box>\n\n      {showAbstract && (\n        <Box className={classes.detailPanel}>\n          <Typography variant=\"subtitle2\">Abstract</Typography>\n          <span className={classes.abstractSpan} dangerouslySetInnerHTML={{ __html: abstract }} />\n        </Box>\n      )}\n\n      {symbol && name && fullTextOpen && isOpenAccess && urlAiApi && (\n        <PublicationSummary name={name} symbol={symbol} pmcId={pmcId} />\n      )}\n    </Box>\n  );\n}\n\nexport default PublicationWrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/security/noDangerouslySetInnerHtml",
      "severity": "error",
      "description": "Avoid passing content using the dangerouslySetInnerHTML prop.",
      "message": [
        { "elements": [], "content": "Avoid passing content using the " },
        { "elements": ["Emphasis"], "content": "dangerouslySetInnerHTML" },
        { "elements": [], "content": " prop." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "warn",
              [
                {
                  "elements": [],
                  "content": "Setting content using code can expose users to cross-site scripting (XSS) attacks"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationWrapper.jsx"
        },
        "span": [4797, 4820],
        "sourceCode": "import { faFileAlt, faMinusCircle, faPlusCircle } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport Link from \"../Link\";\nimport LongText from \"../LongText\";\n\nimport { useConfigContext } from \"../../providers/ConfigurationProvider\";\nimport PublicationSummary from \"./PublicationSummary\";\n\nconst pmUrl = \"https://europepmc.org/\";\nconst pmTitleUrlMED = \"abstract/med/\";\nconst pmTitleUrlPAT = \"abstract/pat/\";\n\nconst useStyles = makeStyles((theme) => ({\n  abstractSpan: {\n    whiteSpace: \"normal\",\n  },\n  detailsButton: {\n    margin: \"1rem !important\",\n    marginLeft: \"0 !important\",\n    color: \"#5a5f5f !important\",\n    borderColor: \"#c4c4c4 !important\",\n  },\n  detailPanel: {\n    background: `${theme.palette.grey[100]}`,\n    marginTop: \"10px\",\n    padding: \"20px\",\n  },\n  matchTable: {\n    width: \"100%\",\n  },\n  fileLabel: {\n    color: \"#5a5f5f\",\n    fontSize: \"0.875rem\",\n    fontFamily: '\"Inter\", \"sans-serif\"',\n    fontWeight: \"500\",\n  },\n}));\n\nfunction PublicationWrapper({\n  europePmcId,\n  title,\n  titleHtml,\n  authors,\n  journal,\n  variant = \"regular\",\n  abstract,\n  fullTextOpen = false,\n  source = \"MED\",\n  patentDetails,\n  symbol = null,\n  name = null,\n  pmcId = null,\n  isOpenAccess = false,\n  inPMC = false,\n}) {\n  const [showAbstract, setShowAbstract] = useState(false);\n\n  const {\n    config: { urlAiApi },\n  } = useConfigContext();\n\n  const handleShowAbstractClick = () => {\n    setShowAbstract(!showAbstract);\n  };\n\n  useEffect(() => {\n    setShowAbstract(false);\n  }, [europePmcId]);\n\n  const classes = useStyles();\n\n  const isSourcePAT = source === \"PAT\";\n  const sourceScope = isSourcePAT ? pmTitleUrlPAT : pmTitleUrlMED;\n  const externalURL = pmUrl + sourceScope + europePmcId;\n\n  return (\n    <Box mb={2}>\n      {/* paper title */}\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <Typography variant={variant === \"small\" ? \"subtitle2\" : \"subtitle1\"}>\n          <Link external to={externalURL}>\n            {titleHtml ? (\n              <span\n                dangerouslySetInnerHTML={{ __html: titleHtml }}\n                style={{ whiteSpace: \"normal\" }}\n              />\n            ) : (\n              title\n            )}\n          </Link>\n        </Typography>\n      </Box>\n\n      <Box style={{ whiteSpace: \"normal\" }}>\n        <LongText lineLimit={1} variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n          {authors\n            .reduce((acc, author) => {\n              if (author.lastName)\n                acc.push(author.lastName + (author.initials ? ` ${author.initials}` : \"\"));\n              return acc;\n            }, [])\n            .join(\", \")}\n        </LongText>\n      </Box>\n\n      {isSourcePAT ? (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {patentDetails.typeDescription}\n            {\" - \"}\n            <span>{patentDetails.country}</span>\n          </Typography>\n        </Box>\n      ) : (\n        <Box style={{ whiteSpace: \"normal\" }}>\n          <Typography variant={variant === \"small\" ? \"caption\" : \"body2\"}>\n            {/* journal, year, reference */}\n            {journal.journal?.title || \"\"}{\" \"}\n            <span>\n              <b>\n                {journal.dateOfPublication && (journal.dateOfPublication.substring(0, 4) || \"\")}\n              </b>\n            </span>{\" \"}\n            <span>{journal.volume || \"\"}</span>\n            <span>{journal.issue && `(${journal.issue})`}</span>\n            <span>{journal.page && `:${journal.page}`}</span>\n          </Typography>\n        </Box>\n      )}\n\n      <Box style={{ display: \"flex\", alignItems: \"center\" }}>\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          disabled={!abstract}\n          onClick={handleShowAbstractClick}\n          startIcon={\n            showAbstract ? (\n              <FontAwesomeIcon icon={faMinusCircle} size=\"sm\" />\n            ) : (\n              <FontAwesomeIcon icon={faPlusCircle} size=\"sm\" />\n            )\n          }\n        >\n          {showAbstract ? \"Hide abstract\" : \"Show abstract\"}\n        </Button>\n        {fullTextOpen && (\n          <span className={classes.fileLabel}>\n            <FontAwesomeIcon icon={faFileAlt} style={{ marginRight: \"8px\" }} size=\"lg\" />\n            {isOpenAccess ? \"Full text free to use/read\" : \"Full text free to read\"}\n          </span>\n        )}\n      </Box>\n\n      {showAbstract && (\n        <Box className={classes.detailPanel}>\n          <Typography variant=\"subtitle2\">Abstract</Typography>\n          <span className={classes.abstractSpan} dangerouslySetInnerHTML={{ __html: abstract }} />\n        </Box>\n      )}\n\n      {symbol && name && fullTextOpen && isOpenAccess && urlAiApi && (\n        <PublicationSummary name={name} symbol={symbol} pmcId={pmcId} />\n      )}\n    </Box>\n  );\n}\n\nexport default PublicationWrapper;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/GtexVariability.jsx" },
        "span": [675, 805],
        "sourceCode": "import { useTheme } from \"@mui/styles\";\nimport {\n  axisLeft,\n  axisTop,\n  max,\n  scaleLinear,\n  scaleOrdinal,\n  scalePoint,\n  schemeCategory10,\n  select,\n} from \"d3\";\nimport { forwardRef, useEffect, useRef } from \"react\";\n\nconst width = 900;\nconst boxHeight = 20;\nconst boxPadding = boxHeight / 4;\nconst margin = { top: 40, right: 20, bottom: 20, left: 220 };\nconst outlierRadius = 2;\n\nfunction getTextWidth(text, fontSize, fontFace) {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context.font = `${fontSize}px ${fontFace}`;\n  return context.measureText(text).width;\n}\n\nfunction getLongestId(data) {\n  let longestId = \"\";\n  data.forEach((d) => {\n    if (d.tissueSiteDetailId.length > longestId.length) {\n      longestId = d.tissueSiteDetailId;\n    }\n  });\n  return longestId;\n}\n\nfunction buildTooltip(X, tooltipObject, data) {\n  return Object.keys(tooltipObject)\n    .map((field) => {\n      const value =\n        data[field] === null ? \"N/A\" : data[field].toFixed(tooltipObject[field].roundDigits);\n      return (\n        `<tspan x='${X}' dy='1.2em' style=\"font-weight: bold;\">` +\n        `${tooltipObject[field].label}: </tspan>` +\n        `<tspan>${value}</tspan>`\n      );\n    })\n    .join(\"\");\n}\n\nconst GtexVariability = forwardRef(function GtexVariability({ data }, ref) {\n  const theme = useTheme();\n  const boxPlotRef = useRef();\n  const tooltipRef = useRef();\n  const xAxisRef = useRef();\n  const yAxisRef = useRef();\n\n  const x = scaleLinear();\n  const y = scalePoint().padding(0.5);\n  const colour = scaleOrdinal();\n\n  margin.left = getTextWidth(getLongestId(data), 12, \"Arial\");\n\n  const height = data.length * boxHeight + margin.top + margin.bottom;\n\n  useEffect(() => {\n    d3Render(data);\n  });\n\n  function d3Render(propsData) {\n    const data = propsData.slice().sort((a, b) => b.median - a.median);\n    const height = data.length * boxHeight + margin.top + margin.bottom;\n    const rectHeight = boxHeight - 2 * boxPadding;\n    const xMax = max(data, (d) => max(d.outliers));\n\n    x.domain([0, xMax]).range([0, width - margin.left - margin.right]);\n    y.domain(data.map((d) => d.tissueSiteDetailId.replace(/_/g, \" \"))).range([\n      0,\n      height - margin.top - margin.bottom,\n    ]);\n\n    colour.domain(data.map((d) => d.tissueSiteDetailId)).range(schemeCategory10);\n\n    const tooltipTextFields = {\n      lowerLimit: {\n        label: \"lower limit\",\n        roundDigits: 1,\n      },\n      q1: {\n        label: \"q1\",\n        roundDigits: 1,\n      },\n      median: {\n        label: \"median\",\n        roundDigits: 1,\n      },\n      q3: {\n        label: \"q3\",\n        roundDigits: 1,\n      },\n      upperLimit: {\n        label: \"upper limit\",\n        roundDigits: 1,\n      },\n    };\n\n    const tooltipSettings = {\n      fontSize: 12,\n      fontFamily: \"sans-serif\",\n      offsetText: 5,\n      offsetX: 10,\n      offsetY: boxHeight / 2 + 5,\n    };\n\n    const tooltip = select(tooltipRef.current);\n\n    const tooltipRect = tooltip\n      .append(\"rect\")\n      .style(\"fill\", \"white\")\n      .style(\"opacity\", 0.8)\n      .style(\"visibility\", \"hidden\");\n\n    const tooltipText = tooltip\n      .append(\"text\")\n      .style(\"font-family\", tooltipSettings.fontFamily)\n      .style(\"font-size\", `${tooltipSettings.fontSize}px`)\n      .style(\"visibility\", \"hidden\");\n\n    const boxPlot = select(boxPlotRef.current);\n    const boxContainer = boxPlot.selectAll(\"g\").data(data).join(\"g\");\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.lowerLimit))\n      .attr(\"x2\", (d) => x(d.upperLimit))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")))\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")))\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    boxContainer\n      .append(\"rect\")\n      .attr(\"x\", (d) => x(d.q1))\n      .attr(\"y\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"width\", (d) => x(d.q3) - x(d.q1))\n      .attr(\"height\", rectHeight)\n      .attr(\"fill\", (d) => colour(d.tissueSiteDetailId))\n      .on(\"mouseover\", (d, i, nodes) => {\n        let X =\n          Number.parseFloat(select(nodes[i]).attr(\"x\")) +\n          Number.parseFloat(select(nodes[i]).attr(\"width\")) +\n          tooltipSettings.offsetX;\n        let Y = Number.parseFloat(select(nodes[i]).attr(\"y\")) + tooltipSettings.offsetY;\n\n        tooltipText\n          .attr(\"y\", Y)\n          .html(buildTooltip(X + tooltipSettings.offsetText, tooltipTextFields, d))\n          .style(\"visibility\", \"visible\");\n\n        const bbox = tooltip.select(\"text\").node().getBBox();\n\n        // keep tooltip box within SVG (X axis)\n        if (margin.left + X + bbox.width + margin.right > width) {\n          X = width - margin.right - bbox.width - margin.left;\n          // re-build tooltip string; this is necessary because the X coordinate\n          // is part of the tooltip string\n          tooltipText.html(buildTooltip(X + tooltipSettings.offsetText, tooltipTextFields, d));\n        }\n\n        // keep tooltip box within SVG (Y axis)\n        if (margin.top + Y + bbox.height + margin.bottom > height) {\n          Y = height - margin.top - bbox.height - margin.bottom;\n          tooltipText.attr(\"y\", Y);\n        }\n\n        tooltipRect\n          .attr(\"x\", X)\n          .attr(\"y\", Y)\n          .attr(\"width\", bbox.width + 10)\n          .attr(\"height\", bbox.height + 10)\n          .style(\"visibility\", \"visible\");\n      })\n      .on(\"mouseout\", () => {\n        tooltipRect.style(\"visibility\", \"hidden\");\n        tooltipText.style(\"visibility\", \"hidden\");\n      });\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.median))\n      .attr(\"x2\", (d) => x(d.median))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) + rectHeight / 2)\n      .attr(\"stroke\", theme.palette.grey[700])\n      .attr(\"stroke-width\", 2);\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.lowerLimit))\n      .attr(\"x2\", (d) => x(d.lowerLimit))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) + rectHeight / 2)\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.upperLimit))\n      .attr(\"x2\", (d) => x(d.upperLimit))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) + rectHeight / 2)\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    boxContainer\n      .selectAll(\"circle\")\n      .data((d) =>\n        d.outliers.map((outlier) => ({\n          tissueSiteDetailId: d.tissueSiteDetailId,\n          outlier,\n        }))\n      )\n      .join(\"circle\")\n      .attr(\"r\", outlierRadius)\n      .attr(\"cx\", (d) => x(d.outlier))\n      .attr(\"cy\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")))\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    const xAxis = axisTop(x);\n    const yAxis = axisLeft(y);\n\n    const customAxis = (g, axis) => {\n      g.call(axis);\n      g.select(\".domain\").attr(\"stroke\", theme.palette.grey[700]);\n      g.selectAll(\".tick line\").attr(\"stroke\", theme.palette.grey[700]);\n      g.selectAll(\".tick text\").attr(\"fill\", theme.palette.grey[700]);\n    };\n\n    select(xAxisRef.current).call(customAxis, xAxis);\n    select(yAxisRef.current).call(customAxis, yAxis);\n  }\n\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" height={height} width={width} ref={ref}>\n      <text x={margin.left} y=\"15\" fill={theme.palette.grey[700]} fontSize=\"14\">\n        Normalised expression (RPKM)\n      </text>\n      <g\n        className=\"boxplot\"\n        ref={boxPlotRef}\n        transform={`translate(${margin.left}, ${margin.top})`}\n      />\n      <g ref={xAxisRef} transform={`translate(${margin.left}, ${margin.top})`} />\n      <g ref={yAxisRef} transform={`translate(${margin.left}, ${margin.top})`} />\n      <g ref={tooltipRef} transform={`translate(${margin.left}, ${margin.top})`} />\n    </svg>\n  );\n});\n\nexport default GtexVariability;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noSvgWithoutTitle",
      "severity": "error",
      "description": "Alternative text title element cannot be empty",
      "message": [
        { "elements": [], "content": "Alternative text " },
        { "elements": ["Emphasis"], "content": "title" },
        { "elements": [], "content": " element cannot be empty" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For accessibility purposes, " },
                { "elements": ["Emphasis"], "content": "SVGs" },
                { "elements": [], "content": " should have an alternative text, provided via " },
                { "elements": ["Emphasis"], "content": "title" },
                {
                  "elements": [],
                  "content": " element. If the svg element has role=\"img\", you should add the "
                },
                { "elements": ["Emphasis"], "content": "aria-label" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "aria-labelledby" },
                { "elements": [], "content": " attribute." }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Expression/GtexVariability.jsx" },
        "span": [7526, 7606],
        "sourceCode": "import { useTheme } from \"@mui/styles\";\nimport {\n  axisLeft,\n  axisTop,\n  max,\n  scaleLinear,\n  scaleOrdinal,\n  scalePoint,\n  schemeCategory10,\n  select,\n} from \"d3\";\nimport { forwardRef, useEffect, useRef } from \"react\";\n\nconst width = 900;\nconst boxHeight = 20;\nconst boxPadding = boxHeight / 4;\nconst margin = { top: 40, right: 20, bottom: 20, left: 220 };\nconst outlierRadius = 2;\n\nfunction getTextWidth(text, fontSize, fontFace) {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  context.font = `${fontSize}px ${fontFace}`;\n  return context.measureText(text).width;\n}\n\nfunction getLongestId(data) {\n  let longestId = \"\";\n  data.forEach((d) => {\n    if (d.tissueSiteDetailId.length > longestId.length) {\n      longestId = d.tissueSiteDetailId;\n    }\n  });\n  return longestId;\n}\n\nfunction buildTooltip(X, tooltipObject, data) {\n  return Object.keys(tooltipObject)\n    .map((field) => {\n      const value =\n        data[field] === null ? \"N/A\" : data[field].toFixed(tooltipObject[field].roundDigits);\n      return (\n        `<tspan x='${X}' dy='1.2em' style=\"font-weight: bold;\">` +\n        `${tooltipObject[field].label}: </tspan>` +\n        `<tspan>${value}</tspan>`\n      );\n    })\n    .join(\"\");\n}\n\nconst GtexVariability = forwardRef(function GtexVariability({ data }, ref) {\n  const theme = useTheme();\n  const boxPlotRef = useRef();\n  const tooltipRef = useRef();\n  const xAxisRef = useRef();\n  const yAxisRef = useRef();\n\n  const x = scaleLinear();\n  const y = scalePoint().padding(0.5);\n  const colour = scaleOrdinal();\n\n  margin.left = getTextWidth(getLongestId(data), 12, \"Arial\");\n\n  const height = data.length * boxHeight + margin.top + margin.bottom;\n\n  useEffect(() => {\n    d3Render(data);\n  });\n\n  function d3Render(propsData) {\n    const data = propsData.slice().sort((a, b) => b.median - a.median);\n    const height = data.length * boxHeight + margin.top + margin.bottom;\n    const rectHeight = boxHeight - 2 * boxPadding;\n    const xMax = max(data, (d) => max(d.outliers));\n\n    x.domain([0, xMax]).range([0, width - margin.left - margin.right]);\n    y.domain(data.map((d) => d.tissueSiteDetailId.replace(/_/g, \" \"))).range([\n      0,\n      height - margin.top - margin.bottom,\n    ]);\n\n    colour.domain(data.map((d) => d.tissueSiteDetailId)).range(schemeCategory10);\n\n    const tooltipTextFields = {\n      lowerLimit: {\n        label: \"lower limit\",\n        roundDigits: 1,\n      },\n      q1: {\n        label: \"q1\",\n        roundDigits: 1,\n      },\n      median: {\n        label: \"median\",\n        roundDigits: 1,\n      },\n      q3: {\n        label: \"q3\",\n        roundDigits: 1,\n      },\n      upperLimit: {\n        label: \"upper limit\",\n        roundDigits: 1,\n      },\n    };\n\n    const tooltipSettings = {\n      fontSize: 12,\n      fontFamily: \"sans-serif\",\n      offsetText: 5,\n      offsetX: 10,\n      offsetY: boxHeight / 2 + 5,\n    };\n\n    const tooltip = select(tooltipRef.current);\n\n    const tooltipRect = tooltip\n      .append(\"rect\")\n      .style(\"fill\", \"white\")\n      .style(\"opacity\", 0.8)\n      .style(\"visibility\", \"hidden\");\n\n    const tooltipText = tooltip\n      .append(\"text\")\n      .style(\"font-family\", tooltipSettings.fontFamily)\n      .style(\"font-size\", `${tooltipSettings.fontSize}px`)\n      .style(\"visibility\", \"hidden\");\n\n    const boxPlot = select(boxPlotRef.current);\n    const boxContainer = boxPlot.selectAll(\"g\").data(data).join(\"g\");\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.lowerLimit))\n      .attr(\"x2\", (d) => x(d.upperLimit))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")))\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")))\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    boxContainer\n      .append(\"rect\")\n      .attr(\"x\", (d) => x(d.q1))\n      .attr(\"y\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"width\", (d) => x(d.q3) - x(d.q1))\n      .attr(\"height\", rectHeight)\n      .attr(\"fill\", (d) => colour(d.tissueSiteDetailId))\n      .on(\"mouseover\", (d, i, nodes) => {\n        let X =\n          Number.parseFloat(select(nodes[i]).attr(\"x\")) +\n          Number.parseFloat(select(nodes[i]).attr(\"width\")) +\n          tooltipSettings.offsetX;\n        let Y = Number.parseFloat(select(nodes[i]).attr(\"y\")) + tooltipSettings.offsetY;\n\n        tooltipText\n          .attr(\"y\", Y)\n          .html(buildTooltip(X + tooltipSettings.offsetText, tooltipTextFields, d))\n          .style(\"visibility\", \"visible\");\n\n        const bbox = tooltip.select(\"text\").node().getBBox();\n\n        // keep tooltip box within SVG (X axis)\n        if (margin.left + X + bbox.width + margin.right > width) {\n          X = width - margin.right - bbox.width - margin.left;\n          // re-build tooltip string; this is necessary because the X coordinate\n          // is part of the tooltip string\n          tooltipText.html(buildTooltip(X + tooltipSettings.offsetText, tooltipTextFields, d));\n        }\n\n        // keep tooltip box within SVG (Y axis)\n        if (margin.top + Y + bbox.height + margin.bottom > height) {\n          Y = height - margin.top - bbox.height - margin.bottom;\n          tooltipText.attr(\"y\", Y);\n        }\n\n        tooltipRect\n          .attr(\"x\", X)\n          .attr(\"y\", Y)\n          .attr(\"width\", bbox.width + 10)\n          .attr(\"height\", bbox.height + 10)\n          .style(\"visibility\", \"visible\");\n      })\n      .on(\"mouseout\", () => {\n        tooltipRect.style(\"visibility\", \"hidden\");\n        tooltipText.style(\"visibility\", \"hidden\");\n      });\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.median))\n      .attr(\"x2\", (d) => x(d.median))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) + rectHeight / 2)\n      .attr(\"stroke\", theme.palette.grey[700])\n      .attr(\"stroke-width\", 2);\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.lowerLimit))\n      .attr(\"x2\", (d) => x(d.lowerLimit))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) + rectHeight / 2)\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    boxContainer\n      .append(\"line\")\n      .attr(\"x1\", (d) => x(d.upperLimit))\n      .attr(\"x2\", (d) => x(d.upperLimit))\n      .attr(\"y1\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) - rectHeight / 2)\n      .attr(\"y2\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")) + rectHeight / 2)\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    boxContainer\n      .selectAll(\"circle\")\n      .data((d) =>\n        d.outliers.map((outlier) => ({\n          tissueSiteDetailId: d.tissueSiteDetailId,\n          outlier,\n        }))\n      )\n      .join(\"circle\")\n      .attr(\"r\", outlierRadius)\n      .attr(\"cx\", (d) => x(d.outlier))\n      .attr(\"cy\", (d) => y(d.tissueSiteDetailId.replace(/_/g, \" \")))\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", theme.palette.grey[700]);\n\n    const xAxis = axisTop(x);\n    const yAxis = axisLeft(y);\n\n    const customAxis = (g, axis) => {\n      g.call(axis);\n      g.select(\".domain\").attr(\"stroke\", theme.palette.grey[700]);\n      g.selectAll(\".tick line\").attr(\"stroke\", theme.palette.grey[700]);\n      g.selectAll(\".tick text\").attr(\"fill\", theme.palette.grey[700]);\n    };\n\n    select(xAxisRef.current).call(customAxis, xAxis);\n    select(yAxisRef.current).call(customAxis, yAxis);\n  }\n\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" height={height} width={width} ref={ref}>\n      <text x={margin.left} y=\"15\" fill={theme.palette.grey[700]} fontSize=\"14\">\n        Normalised expression (RPKM)\n      </text>\n      <g\n        className=\"boxplot\"\n        ref={boxPlotRef}\n        transform={`translate(${margin.left}, ${margin.top})`}\n      />\n      <g ref={xAxisRef} transform={`translate(${margin.left}, ${margin.top})`} />\n      <g ref={yAxisRef} transform={`translate(${margin.left}, ${margin.top})`} />\n      <g ref={tooltipRef} transform={`translate(${margin.left}, ${margin.top})`} />\n    </svg>\n  );\n});\n\nexport default GtexVariability;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/KnownDrugs/Body.jsx" },
        "span": [1356, 1580],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = (id) => [\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction } }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: ensgId, label: name, entity }) {\n  const columnPool = getColumnPool(ensgId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns(ensgId)}\n            dataDownloaderFileStem={`${ensgId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(req) => {\n              setRequest(req);\n            }}\n            variables={{ ensgId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/KnownDrugs/Body.jsx" },
        "span": [1418, 1564],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = (id) => [\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction } }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: ensgId, label: name, entity }) {\n  const columnPool = getColumnPool(ensgId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns(ensgId)}\n            dataDownloaderFileStem={`${ensgId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(req) => {\n              setRequest(req);\n            }}\n            variables={{ ensgId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/KnownDrugs/Body.jsx" },
        "span": [3601, 3778],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = (id) => [\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction } }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: ensgId, label: name, entity }) {\n  const columnPool = getColumnPool(ensgId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns(ensgId)}\n            dataDownloaderFileStem={`${ensgId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(req) => {\n              setRequest(req);\n            }}\n            variables={{ ensgId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/KnownDrugs/Body.jsx" },
        "span": [3652, 3768],
        "sourceCode": "import { sentenceCase } from \"@ot/utils\";\nimport Description from \"./Description\";\nimport { definition } from \"./index\";\n\nimport { naLabel, phaseMap } from \"@ot/constants\";\nimport { useState } from \"react\";\nimport { KnownDrugsSourceDrawer, Link, OtTableSSP, SectionItem } from \"ui\";\nimport KNOWN_DRUGS_BODY_QUERY from \"./KnownDrugsQuery.gql\";\n\nfunction getColumnPool(id, entity) {\n  return [\n    {\n      label: \"Drug information\",\n      columns: [\n        {\n          id: \"drug\",\n          label: \"Drug\",\n          enableHiding: false,\n          propertyPath: \"drug.id\",\n          sticky: true,\n          renderCell: (d) =>\n            d.drug ? (\n              <Link asyncTooltip to={`/drug/${d.drug.id}`}>\n                {d.drug.name}\n              </Link>\n            ) : (\n              naLabel\n            ),\n        },\n        {\n          id: \"type\",\n          label: \"Type\",\n          propertyPath: \"drugType\",\n          renderCell: (d) => d.drugType,\n        },\n        {\n          id: \"mechanismOfAction\",\n          label: \"Mechanism Of Action\",\n        },\n        {\n          id: \"actionType\",\n          label: \"Action Type\",\n          renderCell: ({ drug, target }) => {\n            if (!drug?.mechanismsOfAction) return naLabel;\n            const at = new Set();\n\n            const targetId = entity === \"target\" ? id : target.id;\n\n            drug.mechanismsOfAction.rows.forEach((row) => {\n              row.targets.forEach((t) => {\n                if (t.id === targetId) {\n                  at.add(row.actionType);\n                }\n              });\n            });\n\n            const actionTypes = Array.from(at);\n\n            return actionTypes.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  padding: 0,\n                  listStyle: \"none\",\n                }}\n              >\n                {actionTypes.map((actionType) => (\n                  <li key={actionType}>{sentenceCase(actionType)}</li>\n                ))}\n              </ul>\n            ) : (\n              naLabel\n            );\n          },\n        },\n      ],\n    },\n    {\n      label: \"Disease information\",\n      columns: [\n        {\n          id: \"disease\",\n          label: \"Disease\",\n          propertyPath: \"disease.id\",\n          renderCell: (d) => (\n            <Link asyncTooltip to={`/disease/${d.disease.id}`}>\n              {d.disease.name}\n            </Link>\n          ),\n        },\n      ],\n    },\n    {\n      label: \"Clinical trials information\",\n      columns: [\n        {\n          id: \"phase\",\n          label: \"Phase\",\n          sortable: true,\n          renderCell: ({ phase }) => phaseMap(phase),\n          filterValue: ({ phase }) => phaseMap(phase),\n        },\n        {\n          id: \"status\",\n          label: \"Status\",\n          renderCell: (d) => (d.status ? d.status : naLabel),\n        },\n        {\n          id: \"sources\",\n          label: \"Source\",\n          exportValue: (d) => d.urls.map((reference) => reference.url),\n          renderCell: (d) => <KnownDrugsSourceDrawer references={d.urls} />,\n        },\n      ],\n    },\n  ];\n}\n\nconst exportColumns = (id) => [\n  {\n    label: \"drugId\",\n    exportValue: (row) => row.drug.id,\n  },\n  {\n    label: \"drugName\",\n    exportValue: (row) => row.drug.name,\n  },\n  {\n    label: \"type\",\n    exportValue: (row) => row.drugType,\n  },\n  {\n    label: \"mechanismOfAction\",\n    exportValue: (row) => row.mechanismOfAction,\n  },\n  {\n    label: \"actionType\",\n    exportValue: ({ drug: { mechanismsOfAction } }) => {\n      if (!mechanismsOfAction) return \"\";\n      const at = new Set();\n      mechanismsOfAction.rows.forEach((row) => {\n        row.targets.forEach((t) => {\n          if (t.id === id) {\n            at.add(row.actionType);\n          }\n        });\n      });\n      const actionTypes = Array.from(at);\n      return actionTypes.map((actionType) => sentenceCase(actionType));\n    },\n  },\n  {\n    label: \"diseaseId\",\n    exportValue: (row) => row.disease.id,\n  },\n  {\n    label: \"diseaseName\",\n    exportValue: (row) => row.disease.name,\n  },\n  {\n    label: \"phase\",\n    exportValue: (row) => row.phase,\n  },\n  {\n    label: \"status\",\n    exportValue: (row) => row.status,\n  },\n  {\n    label: \"source\",\n    exportValue: (row) => row.urls.map((reference) => reference.url),\n  },\n];\n\nfunction Body({ id: ensgId, label: name, entity }) {\n  const columnPool = getColumnPool(ensgId, entity);\n  const [request, setRequest] = useState({ loading: true, data: null, error: false });\n\n  return (\n    <>\n      <SectionItem\n        definition={definition}\n        entity={entity}\n        request={request}\n        renderDescription={() => <Description name={name} />}\n        renderBody={() => (\n          <OtTableSSP\n            query={KNOWN_DRUGS_BODY_QUERY}\n            columns={columnPool}\n            dataDownloader\n            dataDownloaderColumns={exportColumns(ensgId)}\n            dataDownloaderFileStem={`${ensgId}-known-drugs`}\n            entity={entity}\n            sectionName=\"knownDrugs\"\n            setInitialRequestData={(req) => {\n              setRequest(req);\n            }}\n            variables={{ ensgId }}\n          />\n        )}\n      />\n    </>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: client" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1493, 1499],
              "sourceCode": "import { Tab, Tabs, Typography } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient, usePlatformApi } from \"ui\";\n\nimport { definition } from \".\";\nimport Description from \"./Description\";\n\nimport IntactTab from \"./IntactTab\";\nimport ReactomeTab from \"./ReactomeTab\";\nimport SignorTab from \"./SignorTab\";\nimport StringTab from \"./StringTab\";\n\nimport INTERACTIONS_STATS_QUERY from \"./InteractionsStats.gql\";\n\nconst getSummaryCounts = (ensgId, client) =>\n  client.query({\n    query: INTERACTIONS_STATS_QUERY,\n    variables: {\n      ensgId,\n    },\n  });\n\nconst sources = [\n  {\n    label: \"IntAct\",\n    id: \"intact\",\n    countDescription: \"molecular interactions\",\n  },\n  {\n    label: \"Signor\",\n    id: \"signor\",\n    countDescription: \"directional, causal interactions\",\n  },\n  {\n    label: \"Reactome\",\n    id: \"reactome\",\n    countDescription: \"pathway-based interactions\",\n  },\n  {\n    label: \"String\",\n    id: \"string\",\n    countDescription: \"functional interactions\",\n  },\n];\n\nfunction Body({ label: symbol, id, entity }) {\n  const request = usePlatformApi();\n  const [source, setSource] = useState(sources[0].id); // must initialize to valid value for tabs to work\n  const [counts, setCounts] = useState({});\n  const [versions, setVersions] = useState({});\n  const client = useApolloClient();\n\n  const onTabChange = (_event, tabId) => {\n    setSource(tabId);\n  };\n\n  // load tabs summary counts\n  useEffect(() => {\n    getSummaryCounts(id, client).then((res) => {\n      // when there is no data, interactions object is null, so there is no count\n      setCounts(\n        Object.assign(\n          {},\n          ...sources.map((k) => ({\n            [k.id]: res.data.target[k.id] ? res.data.target[k.id].count : 0,\n          }))\n        )\n      );\n      // set the sources database versions\n      setVersions(\n        res.data.interactionResources.reduce((a, v) => {\n          const interactionResourceObj = a;\n          interactionResourceObj[v.sourceDatabase] = v.databaseVersion;\n          return a;\n        }, {})\n      );\n      // find first source (tab) with data and set that as the initially selected tab\n      const initialTab = sources.find(\n        (s) => res.data.target[s.id] && res.data.target[s.id].count > 0\n      );\n      if (initialTab) {\n        setSource(initialTab.id);\n      }\n    });\n  }, [id]);\n\n  return (\n    <SectionItem\n      entity={entity}\n      definition={definition}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          {/* Interaction Resource */}\n          <Tabs value={source} onChange={onTabChange} aria-label=\"simple tabs example\">\n            {sources.map((s) => (\n              <Tab\n                label={\n                  <>\n                    <Typography variant=\"body1\">{s.label}</Typography>\n                    {versions[s.id] ? (\n                      <Typography variant=\"caption\" display=\"block\" gutterBottom>\n                        Version: {versions[s.id]}\n                      </Typography>\n                    ) : null}\n                    <Typography variant=\"body2\" gutterBottom>\n                      {counts[s.id]} {s.countDescription}\n                    </Typography>\n                  </>\n                }\n                value={s.id}\n                key={s.id}\n                disabled={counts[s.id] === 0}\n              />\n            ))}\n          </Tabs>\n\n          <div style={{ marginTop: \"50px\" }}>\n            {/* intact stuff */}\n            {source === \"intact\" && counts[source] > 0 && <IntactTab ensgId={id} symbol={symbol} />}\n\n            {/* signor stuff */}\n            {source === \"signor\" && counts[source] > 0 && <SignorTab ensgId={id} symbol={symbol} />}\n\n            {/* reactome stuff */}\n            {source === \"reactome\" && counts[source] > 0 && (\n              <ReactomeTab ensgId={id} symbol={symbol} />\n            )}\n\n            {/* string stuff */}\n            {source === \"string\" && counts[source] > 0 && <StringTab ensgId={id} symbol={symbol} />}\n          </div>\n        </>\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/MolecularInteractions/Body.jsx" },
        "span": [1450, 1459],
        "sourceCode": "import { Tab, Tabs, Typography } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { SectionItem, useApolloClient, usePlatformApi } from \"ui\";\n\nimport { definition } from \".\";\nimport Description from \"./Description\";\n\nimport IntactTab from \"./IntactTab\";\nimport ReactomeTab from \"./ReactomeTab\";\nimport SignorTab from \"./SignorTab\";\nimport StringTab from \"./StringTab\";\n\nimport INTERACTIONS_STATS_QUERY from \"./InteractionsStats.gql\";\n\nconst getSummaryCounts = (ensgId, client) =>\n  client.query({\n    query: INTERACTIONS_STATS_QUERY,\n    variables: {\n      ensgId,\n    },\n  });\n\nconst sources = [\n  {\n    label: \"IntAct\",\n    id: \"intact\",\n    countDescription: \"molecular interactions\",\n  },\n  {\n    label: \"Signor\",\n    id: \"signor\",\n    countDescription: \"directional, causal interactions\",\n  },\n  {\n    label: \"Reactome\",\n    id: \"reactome\",\n    countDescription: \"pathway-based interactions\",\n  },\n  {\n    label: \"String\",\n    id: \"string\",\n    countDescription: \"functional interactions\",\n  },\n];\n\nfunction Body({ label: symbol, id, entity }) {\n  const request = usePlatformApi();\n  const [source, setSource] = useState(sources[0].id); // must initialize to valid value for tabs to work\n  const [counts, setCounts] = useState({});\n  const [versions, setVersions] = useState({});\n  const client = useApolloClient();\n\n  const onTabChange = (_event, tabId) => {\n    setSource(tabId);\n  };\n\n  // load tabs summary counts\n  useEffect(() => {\n    getSummaryCounts(id, client).then((res) => {\n      // when there is no data, interactions object is null, so there is no count\n      setCounts(\n        Object.assign(\n          {},\n          ...sources.map((k) => ({\n            [k.id]: res.data.target[k.id] ? res.data.target[k.id].count : 0,\n          }))\n        )\n      );\n      // set the sources database versions\n      setVersions(\n        res.data.interactionResources.reduce((a, v) => {\n          const interactionResourceObj = a;\n          interactionResourceObj[v.sourceDatabase] = v.databaseVersion;\n          return a;\n        }, {})\n      );\n      // find first source (tab) with data and set that as the initially selected tab\n      const initialTab = sources.find(\n        (s) => res.data.target[s.id] && res.data.target[s.id].count > 0\n      );\n      if (initialTab) {\n        setSource(initialTab.id);\n      }\n    });\n  }, [id]);\n\n  return (\n    <SectionItem\n      entity={entity}\n      definition={definition}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      showContentLoading={true}\n      renderBody={() => (\n        <>\n          {/* Interaction Resource */}\n          <Tabs value={source} onChange={onTabChange} aria-label=\"simple tabs example\">\n            {sources.map((s) => (\n              <Tab\n                label={\n                  <>\n                    <Typography variant=\"body1\">{s.label}</Typography>\n                    {versions[s.id] ? (\n                      <Typography variant=\"caption\" display=\"block\" gutterBottom>\n                        Version: {versions[s.id]}\n                      </Typography>\n                    ) : null}\n                    <Typography variant=\"body2\" gutterBottom>\n                      {counts[s.id]} {s.countDescription}\n                    </Typography>\n                  </>\n                }\n                value={s.id}\n                key={s.id}\n                disabled={counts[s.id] === 0}\n              />\n            ))}\n          </Tabs>\n\n          <div style={{ marginTop: \"50px\" }}>\n            {/* intact stuff */}\n            {source === \"intact\" && counts[source] > 0 && <IntactTab ensgId={id} symbol={symbol} />}\n\n            {/* signor stuff */}\n            {source === \"signor\" && counts[source] > 0 && <SignorTab ensgId={id} symbol={symbol} />}\n\n            {/* reactome stuff */}\n            {source === \"reactome\" && counts[source] > 0 && (\n              <ReactomeTab ensgId={id} symbol={symbol} />\n            )}\n\n            {/* string stuff */}\n            {source === \"string\" && counts[source] > 0 && <StringTab ensgId={id} symbol={symbol} />}\n          </div>\n        </>\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: client" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6286, 6292],
              "sourceCode": "import { faPlay } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { DataTable, EllsWrapper, Link, Tooltip, useApolloClient } from \"ui\";\n\nimport { defaultRowsPerPageOptions } from \"@ot/constants\";\nimport { MethodIconArrow, MethodIconExpandArrow, MethodIconText } from \"./custom/MethodIcons\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst onLinkClick = (e) => {\n  // handler to stop propagation of clicks on links in table rows\n  // to avoid selection of a different row\n  e.stopPropagation();\n};\n\nconst columns = {\n  // interactions table columns\n  interactions: [\n    {\n      id: \"targetB\",\n      label: (\n        <>\n          Interactor{\" \"}\n          <MethodIconText notooltip enabled>\n            B\n          </MethodIconText>\n          <br />\n          <Typography variant=\"caption\">Alt ID</Typography>\n        </>\n      ),\n      exportLabel: \"interactorB-AltId\",\n      renderCell: (row) => (\n        <>\n          <EllsWrapper title={row.targetB ? row.targetB.approvedSymbol : row.intB}>\n            {row.targetB ? (\n              <Link asyncTooltip to={`/target/${row.targetB.id}`} onClick={onLinkClick}>\n                {row.targetB.approvedSymbol}\n              </Link>\n            ) : (\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            )}\n          </EllsWrapper>\n          {row.speciesB && row.speciesB?.mnemonic.toLowerCase() !== \"human\" ? (\n            <Tooltip title={row.speciesB?.mnemonic} showHelpIcon />\n          ) : null}\n          <br />\n          <EllsWrapper title={row.intB}>\n            <Typography variant=\"caption\">\n              Alt ID:{\" \"}\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            </Typography>\n          </EllsWrapper>\n        </>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n      width: \"65%\",\n    },\n    {\n      id: \"sizeEvidences\",\n      label: \"Interaction evidence entries\",\n      renderCell: (row) => (\n        <>\n          {row.count}\n          <span className=\"selected-evidence\">\n            <FontAwesomeIcon icon={faPlay} />\n          </span>\n        </>\n      ),\n      exportValue: (row) => row.count,\n      width: \"35%\",\n    },\n  ],\n\n  // evidence table\n  evidence: [\n    {\n      id: \"interactionIdentifier\",\n      label: \"ID\",\n      renderCell: (row) => (\n        <Link\n          to={`https://reactome.org/content/detail/${row.interactionIdentifier}`}\n          onClick={onLinkClick}\n          external\n        >\n          {row.interactionIdentifier}\n        </Link>\n      ),\n      width: \"25%\",\n    },\n    {\n      id: \"interaction\",\n      label: (\n        <>\n          Interaction\n          <br />\n          <Typography variant=\"caption\">Host organism</Typography>\n        </>\n      ),\n      renderCell: (row) => (\n        <>\n          <EllsWrapper>{row.interactionTypeShortName}</EllsWrapper>\n          <br />\n          <EllsWrapper title={row.hostOrganismScientificName}>\n            <Typography variant=\"caption\">Organism: {row.hostOrganismScientificName}</Typography>\n          </EllsWrapper>\n        </>\n      ),\n      filterValue: (row) => `${row.interactionTypeShortName} ${row.hostOrganismScientificName}`,\n      width: \"30%\",\n    },\n    {\n      id: \"methods\",\n      label: \"Detection methods\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText\n            tooltip={row.participantDetectionMethodA.map((m) => m.shortName).join()}\n            enabled\n          >\n            A\n          </MethodIconText>\n          <MethodIconArrow tooltip={row.interactionDetectionMethodShortName} enabled />\n          <MethodIconText tooltip={row.participantDetectionMethodB[0].shortName} enabled>\n            B\n          </MethodIconText>\n          <MethodIconExpandArrow tooltip={row.expansionMethodShortName} enabled />\n        </>\n      ),\n      filterValue: (row) =>\n        `${row.participantDetectionMethodA.map((m) => m.shortName).join(\" \")} ${\n          row.interactionDetectionMethodShortName\n        } ${row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : \"\"} ${\n          row.expansionMethodShortName\n        }`,\n      width: \"25%\",\n    },\n    {\n      id: \"pubmedId\",\n      label: \"Publication\",\n      renderCell: (d) =>\n        d.pubmedId && d.pubmedId.indexOf(\"unassigned\") === -1 ? (\n          <Link external to={`http://europepmc.org/abstract/MED/${d.pubmedId}`}>\n            {d.pubmedId}\n          </Link>\n        ) : (\n          d.pubmedId\n        ),\n      filterValue: (row) => row.pubmedId,\n      width: \"20%\",\n    },\n  ],\n};\n\nconst evidenceColsExport = [\n  {\n    label: \"Interaction host organism\",\n    exportValue: (row) => row.hostOrganismScientificName,\n  },\n  {\n    label: \"detection method A\",\n    exportValue: (row) => row.participantDetectionMethodA.map((m) => m.shortName),\n  },\n  {\n    label: \"detection method short name\",\n    exportValue: (row) => row.interactionDetectionMethodShortName,\n  },\n  {\n    label: \"detection method B\",\n    exportValue: (row) => row.participantDetectionMethodB[0].shortName,\n  },\n  {\n    label: \"expansion method short name\",\n    exportValue: (row) => row.expansionMethodShortName,\n  },\n];\n\nconst id = \"reactome\";\nconst index = 0;\nconst size = 3000;\n\nfunction ReactomeTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [evidence, setEvidence] = useState([]);\n  const [selectedIntB, setSelectedIntB] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const variables = { ensgId, sourceDatabase: id };\n  const client = useApolloClient();\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n        setEvidence(res.data.target.interactions.rows[0].evidences);\n        setSelectedIntB(\n          res.data.target.interactions.rows[0].targetB?.approvedSymbol ||\n            res.data.target.interactions.rows[0].intB\n        );\n      }\n    });\n  }, [ensgId]);\n  return (\n    <Grid container spacing={10}>\n      <Grid item xs={12} md={5}>\n        {/* table 1: interactions */}\n        <Typography variant=\"h6\" gutterBottom>\n          Interactors of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>{\" \"}\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.interactions}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-interactors`}\n          hover\n          selected\n          onRowClick={(r) => {\n            setEvidence(r.evidences);\n            setSelectedIntB(r.targetB?.approvedSymbol || r.intB);\n          }}\n          rowIsSelectable\n          fixed\n          noWrapHeader={false}\n          onPagination={(page, pageSize) => {\n            setEvidence(data[page * pageSize].evidences);\n            setSelectedIntB(\n              data[page * pageSize].targetB?.approvedSymbol || data[page * pageSize].intB\n            );\n          }}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n          query={INTERACTIONS_QUERY.loc.source.body}\n          variables={variables}\n        />\n      </Grid>\n\n      {/* table 2: evidence */}\n      <Grid item xs={12} md={7}>\n        <Typography variant=\"h6\" gutterBottom>\n          Interaction evidence of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n          {` + ${selectedIntB} `}\n          <MethodIconText notooltip enabled small>\n            B\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.evidence}\n          rows={evidence}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-evidence`}\n          dataDownloaderColumns={evidenceColsExport}\n          fixed\n          noWrapHeader={false}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default ReactomeTab;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/MolecularInteractions/ReactomeTab.jsx" },
        "span": [6189, 6198],
        "sourceCode": "import { faPlay } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { useEffect, useState } from \"react\";\nimport { DataTable, EllsWrapper, Link, Tooltip, useApolloClient } from \"ui\";\n\nimport { defaultRowsPerPageOptions } from \"@ot/constants\";\nimport { MethodIconArrow, MethodIconExpandArrow, MethodIconText } from \"./custom/MethodIcons\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst onLinkClick = (e) => {\n  // handler to stop propagation of clicks on links in table rows\n  // to avoid selection of a different row\n  e.stopPropagation();\n};\n\nconst columns = {\n  // interactions table columns\n  interactions: [\n    {\n      id: \"targetB\",\n      label: (\n        <>\n          Interactor{\" \"}\n          <MethodIconText notooltip enabled>\n            B\n          </MethodIconText>\n          <br />\n          <Typography variant=\"caption\">Alt ID</Typography>\n        </>\n      ),\n      exportLabel: \"interactorB-AltId\",\n      renderCell: (row) => (\n        <>\n          <EllsWrapper title={row.targetB ? row.targetB.approvedSymbol : row.intB}>\n            {row.targetB ? (\n              <Link asyncTooltip to={`/target/${row.targetB.id}`} onClick={onLinkClick}>\n                {row.targetB.approvedSymbol}\n              </Link>\n            ) : (\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            )}\n          </EllsWrapper>\n          {row.speciesB && row.speciesB?.mnemonic.toLowerCase() !== \"human\" ? (\n            <Tooltip title={row.speciesB?.mnemonic} showHelpIcon />\n          ) : null}\n          <br />\n          <EllsWrapper title={row.intB}>\n            <Typography variant=\"caption\">\n              Alt ID:{\" \"}\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            </Typography>\n          </EllsWrapper>\n        </>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n      width: \"65%\",\n    },\n    {\n      id: \"sizeEvidences\",\n      label: \"Interaction evidence entries\",\n      renderCell: (row) => (\n        <>\n          {row.count}\n          <span className=\"selected-evidence\">\n            <FontAwesomeIcon icon={faPlay} />\n          </span>\n        </>\n      ),\n      exportValue: (row) => row.count,\n      width: \"35%\",\n    },\n  ],\n\n  // evidence table\n  evidence: [\n    {\n      id: \"interactionIdentifier\",\n      label: \"ID\",\n      renderCell: (row) => (\n        <Link\n          to={`https://reactome.org/content/detail/${row.interactionIdentifier}`}\n          onClick={onLinkClick}\n          external\n        >\n          {row.interactionIdentifier}\n        </Link>\n      ),\n      width: \"25%\",\n    },\n    {\n      id: \"interaction\",\n      label: (\n        <>\n          Interaction\n          <br />\n          <Typography variant=\"caption\">Host organism</Typography>\n        </>\n      ),\n      renderCell: (row) => (\n        <>\n          <EllsWrapper>{row.interactionTypeShortName}</EllsWrapper>\n          <br />\n          <EllsWrapper title={row.hostOrganismScientificName}>\n            <Typography variant=\"caption\">Organism: {row.hostOrganismScientificName}</Typography>\n          </EllsWrapper>\n        </>\n      ),\n      filterValue: (row) => `${row.interactionTypeShortName} ${row.hostOrganismScientificName}`,\n      width: \"30%\",\n    },\n    {\n      id: \"methods\",\n      label: \"Detection methods\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText\n            tooltip={row.participantDetectionMethodA.map((m) => m.shortName).join()}\n            enabled\n          >\n            A\n          </MethodIconText>\n          <MethodIconArrow tooltip={row.interactionDetectionMethodShortName} enabled />\n          <MethodIconText tooltip={row.participantDetectionMethodB[0].shortName} enabled>\n            B\n          </MethodIconText>\n          <MethodIconExpandArrow tooltip={row.expansionMethodShortName} enabled />\n        </>\n      ),\n      filterValue: (row) =>\n        `${row.participantDetectionMethodA.map((m) => m.shortName).join(\" \")} ${\n          row.interactionDetectionMethodShortName\n        } ${row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : \"\"} ${\n          row.expansionMethodShortName\n        }`,\n      width: \"25%\",\n    },\n    {\n      id: \"pubmedId\",\n      label: \"Publication\",\n      renderCell: (d) =>\n        d.pubmedId && d.pubmedId.indexOf(\"unassigned\") === -1 ? (\n          <Link external to={`http://europepmc.org/abstract/MED/${d.pubmedId}`}>\n            {d.pubmedId}\n          </Link>\n        ) : (\n          d.pubmedId\n        ),\n      filterValue: (row) => row.pubmedId,\n      width: \"20%\",\n    },\n  ],\n};\n\nconst evidenceColsExport = [\n  {\n    label: \"Interaction host organism\",\n    exportValue: (row) => row.hostOrganismScientificName,\n  },\n  {\n    label: \"detection method A\",\n    exportValue: (row) => row.participantDetectionMethodA.map((m) => m.shortName),\n  },\n  {\n    label: \"detection method short name\",\n    exportValue: (row) => row.interactionDetectionMethodShortName,\n  },\n  {\n    label: \"detection method B\",\n    exportValue: (row) => row.participantDetectionMethodB[0].shortName,\n  },\n  {\n    label: \"expansion method short name\",\n    exportValue: (row) => row.expansionMethodShortName,\n  },\n];\n\nconst id = \"reactome\";\nconst index = 0;\nconst size = 3000;\n\nfunction ReactomeTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [evidence, setEvidence] = useState([]);\n  const [selectedIntB, setSelectedIntB] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const variables = { ensgId, sourceDatabase: id };\n  const client = useApolloClient();\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n        setEvidence(res.data.target.interactions.rows[0].evidences);\n        setSelectedIntB(\n          res.data.target.interactions.rows[0].targetB?.approvedSymbol ||\n            res.data.target.interactions.rows[0].intB\n        );\n      }\n    });\n  }, [ensgId]);\n  return (\n    <Grid container spacing={10}>\n      <Grid item xs={12} md={5}>\n        {/* table 1: interactions */}\n        <Typography variant=\"h6\" gutterBottom>\n          Interactors of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>{\" \"}\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.interactions}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-interactors`}\n          hover\n          selected\n          onRowClick={(r) => {\n            setEvidence(r.evidences);\n            setSelectedIntB(r.targetB?.approvedSymbol || r.intB);\n          }}\n          rowIsSelectable\n          fixed\n          noWrapHeader={false}\n          onPagination={(page, pageSize) => {\n            setEvidence(data[page * pageSize].evidences);\n            setSelectedIntB(\n              data[page * pageSize].targetB?.approvedSymbol || data[page * pageSize].intB\n            );\n          }}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n          query={INTERACTIONS_QUERY.loc.source.body}\n          variables={variables}\n        />\n      </Grid>\n\n      {/* table 2: evidence */}\n      <Grid item xs={12} md={7}>\n        <Typography variant=\"h6\" gutterBottom>\n          Interaction evidence of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n          {` + ${selectedIntB} `}\n          <MethodIconText notooltip enabled small>\n            B\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.evidence}\n          rows={evidence}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-evidence`}\n          dataDownloaderColumns={evidenceColsExport}\n          fixed\n          noWrapHeader={false}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default ReactomeTab;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: client" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6300, 6306],
              "sourceCode": "import { faPlay } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { defaultRowsPerPageOptions } from \"@ot/constants\";\nimport { useEffect, useState } from \"react\";\nimport { DataTable, EllsWrapper, Link, Tooltip, useApolloClient } from \"ui\";\nimport { MethodIconArrow, MethodIconText } from \"./custom/MethodIcons\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst onLinkClick = (e) => {\n  // handler to stop propagation of clicks on links in table rows\n  // to avoid selection of a different row\n  e.stopPropagation();\n};\n\nconst columns = {\n  // interactions table columns\n  interactions: [\n    {\n      id: \"targetB\",\n      label: (\n        <>\n          Interactor{\" \"}\n          <MethodIconText notooltip enabled>\n            B\n          </MethodIconText>\n          <br />\n          <Typography variant=\"caption\">Alt ID</Typography>\n        </>\n      ),\n      exportLabel: \"interactorB-AltId\",\n      renderCell: (row) => (\n        <>\n          <EllsWrapper title={row.targetB ? row.targetB.approvedSymbol : row.intB}>\n            {row.targetB ? (\n              <Link asyncTooltip to={`/target/${row.targetB.id}`} onClick={onLinkClick}>\n                {row.targetB.approvedSymbol}\n              </Link>\n            ) : (\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            )}\n          </EllsWrapper>\n          {row.speciesB && row.speciesB?.mnemonic.toLowerCase() !== \"human\" ? (\n            <Tooltip title={row.speciesB?.mnemonic} showHelpIcon />\n          ) : null}\n          <br />\n          <EllsWrapper title={row.intB}>\n            <Typography variant=\"caption\">\n              Alt ID:{\" \"}\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            </Typography>\n          </EllsWrapper>\n        </>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n      width: \"44%\",\n    },\n    {\n      id: \"role\",\n      label: \"Biological role\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText tooltip={row.intABiologicalRole} enabled>\n            A\n          </MethodIconText>\n          <MethodIconText tooltip={row.intBBiologicalRole} enabled>\n            B\n          </MethodIconText>\n        </>\n      ),\n      exportValue: (row) => `A: ${row.intABiologicalRole}, B: ${row.intBBiologicalRole}`,\n      filterValue: (row) => `${row.intABiologicalRole} ${row.intBBiologicalRole}`,\n      width: \"28%\",\n    },\n    {\n      id: \"evidences\",\n      label: \"Interaction evidence entries\",\n      renderCell: (row) => (\n        <>\n          {row.count}\n          <span className=\"selected-evidence\">\n            <FontAwesomeIcon icon={faPlay} />\n          </span>\n        </>\n      ),\n      exportValue: (row) => row.count,\n      width: \"28%\",\n    },\n  ],\n\n  // evidence table\n  evidence: [\n    {\n      id: \"interactionIdentifier\",\n      label: \"Identifier\",\n      width: \"25%\",\n    },\n    {\n      id: \"interaction\",\n      label: (\n        <>\n          Interaction\n          <br />\n          <Typography variant=\"caption\">Host organism</Typography>\n        </>\n      ),\n      renderCell: (row) => (\n        <>\n          <EllsWrapper>{row.interactionTypeShortName}</EllsWrapper>\n          <br />\n          <EllsWrapper title={row.hostOrganismScientificName}>\n            <Typography variant=\"caption\">{row.hostOrganismScientificName}</Typography>\n          </EllsWrapper>\n        </>\n      ),\n      filterValue: (row) => `${row.interactionTypeShortName} ${row.hostOrganismScientificName}`,\n      width: \"30%\",\n    },\n    {\n      id: \"methods\",\n      label: \"Detection methods\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText\n            tooltip={row.participantDetectionMethodA.map((m) => m.shortName).join()}\n            enabled\n          >\n            A\n          </MethodIconText>\n          <MethodIconArrow tooltip={row.interactionDetectionMethodShortName} enabled />\n          <MethodIconText tooltip={row.participantDetectionMethodB[0].shortName} enabled>\n            B\n          </MethodIconText>\n        </>\n      ),\n      filterValue: (row) =>\n        `${row.participantDetectionMethodA.map((m) => m.shortName).join(\" \")} ${\n          row.interactionDetectionMethodShortName\n        } ${row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : \"\"}`,\n      width: \"25%\",\n    },\n    {\n      id: \"pubmedId\",\n      label: \"Publication\",\n      renderCell: (d) =>\n        d.pubmedId && d.pubmedId.indexOf(\"unassigned\") === -1 ? (\n          <Link external to={`http://europepmc.org/abstract/MED/${d.pubmedId}`}>\n            {d.pubmedId}\n          </Link>\n        ) : (\n          d.pubmedId\n        ),\n      filterValue: (row) => row.pubmedId,\n      width: \"20%\",\n    },\n  ],\n};\n\nconst evidenceColsExport = [\n  {\n    label: \"Interaction host organism\",\n    exportValue: (row) => row.hostOrganismScientificName,\n  },\n  {\n    label: \"detection method A\",\n    exportValue: (row) => row.participantDetectionMethodA.map((m) => m.shortName),\n  },\n  {\n    label: \"detection method short name\",\n    exportValue: (row) => row.interactionDetectionMethodShortName,\n  },\n  {\n    label: \"detection method B\",\n    exportValue: (row) => row.participantDetectionMethodB[0].shortName,\n  },\n];\n\nconst id = \"signor\";\nconst index = 0;\nconst size = 3000;\n\nfunction SignorTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [evidence, setEvidence] = useState([]);\n  const [selectedIntB, setSelectedIntB] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const client = useApolloClient();\n\n  const variables = { ensgId, sourceDatabase: id };\n\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n        setEvidence(res.data.target.interactions.rows[0].evidences);\n        setSelectedIntB(\n          res.data.target.interactions.rows[0].targetB?.approvedSymbol ||\n            res.data.target.interactions.rows[0].intB\n        );\n      }\n    });\n  }, [ensgId]);\n\n  return (\n    <Grid container spacing={10}>\n      <Grid item xs={12} md={5}>\n        {/* table 1: interactions */}\n        <Typography variant=\"h6\" gutterBottom>\n          Interactors of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>{\" \"}\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.interactions}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-interactors`}\n          hover\n          selected\n          onRowClick={(r) => {\n            setEvidence(r.evidences);\n            setSelectedIntB(r.targetB?.approvedSymbol || r.intB);\n          }}\n          rowIsSelectable\n          fixed\n          noWrapHeader={false}\n          onPagination={(page, pageSize) => {\n            setEvidence(data[page * pageSize].evidences);\n            setSelectedIntB(\n              data[page * pageSize].targetB?.approvedSymbol || data[page * pageSize].intB\n            );\n          }}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n          query={INTERACTIONS_QUERY.loc.source.body}\n          variables={variables}\n        />\n      </Grid>\n\n      {/* table 2: evidence */}\n      <Grid item xs={12} md={7}>\n        <Typography variant=\"h6\" gutterBottom>\n          Interaction evidence of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n          {` + ${selectedIntB} `}\n          <MethodIconText notooltip enabled small>\n            B\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.evidence}\n          rows={evidence}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-evidence`}\n          dataDownloaderColumns={evidenceColsExport}\n          fixed\n          noWrapHeader={false}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default SignorTab;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/MolecularInteractions/SignorTab.jsx" },
        "span": [6203, 6212],
        "sourceCode": "import { faPlay } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { defaultRowsPerPageOptions } from \"@ot/constants\";\nimport { useEffect, useState } from \"react\";\nimport { DataTable, EllsWrapper, Link, Tooltip, useApolloClient } from \"ui\";\nimport { MethodIconArrow, MethodIconText } from \"./custom/MethodIcons\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst onLinkClick = (e) => {\n  // handler to stop propagation of clicks on links in table rows\n  // to avoid selection of a different row\n  e.stopPropagation();\n};\n\nconst columns = {\n  // interactions table columns\n  interactions: [\n    {\n      id: \"targetB\",\n      label: (\n        <>\n          Interactor{\" \"}\n          <MethodIconText notooltip enabled>\n            B\n          </MethodIconText>\n          <br />\n          <Typography variant=\"caption\">Alt ID</Typography>\n        </>\n      ),\n      exportLabel: \"interactorB-AltId\",\n      renderCell: (row) => (\n        <>\n          <EllsWrapper title={row.targetB ? row.targetB.approvedSymbol : row.intB}>\n            {row.targetB ? (\n              <Link asyncTooltip to={`/target/${row.targetB.id}`} onClick={onLinkClick}>\n                {row.targetB.approvedSymbol}\n              </Link>\n            ) : (\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            )}\n          </EllsWrapper>\n          {row.speciesB && row.speciesB?.mnemonic.toLowerCase() !== \"human\" ? (\n            <Tooltip title={row.speciesB?.mnemonic} showHelpIcon />\n          ) : null}\n          <br />\n          <EllsWrapper title={row.intB}>\n            <Typography variant=\"caption\">\n              Alt ID:{\" \"}\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            </Typography>\n          </EllsWrapper>\n        </>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n      width: \"44%\",\n    },\n    {\n      id: \"role\",\n      label: \"Biological role\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText tooltip={row.intABiologicalRole} enabled>\n            A\n          </MethodIconText>\n          <MethodIconText tooltip={row.intBBiologicalRole} enabled>\n            B\n          </MethodIconText>\n        </>\n      ),\n      exportValue: (row) => `A: ${row.intABiologicalRole}, B: ${row.intBBiologicalRole}`,\n      filterValue: (row) => `${row.intABiologicalRole} ${row.intBBiologicalRole}`,\n      width: \"28%\",\n    },\n    {\n      id: \"evidences\",\n      label: \"Interaction evidence entries\",\n      renderCell: (row) => (\n        <>\n          {row.count}\n          <span className=\"selected-evidence\">\n            <FontAwesomeIcon icon={faPlay} />\n          </span>\n        </>\n      ),\n      exportValue: (row) => row.count,\n      width: \"28%\",\n    },\n  ],\n\n  // evidence table\n  evidence: [\n    {\n      id: \"interactionIdentifier\",\n      label: \"Identifier\",\n      width: \"25%\",\n    },\n    {\n      id: \"interaction\",\n      label: (\n        <>\n          Interaction\n          <br />\n          <Typography variant=\"caption\">Host organism</Typography>\n        </>\n      ),\n      renderCell: (row) => (\n        <>\n          <EllsWrapper>{row.interactionTypeShortName}</EllsWrapper>\n          <br />\n          <EllsWrapper title={row.hostOrganismScientificName}>\n            <Typography variant=\"caption\">{row.hostOrganismScientificName}</Typography>\n          </EllsWrapper>\n        </>\n      ),\n      filterValue: (row) => `${row.interactionTypeShortName} ${row.hostOrganismScientificName}`,\n      width: \"30%\",\n    },\n    {\n      id: \"methods\",\n      label: \"Detection methods\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText\n            tooltip={row.participantDetectionMethodA.map((m) => m.shortName).join()}\n            enabled\n          >\n            A\n          </MethodIconText>\n          <MethodIconArrow tooltip={row.interactionDetectionMethodShortName} enabled />\n          <MethodIconText tooltip={row.participantDetectionMethodB[0].shortName} enabled>\n            B\n          </MethodIconText>\n        </>\n      ),\n      filterValue: (row) =>\n        `${row.participantDetectionMethodA.map((m) => m.shortName).join(\" \")} ${\n          row.interactionDetectionMethodShortName\n        } ${row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : \"\"}`,\n      width: \"25%\",\n    },\n    {\n      id: \"pubmedId\",\n      label: \"Publication\",\n      renderCell: (d) =>\n        d.pubmedId && d.pubmedId.indexOf(\"unassigned\") === -1 ? (\n          <Link external to={`http://europepmc.org/abstract/MED/${d.pubmedId}`}>\n            {d.pubmedId}\n          </Link>\n        ) : (\n          d.pubmedId\n        ),\n      filterValue: (row) => row.pubmedId,\n      width: \"20%\",\n    },\n  ],\n};\n\nconst evidenceColsExport = [\n  {\n    label: \"Interaction host organism\",\n    exportValue: (row) => row.hostOrganismScientificName,\n  },\n  {\n    label: \"detection method A\",\n    exportValue: (row) => row.participantDetectionMethodA.map((m) => m.shortName),\n  },\n  {\n    label: \"detection method short name\",\n    exportValue: (row) => row.interactionDetectionMethodShortName,\n  },\n  {\n    label: \"detection method B\",\n    exportValue: (row) => row.participantDetectionMethodB[0].shortName,\n  },\n];\n\nconst id = \"signor\";\nconst index = 0;\nconst size = 3000;\n\nfunction SignorTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [evidence, setEvidence] = useState([]);\n  const [selectedIntB, setSelectedIntB] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const client = useApolloClient();\n\n  const variables = { ensgId, sourceDatabase: id };\n\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n        setEvidence(res.data.target.interactions.rows[0].evidences);\n        setSelectedIntB(\n          res.data.target.interactions.rows[0].targetB?.approvedSymbol ||\n            res.data.target.interactions.rows[0].intB\n        );\n      }\n    });\n  }, [ensgId]);\n\n  return (\n    <Grid container spacing={10}>\n      <Grid item xs={12} md={5}>\n        {/* table 1: interactions */}\n        <Typography variant=\"h6\" gutterBottom>\n          Interactors of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>{\" \"}\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.interactions}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-interactors`}\n          hover\n          selected\n          onRowClick={(r) => {\n            setEvidence(r.evidences);\n            setSelectedIntB(r.targetB?.approvedSymbol || r.intB);\n          }}\n          rowIsSelectable\n          fixed\n          noWrapHeader={false}\n          onPagination={(page, pageSize) => {\n            setEvidence(data[page * pageSize].evidences);\n            setSelectedIntB(\n              data[page * pageSize].targetB?.approvedSymbol || data[page * pageSize].intB\n            );\n          }}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n          query={INTERACTIONS_QUERY.loc.source.body}\n          variables={variables}\n        />\n      </Grid>\n\n      {/* table 2: evidence */}\n      <Grid item xs={12} md={7}>\n        <Typography variant=\"h6\" gutterBottom>\n          Interaction evidence of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n          {` + ${selectedIntB} `}\n          <MethodIconText notooltip enabled small>\n            B\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.evidence}\n          rows={evidence}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-evidence`}\n          dataDownloaderColumns={evidenceColsExport}\n          fixed\n          noWrapHeader={false}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default SignorTab;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: name",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: name" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2972, 2976],
              "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationSummary.tsx"
        },
        "span": [2797, 2806],
        "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: requestSummary",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: requestSummary"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3205, 3219],
              "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationSummary.tsx"
        },
        "span": [2797, 2806],
        "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: symbol",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: symbol" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2956, 2962],
              "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationSummary.tsx"
        },
        "span": [2797, 2806],
        "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: pmcId",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: pmcId" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2941, 2946],
              "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationSummary.tsx"
        },
        "span": [2797, 2806],
        "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: summaryText",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: summaryText"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3281, 3292],
              "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/PublicationsDrawer/PublicationSummary.tsx"
        },
        "span": [2797, 2806],
        "sourceCode": "import { Box, Button, Collapse, type Theme, Typography } from \"@mui/material\";\nimport { createStyles, makeStyles } from \"@mui/styles\";\nimport { useEffect, useState } from \"react\";\n\nimport { faCircleNodes } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { publicationSummaryQuery } from \"@ot/utils\";\nimport PublicationActionsTooltip from \"./PublicationActionsTooltip\";\nimport PublicationSummaryLabel from \"./PublicationSummaryLabel\";\nimport SummaryLoader from \"./SummaryLoader\";\n\ntype LoadingState = true | false;\ntype CollapsedState = true | false;\ntype TextState = string | null;\ntype PublicationSummaryProps = {\n  pmcId: string;\n  symbol: string;\n  name: string;\n};\n\nconst helpText =\n  \"Evidence summarisation based on the available full-text article. Free-to-use full-text article provided by Europe PMC and summarised using OpenAI's gpt-3.5-turbo model.\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    fileLabel: {\n      cursor: \"pointer\",\n      color: \"#5a5f5f\",\n      fontSize: \"0.875rem\",\n      fontFamily: '\"Inter\", \"sans-serif\"',\n    },\n    detailPanel: {\n      background: `${theme.palette.grey[100]}`,\n      marginTop: \"10px\",\n      marginBottom: \"10px\",\n      padding: \"25px 20px\",\n      position: \"relative\",\n    },\n    summarySpan: {\n      whiteSpace: \"normal\",\n    },\n    detailsButton: {\n      margin: \"0 \",\n    },\n  })\n);\n\nfunction PublicationSummary({ pmcId, symbol, name }: PublicationSummaryProps): JSX.Element {\n  const [loading, setLoading] = useState<LoadingState>(false);\n  const [error, setError] = useState<TextState>(null);\n  const [summaryText, setSummaryText] = useState<TextState>(null);\n  const [collapseOpen, setCollapseOpen] = useState<CollapsedState>(false);\n\n  const classes = useStyles();\n\n  const handleChange = () => {\n    setCollapseOpen((prev) => !prev);\n  };\n\n  function requestSummary({ baseUrl, requestOptions }: any) {\n    fetch(baseUrl, requestOptions)\n      .then((response) => {\n        if (response.ok) return response.json();\n        return response.json().then((err) => {\n          throw new Error(err.error);\n        });\n      })\n      .then((data) => {\n        setSummaryText(data.text);\n        setError(null);\n        setLoading(false);\n      })\n      .catch((err) => {\n        setError(err.message);\n        setLoading(false);\n      });\n  }\n\n  const onClickRetry = () => {\n    setLoading(true);\n    const { baseUrl, body } = publicationSummaryQuery({\n      pmcId,\n      symbol,\n      name,\n    });\n    const requestOptions: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({ payload: body.payload }),\n    };\n    requestSummary({ baseUrl, requestOptions });\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      const { baseUrl, body } = publicationSummaryQuery({\n        pmcId,\n        symbol,\n        name,\n      });\n      const requestOptions: RequestInit = {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ payload: body.payload }),\n      };\n\n      requestSummary({ baseUrl, requestOptions });\n    };\n    if (collapseOpen && summaryText === null) {\n      fetchData();\n    }\n  }, [collapseOpen]);\n\n  return (\n    <div>\n      <PublicationActionsTooltip title={helpText} placement=\"top\">\n        <Button\n          className={classes.detailsButton}\n          variant=\"outlined\"\n          size=\"small\"\n          onClick={() => {\n            handleChange();\n          }}\n          startIcon={<FontAwesomeIcon icon={faCircleNodes} size=\"sm\" />}\n        >\n          Show summary\n        </Button>\n      </PublicationActionsTooltip>\n      <Collapse in={collapseOpen}>\n        <Box className={classes.detailPanel}>\n          {loading && <SummaryLoader />}\n          {!loading && error && (\n            <>\n              <span className={classes.summarySpan}>\n                <b>Error: </b>\n                {error}\n              </span>\n              <br />\n              <br />\n              <button type=\"button\" onClick={onClickRetry}>\n                Retry request\n              </button>\n            </>\n          )}\n          {!loading && !error && (\n            <>\n              <Typography variant=\"subtitle2\">Evidence summary</Typography>\n              <span className={classes.summarySpan}>{summaryText}</span>\n            </>\n          )}\n          <PublicationSummaryLabel />\n        </Box>\n      </Collapse>\n    </div>\n  );\n}\n\nexport default PublicationSummary;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: client" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7245, 7251],
              "sourceCode": "import { faPlay } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { defaultRowsPerPageOptions } from \"@ot/constants\";\nimport { useEffect, useState } from \"react\";\nimport { DataTable, EllsWrapper, Link, Tooltip, useApolloClient } from \"ui\";\nimport { MethodIconArrow, MethodIconText } from \"./custom/MethodIcons\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst onLinkClick = (e) => {\n  // handler to stop propagation of clicks on links in table rows\n  // to avoid selection of a different row\n  e.stopPropagation();\n};\n\nconst columns = {\n  interactions: [\n    {\n      id: \"targetB\",\n      label: (\n        <>\n          Interactor{\" \"}\n          <MethodIconText notooltip enabled>\n            B\n          </MethodIconText>\n          <br />\n          <Typography variant=\"caption\">Alt ID</Typography>\n        </>\n      ),\n      exportLabel: \"interactorB-AltId\",\n      renderCell: (row) => (\n        <>\n          <EllsWrapper title={row.targetB ? row.targetB.approvedSymbol : row.intB}>\n            {row.targetB ? (\n              <Link asyncTooltip to={`/target/${row.targetB.id}`} onClick={onLinkClick}>\n                {row.targetB.approvedSymbol}\n              </Link>\n            ) : (\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            )}\n          </EllsWrapper>\n          {row.speciesB && row.speciesB?.mnemonic.toLowerCase() !== \"human\" ? (\n            <Tooltip title={row.speciesB?.mnemonic} showHelpIcon />\n          ) : null}\n          <br />\n          <EllsWrapper title={row.intB}>\n            <Typography variant=\"caption\">\n              Alt ID:{\" \"}\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            </Typography>\n          </EllsWrapper>\n        </>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n      width: \"40%\",\n    },\n    {\n      id: \"score\",\n      label: \"Score\",\n      renderCell: (row) => row.score.toFixed(2),\n      exportValue: (row) => row.score.toFixed(2),\n      width: \"14%\",\n    },\n    {\n      id: \"biologicalRole\",\n      label: \"Biological role\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText tooltip={row.intABiologicalRole} enabled>\n            A\n          </MethodIconText>\n          <MethodIconText tooltip={row.intBBiologicalRole} enabled>\n            B\n          </MethodIconText>\n        </>\n      ),\n      exportValue: (row) => `A: ${row.intABiologicalRole}, B: ${row.intBBiologicalRole}`,\n      filterValue: (row) => `${row.intABiologicalRole} ${row.intBBiologicalRole}`,\n      width: \"23%\",\n    },\n    {\n      id: \"evidences\",\n      label: \"Interaction evidence entries\",\n      renderCell: (row) => (\n        <>\n          {row.count}\n          <span className=\"selected-evidence\">\n            <FontAwesomeIcon icon={faPlay} />\n          </span>\n        </>\n      ),\n      exportValue: (row) => row.count,\n      width: \"23%\",\n    },\n  ],\n\n  evidence: [\n    {\n      id: \"interactionIdentifier\",\n      label: \"Identifier\",\n      renderCell: (row) => (\n        <Link\n          to={`http://www.ebi.ac.uk/intact/interaction/${row.interactionIdentifier}`}\n          onClick={onLinkClick}\n          external\n        >\n          {row.interactionIdentifier}\n        </Link>\n      ),\n      width: \"25%\",\n    },\n    {\n      id: \"interaction\",\n      label: (\n        <>\n          Interaction\n          <br />\n          <Typography variant=\"caption\">Host organism</Typography>\n        </>\n      ),\n      renderCell: (row) => (\n        <>\n          <EllsWrapper>{row.interactionTypeShortName}</EllsWrapper>\n          {row.hostOrganismScientificName ? (\n            <>\n              <br />\n              <EllsWrapper title={row.hostOrganismScientificName}>\n                <Typography variant=\"caption\">{row.hostOrganismScientificName}</Typography>\n              </EllsWrapper>\n            </>\n          ) : null}\n        </>\n      ),\n      filterValue: (row) => `${row.interactionTypeShortName} ${row.hostOrganismScientificName}`,\n      width: \"30%\",\n    },\n    {\n      id: \"methods\",\n      label: \"Detection methods\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText\n            tooltip={row.participantDetectionMethodA.map((m) => m.shortName).join()}\n            enabled\n          >\n            A\n          </MethodIconText>\n          <MethodIconArrow tooltip={row.interactionDetectionMethodShortName} enabled />\n          <MethodIconText\n            tooltip={\n              row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : null\n            }\n            enabled\n          >\n            B\n          </MethodIconText>\n        </>\n      ),\n      filterValue: (row) =>\n        `${row.participantDetectionMethodA.map((m) => m.shortName).join(\" \")} ${\n          row.interactionDetectionMethodShortName\n        } ${row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : \"\"}`,\n      width: \"25%\",\n    },\n    {\n      id: \"pubmedId\",\n      label: \"Publication\",\n      renderCell: (d) => (\n        <EllsWrapper title={d.pubmedId}>\n          {d.pubmedId && d.pubmedId.indexOf(\"unassigned\") === -1 ? (\n            <Link external to={`http://europepmc.org/abstract/MED/${d.pubmedId}`}>\n              {d.pubmedId}\n            </Link>\n          ) : (\n            d.pubmedId\n          )}\n        </EllsWrapper>\n      ),\n      filterValue: (row) => row.pubmedId,\n      width: \"20%\",\n    },\n  ],\n};\n\nconst evidenceColsExport = [\n  {\n    label: \"Identifier\",\n    exportValue: (row) => row.interactionIdentifier,\n  },\n  {\n    label: \"interaction\",\n    exportValue: (row) => row.interactionTypeShortName,\n  },\n  {\n    label: \"interaction host organism\",\n    exportValue: (row) => row.hostOrganismScientificName,\n  },\n  {\n    label: \"detection method A\",\n    exportValue: (row) => row.participantDetectionMethodA.map((m) => m.shortName),\n  },\n  {\n    label: \"detection method short name\",\n    exportValue: (row) => row.interactionDetectionMethodShortName,\n  },\n  {\n    label: \"detection method B\",\n    exportValue: (row) => row.participantDetectionMethodB[0].shortName,\n  },\n  {\n    label: \"publication id\",\n    exportValue: (row) => row.pubmedId,\n  },\n];\nconst id = \"intact\";\nconst index = 0;\nconst size = 3000;\n\nfunction IntactTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [evidence, setEvidence] = useState([]);\n  const [selectedIntB, setSelectedIntB] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const variables = { ensgId, sourceDatabase: id };\n  const client = useApolloClient();\n\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n        setEvidence(res.data.target.interactions.rows[0].evidences);\n        setSelectedIntB(\n          res.data.target.interactions.rows[0].targetB?.approvedSymbol ||\n            res.data.target.interactions.rows[0].intB\n        );\n      }\n    });\n  }, [ensgId]);\n\n  return (\n    <Grid container spacing={10}>\n      <Grid item xs={12} md={5}>\n        {/* table 1: interactions */}\n        <Typography variant=\"body1\" gutterBottom>\n          Interactors of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.interactions}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-interactors`}\n          hover\n          selected\n          onRowClick={(r) => {\n            setEvidence(r.evidences);\n            setSelectedIntB(r.targetB?.approvedSymbol || r.intB);\n          }}\n          rowIsSelectable\n          fixed\n          noWrapHeader={false}\n          onPagination={(page, pageSize) => {\n            setEvidence(data[page * pageSize].evidences);\n            setSelectedIntB(\n              data[page * pageSize].targetB?.approvedSymbol || data[page * pageSize].intB\n            );\n          }}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n          query={INTERACTIONS_QUERY.loc.source.body}\n          variables={variables}\n        />\n      </Grid>\n\n      {/* table 2: evidence */}\n      <Grid item xs={12} md={7}>\n        <Typography variant=\"body1\" gutterBottom>\n          Interaction evidence of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n          {` + ${selectedIntB} `}\n          <MethodIconText notooltip enabled small>\n            B\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.evidence}\n          rows={evidence}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-evidence`}\n          dataDownloaderColumns={evidenceColsExport}\n          fixed\n          noWrapHeader={false}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default IntactTab;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/MolecularInteractions/IntactTab.jsx" },
        "span": [7148, 7157],
        "sourceCode": "import { faPlay } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { defaultRowsPerPageOptions } from \"@ot/constants\";\nimport { useEffect, useState } from \"react\";\nimport { DataTable, EllsWrapper, Link, Tooltip, useApolloClient } from \"ui\";\nimport { MethodIconArrow, MethodIconText } from \"./custom/MethodIcons\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst onLinkClick = (e) => {\n  // handler to stop propagation of clicks on links in table rows\n  // to avoid selection of a different row\n  e.stopPropagation();\n};\n\nconst columns = {\n  interactions: [\n    {\n      id: \"targetB\",\n      label: (\n        <>\n          Interactor{\" \"}\n          <MethodIconText notooltip enabled>\n            B\n          </MethodIconText>\n          <br />\n          <Typography variant=\"caption\">Alt ID</Typography>\n        </>\n      ),\n      exportLabel: \"interactorB-AltId\",\n      renderCell: (row) => (\n        <>\n          <EllsWrapper title={row.targetB ? row.targetB.approvedSymbol : row.intB}>\n            {row.targetB ? (\n              <Link asyncTooltip to={`/target/${row.targetB.id}`} onClick={onLinkClick}>\n                {row.targetB.approvedSymbol}\n              </Link>\n            ) : (\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            )}\n          </EllsWrapper>\n          {row.speciesB && row.speciesB?.mnemonic.toLowerCase() !== \"human\" ? (\n            <Tooltip title={row.speciesB?.mnemonic} showHelpIcon />\n          ) : null}\n          <br />\n          <EllsWrapper title={row.intB}>\n            <Typography variant=\"caption\">\n              Alt ID:{\" \"}\n              <Link to={`http://uniprot.org/uniprot/${row.intB}`} onClick={onLinkClick} external>\n                {row.intB}\n              </Link>\n            </Typography>\n          </EllsWrapper>\n        </>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n      width: \"40%\",\n    },\n    {\n      id: \"score\",\n      label: \"Score\",\n      renderCell: (row) => row.score.toFixed(2),\n      exportValue: (row) => row.score.toFixed(2),\n      width: \"14%\",\n    },\n    {\n      id: \"biologicalRole\",\n      label: \"Biological role\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText tooltip={row.intABiologicalRole} enabled>\n            A\n          </MethodIconText>\n          <MethodIconText tooltip={row.intBBiologicalRole} enabled>\n            B\n          </MethodIconText>\n        </>\n      ),\n      exportValue: (row) => `A: ${row.intABiologicalRole}, B: ${row.intBBiologicalRole}`,\n      filterValue: (row) => `${row.intABiologicalRole} ${row.intBBiologicalRole}`,\n      width: \"23%\",\n    },\n    {\n      id: \"evidences\",\n      label: \"Interaction evidence entries\",\n      renderCell: (row) => (\n        <>\n          {row.count}\n          <span className=\"selected-evidence\">\n            <FontAwesomeIcon icon={faPlay} />\n          </span>\n        </>\n      ),\n      exportValue: (row) => row.count,\n      width: \"23%\",\n    },\n  ],\n\n  evidence: [\n    {\n      id: \"interactionIdentifier\",\n      label: \"Identifier\",\n      renderCell: (row) => (\n        <Link\n          to={`http://www.ebi.ac.uk/intact/interaction/${row.interactionIdentifier}`}\n          onClick={onLinkClick}\n          external\n        >\n          {row.interactionIdentifier}\n        </Link>\n      ),\n      width: \"25%\",\n    },\n    {\n      id: \"interaction\",\n      label: (\n        <>\n          Interaction\n          <br />\n          <Typography variant=\"caption\">Host organism</Typography>\n        </>\n      ),\n      renderCell: (row) => (\n        <>\n          <EllsWrapper>{row.interactionTypeShortName}</EllsWrapper>\n          {row.hostOrganismScientificName ? (\n            <>\n              <br />\n              <EllsWrapper title={row.hostOrganismScientificName}>\n                <Typography variant=\"caption\">{row.hostOrganismScientificName}</Typography>\n              </EllsWrapper>\n            </>\n          ) : null}\n        </>\n      ),\n      filterValue: (row) => `${row.interactionTypeShortName} ${row.hostOrganismScientificName}`,\n      width: \"30%\",\n    },\n    {\n      id: \"methods\",\n      label: \"Detection methods\",\n      renderCell: (row) => (\n        <>\n          <MethodIconText\n            tooltip={row.participantDetectionMethodA.map((m) => m.shortName).join()}\n            enabled\n          >\n            A\n          </MethodIconText>\n          <MethodIconArrow tooltip={row.interactionDetectionMethodShortName} enabled />\n          <MethodIconText\n            tooltip={\n              row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : null\n            }\n            enabled\n          >\n            B\n          </MethodIconText>\n        </>\n      ),\n      filterValue: (row) =>\n        `${row.participantDetectionMethodA.map((m) => m.shortName).join(\" \")} ${\n          row.interactionDetectionMethodShortName\n        } ${row.participantDetectionMethodB ? row.participantDetectionMethodB[0].shortName : \"\"}`,\n      width: \"25%\",\n    },\n    {\n      id: \"pubmedId\",\n      label: \"Publication\",\n      renderCell: (d) => (\n        <EllsWrapper title={d.pubmedId}>\n          {d.pubmedId && d.pubmedId.indexOf(\"unassigned\") === -1 ? (\n            <Link external to={`http://europepmc.org/abstract/MED/${d.pubmedId}`}>\n              {d.pubmedId}\n            </Link>\n          ) : (\n            d.pubmedId\n          )}\n        </EllsWrapper>\n      ),\n      filterValue: (row) => row.pubmedId,\n      width: \"20%\",\n    },\n  ],\n};\n\nconst evidenceColsExport = [\n  {\n    label: \"Identifier\",\n    exportValue: (row) => row.interactionIdentifier,\n  },\n  {\n    label: \"interaction\",\n    exportValue: (row) => row.interactionTypeShortName,\n  },\n  {\n    label: \"interaction host organism\",\n    exportValue: (row) => row.hostOrganismScientificName,\n  },\n  {\n    label: \"detection method A\",\n    exportValue: (row) => row.participantDetectionMethodA.map((m) => m.shortName),\n  },\n  {\n    label: \"detection method short name\",\n    exportValue: (row) => row.interactionDetectionMethodShortName,\n  },\n  {\n    label: \"detection method B\",\n    exportValue: (row) => row.participantDetectionMethodB[0].shortName,\n  },\n  {\n    label: \"publication id\",\n    exportValue: (row) => row.pubmedId,\n  },\n];\nconst id = \"intact\";\nconst index = 0;\nconst size = 3000;\n\nfunction IntactTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [evidence, setEvidence] = useState([]);\n  const [selectedIntB, setSelectedIntB] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const variables = { ensgId, sourceDatabase: id };\n  const client = useApolloClient();\n\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n        setEvidence(res.data.target.interactions.rows[0].evidences);\n        setSelectedIntB(\n          res.data.target.interactions.rows[0].targetB?.approvedSymbol ||\n            res.data.target.interactions.rows[0].intB\n        );\n      }\n    });\n  }, [ensgId]);\n\n  return (\n    <Grid container spacing={10}>\n      <Grid item xs={12} md={5}>\n        {/* table 1: interactions */}\n        <Typography variant=\"body1\" gutterBottom>\n          Interactors of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.interactions}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-interactors`}\n          hover\n          selected\n          onRowClick={(r) => {\n            setEvidence(r.evidences);\n            setSelectedIntB(r.targetB?.approvedSymbol || r.intB);\n          }}\n          rowIsSelectable\n          fixed\n          noWrapHeader={false}\n          onPagination={(page, pageSize) => {\n            setEvidence(data[page * pageSize].evidences);\n            setSelectedIntB(\n              data[page * pageSize].targetB?.approvedSymbol || data[page * pageSize].intB\n            );\n          }}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n          query={INTERACTIONS_QUERY.loc.source.body}\n          variables={variables}\n        />\n      </Grid>\n\n      {/* table 2: evidence */}\n      <Grid item xs={12} md={7}>\n        <Typography variant=\"body1\" gutterBottom>\n          Interaction evidence of\n          <br />\n          {symbol}{\" \"}\n          <MethodIconText notooltip enabled small>\n            A\n          </MethodIconText>\n          {` + ${selectedIntB} `}\n          <MethodIconText notooltip enabled small>\n            B\n          </MethodIconText>\n        </Typography>\n        <DataTable\n          showGlobalFilter\n          columns={columns.evidence}\n          rows={evidence}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-evidence`}\n          dataDownloaderColumns={evidenceColsExport}\n          fixed\n          noWrapHeader={false}\n          rowsPerPageOptions={defaultRowsPerPageOptions}\n          loading={loading}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default IntactTab;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: client",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: client" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [8538, 8544],
              "sourceCode": "import { Grid } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { colorRange } from \"@ot/constants\";\nimport { scaleQuantize } from \"d3\";\nimport { useEffect, useState } from \"react\";\nimport { Legend, Link, OtTable, useApolloClient } from \"ui\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsStringQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst useStyles = makeStyles({\n  root: {\n    overflow: \"visible\",\n    padding: \"2rem 3rem 0 0 !important\",\n  },\n  table: {\n    tableLayout: \"fixed !important\",\n  },\n  sortLabel: {\n    top: \"8px\",\n  },\n  innerLabel: {\n    position: \"absolute\",\n    display: \"inline-block\",\n    transformOrigin: \"-20px 20px\",\n    bottom: 0,\n    transform: \"rotate(315deg)\",\n    marginBottom: \"5px\",\n  },\n  nameHeaderCell: {\n    width: \"15%\",\n    borderBottom: \"0 !important\",\n    height: \"140px !important\",\n    verticalAlign: \"bottom !important\",\n    textAlign: \"end !important\",\n    padding: \"1rem 0.5rem !important\",\n    paddingBottom: \".4rem\",\n  },\n  headerCell: {\n    position: \"relative\",\n    borderBottom: \"0 !important\",\n    height: \"140px !important\",\n    whiteSpace: \"nowrap\",\n    textAlign: \"center !important\",\n    verticalAlign: \"bottom !important\",\n    padding: \"1rem 0.5rem !important\",\n  },\n  overallCell: {\n    border: \"0 !important\",\n    textAlign: \"center !important\",\n    paddingTop: \"1px !important\",\n    paddingBottom: \"1px !important\",\n    paddingLeft: \"1px !important\",\n    paddingRight: \"10px !important\",\n  },\n  cell: {\n    border: \"0 !important\",\n    height: \"20px !important\",\n    textAlign: \"center !important\",\n    padding: \"1px 1px !important\",\n    \"&:last-child\": {\n      paddingRight: 0,\n    },\n  },\n  colorSpan: {\n    display: \"block\",\n    height: \"20px\",\n    border: \"1px solid #eeefef\",\n  },\n  nameCell: {\n    border: \"0 !important\",\n    // width: '20%',\n    padding: \"0 0.5rem 0 0 !important\",\n    \"&:first-child\": {\n      paddingLeft: \"0 !important\",\n    },\n  },\n  nameContainer: {\n    display: \"block\",\n    textAlign: \"end !important\",\n    textOverflow: \"ellipsis\",\n    overflow: \"hidden\",\n  },\n});\n\nconst id = \"string\";\nconst index = 0;\nconst size = 3000;\nconst color = scaleQuantize().domain([0, 1]).range(colorRange);\n\nconst getScoreForColumn = (evidences, evidencesId) =>\n  evidences\n    .filter((e) => e.interactionDetectionMethodShortName === evidencesId)\n    .map((e) => e.evidenceScore)[0]; // TODO: the [0] is to catch a data error: remove when fixed.\nconst getHeatmapCell = (score, classes) => (\n  <span\n    className={classes.colorSpan}\n    title={score || \"No data\"}\n    style={{ backgroundColor: color(score) }}\n  />\n);\n\nfunction getColumns(classes) {\n  return [\n    {\n      id: \"partner\",\n      label: <>Interactor B</>,\n      classes: {\n        headerCell: classes.nameHeaderCell,\n        cell: classes.nameCell,\n      },\n      renderCell: (row) => (\n        <span className={classes.nameContainer}>\n          {row.targetB ? (\n            <Link asyncTooltip to={`/target/${row.targetB.id}`}>\n              {row.targetB.approvedSymbol}\n            </Link>\n          ) : (\n            <Link to={`http://uniprot.org/uniprot/${row.intB}`} external>\n              {row.intB}\n            </Link>\n          )}\n        </span>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n    },\n    {\n      id: \"overallScore\",\n      label: (\n        <>\n          Overall\n          <br />\n          interaction score\n        </>\n      ),\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => row.score.toFixed(3),\n      exportValue: (row) => row.score.toFixed(3),\n      filterValue: (row) => row.score.toFixed(3),\n    },\n    {\n      id: \"neighbourhood\",\n      label: \"Neighbourhood\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) =>\n        getHeatmapCell(getScoreForColumn(row.evidences, \"neighborhood\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"neighborhood\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"neighborhood\")?.toFixed(3),\n    },\n    {\n      id: \"geneFusion\",\n      label: \"Gene fusion\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"fusion\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"fusion\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"fusion\")?.toFixed(3),\n    },\n    {\n      id: \"occurance\",\n      label: \"Co-occurrance\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"cooccurence\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"cooccurence\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"cooccurence\")?.toFixed(3),\n    },\n    {\n      id: \"expression\",\n      label: \"Co-expression\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) =>\n        getHeatmapCell(getScoreForColumn(row.evidences, \"coexpression\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"coexpression\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"coexpression\")?.toFixed(3),\n    },\n    {\n      id: \"experiments\",\n      label: \"Experiments\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) =>\n        getHeatmapCell(getScoreForColumn(row.evidences, \"experimental\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"experimental\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"experimental\")?.toFixed(3),\n    },\n    {\n      id: \"databases\",\n      label: \"Databases\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"database\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"database\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"database\")?.toFixed(3),\n    },\n    {\n      id: \"textMining\",\n      label: \"Text mining\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"textmining\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"textmining\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"textmining\")?.toFixed(3),\n    },\n    {\n      id: \"homology\",\n      label: \"Homology\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"homology\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"homology\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"homology\")?.toFixed(3),\n    },\n  ];\n}\n\nfunction StringTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const classes = useStyles();\n  const columns = getColumns(classes);\n  const client = useApolloClient();\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n      }\n    });\n  }, [ensgId]);\n\n  return (\n    <Grid container spacing={4}>\n      <Grid item xs={12}>\n        {/* table 1: this is the only table and will need to be a HEATMAP */}\n        <OtTable\n          showGlobalFilter\n          columns={columns}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-string`}\n          fixed\n          classes={{ root: classes.root, table: classes.table }}\n          loading={loading}\n        />\n        <Legend url=\"https://string-db.org/cgi/info\" />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default StringTab;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/MolecularInteractions/StringTab.jsx" },
        "span": [8441, 8450],
        "sourceCode": "import { Grid } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { colorRange } from \"@ot/constants\";\nimport { scaleQuantize } from \"d3\";\nimport { useEffect, useState } from \"react\";\nimport { Legend, Link, OtTable, useApolloClient } from \"ui\";\n\nimport INTERACTIONS_QUERY from \"./InteractionsStringQuery.gql\";\n\nconst getData = (query, ensgId, sourceDatabase, index, size, client) =>\n  client.query({\n    query,\n    variables: {\n      ensgId,\n      sourceDatabase,\n      index,\n      size,\n    },\n  });\n\nconst useStyles = makeStyles({\n  root: {\n    overflow: \"visible\",\n    padding: \"2rem 3rem 0 0 !important\",\n  },\n  table: {\n    tableLayout: \"fixed !important\",\n  },\n  sortLabel: {\n    top: \"8px\",\n  },\n  innerLabel: {\n    position: \"absolute\",\n    display: \"inline-block\",\n    transformOrigin: \"-20px 20px\",\n    bottom: 0,\n    transform: \"rotate(315deg)\",\n    marginBottom: \"5px\",\n  },\n  nameHeaderCell: {\n    width: \"15%\",\n    borderBottom: \"0 !important\",\n    height: \"140px !important\",\n    verticalAlign: \"bottom !important\",\n    textAlign: \"end !important\",\n    padding: \"1rem 0.5rem !important\",\n    paddingBottom: \".4rem\",\n  },\n  headerCell: {\n    position: \"relative\",\n    borderBottom: \"0 !important\",\n    height: \"140px !important\",\n    whiteSpace: \"nowrap\",\n    textAlign: \"center !important\",\n    verticalAlign: \"bottom !important\",\n    padding: \"1rem 0.5rem !important\",\n  },\n  overallCell: {\n    border: \"0 !important\",\n    textAlign: \"center !important\",\n    paddingTop: \"1px !important\",\n    paddingBottom: \"1px !important\",\n    paddingLeft: \"1px !important\",\n    paddingRight: \"10px !important\",\n  },\n  cell: {\n    border: \"0 !important\",\n    height: \"20px !important\",\n    textAlign: \"center !important\",\n    padding: \"1px 1px !important\",\n    \"&:last-child\": {\n      paddingRight: 0,\n    },\n  },\n  colorSpan: {\n    display: \"block\",\n    height: \"20px\",\n    border: \"1px solid #eeefef\",\n  },\n  nameCell: {\n    border: \"0 !important\",\n    // width: '20%',\n    padding: \"0 0.5rem 0 0 !important\",\n    \"&:first-child\": {\n      paddingLeft: \"0 !important\",\n    },\n  },\n  nameContainer: {\n    display: \"block\",\n    textAlign: \"end !important\",\n    textOverflow: \"ellipsis\",\n    overflow: \"hidden\",\n  },\n});\n\nconst id = \"string\";\nconst index = 0;\nconst size = 3000;\nconst color = scaleQuantize().domain([0, 1]).range(colorRange);\n\nconst getScoreForColumn = (evidences, evidencesId) =>\n  evidences\n    .filter((e) => e.interactionDetectionMethodShortName === evidencesId)\n    .map((e) => e.evidenceScore)[0]; // TODO: the [0] is to catch a data error: remove when fixed.\nconst getHeatmapCell = (score, classes) => (\n  <span\n    className={classes.colorSpan}\n    title={score || \"No data\"}\n    style={{ backgroundColor: color(score) }}\n  />\n);\n\nfunction getColumns(classes) {\n  return [\n    {\n      id: \"partner\",\n      label: <>Interactor B</>,\n      classes: {\n        headerCell: classes.nameHeaderCell,\n        cell: classes.nameCell,\n      },\n      renderCell: (row) => (\n        <span className={classes.nameContainer}>\n          {row.targetB ? (\n            <Link asyncTooltip to={`/target/${row.targetB.id}`}>\n              {row.targetB.approvedSymbol}\n            </Link>\n          ) : (\n            <Link to={`http://uniprot.org/uniprot/${row.intB}`} external>\n              {row.intB}\n            </Link>\n          )}\n        </span>\n      ),\n      exportValue: (row) => row.targetB?.approvedSymbol || row.intB,\n      filterValue: (row) => `${row.targetB?.approvedSymbol} ${row.intB}`,\n    },\n    {\n      id: \"overallScore\",\n      label: (\n        <>\n          Overall\n          <br />\n          interaction score\n        </>\n      ),\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => row.score.toFixed(3),\n      exportValue: (row) => row.score.toFixed(3),\n      filterValue: (row) => row.score.toFixed(3),\n    },\n    {\n      id: \"neighbourhood\",\n      label: \"Neighbourhood\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) =>\n        getHeatmapCell(getScoreForColumn(row.evidences, \"neighborhood\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"neighborhood\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"neighborhood\")?.toFixed(3),\n    },\n    {\n      id: \"geneFusion\",\n      label: \"Gene fusion\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"fusion\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"fusion\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"fusion\")?.toFixed(3),\n    },\n    {\n      id: \"occurance\",\n      label: \"Co-occurrance\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"cooccurence\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"cooccurence\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"cooccurence\")?.toFixed(3),\n    },\n    {\n      id: \"expression\",\n      label: \"Co-expression\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) =>\n        getHeatmapCell(getScoreForColumn(row.evidences, \"coexpression\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"coexpression\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"coexpression\")?.toFixed(3),\n    },\n    {\n      id: \"experiments\",\n      label: \"Experiments\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) =>\n        getHeatmapCell(getScoreForColumn(row.evidences, \"experimental\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"experimental\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"experimental\")?.toFixed(3),\n    },\n    {\n      id: \"databases\",\n      label: \"Databases\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"database\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"database\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"database\")?.toFixed(3),\n    },\n    {\n      id: \"textMining\",\n      label: \"Text mining\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"textmining\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"textmining\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"textmining\")?.toFixed(3),\n    },\n    {\n      id: \"homology\",\n      label: \"Homology\",\n      classes: {\n        headerCell: classes.headerCell,\n        cell: classes.cell,\n        sortLabel: classes.sortLabel,\n        innerLabel: classes.innerLabel,\n      },\n      renderCell: (row) => getHeatmapCell(getScoreForColumn(row.evidences, \"homology\"), classes),\n      exportValue: (row) => getScoreForColumn(row.evidences, \"homology\")?.toFixed(3),\n      filterValue: (row) => getScoreForColumn(row.evidences, \"homology\")?.toFixed(3),\n    },\n  ];\n}\n\nfunction StringTab({ ensgId, symbol }) {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const classes = useStyles();\n  const columns = getColumns(classes);\n  const client = useApolloClient();\n  // load tab data when new tab selected (also on first load)\n  useEffect(() => {\n    setLoading(true);\n    getData(INTERACTIONS_QUERY, ensgId, id, index, size, client).then((res) => {\n      if (res.data.target.interactions) {\n        setLoading(false);\n        setData(res.data.target.interactions.rows);\n      }\n    });\n  }, [ensgId]);\n\n  return (\n    <Grid container spacing={4}>\n      <Grid item xs={12}>\n        {/* table 1: this is the only table and will need to be a HEATMAP */}\n        <OtTable\n          showGlobalFilter\n          columns={columns}\n          rows={data}\n          dataDownloader\n          dataDownloaderFileStem={`${symbol}-molecular-interactions-string`}\n          fixed\n          classes={{ root: classes.root, table: classes.table }}\n          loading={loading}\n        />\n        <Legend url=\"https://string-db.org/cgi/info\" />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default StringTab;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [4481, 4486],
              "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { makeStyles } from \"@mui/styles\";\nimport classNames from \"classnames\";\nimport { LabelChip, Link, OtTable, PublicationsDrawer, SectionItem, Tooltip } from \"ui\";\n\nimport { faCircleXmark } from \"@fortawesome/free-regular-svg-icons\";\nimport { faCircleCheck } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box } from \"@mui/material\";\nimport { PHARM_GKB_COLOR, naLabel, variantConsequenceSource } from \"@ot/constants\";\nimport { epmcUrl, identifiersOrgLink, sentenceCase } from \"@ot/utils\";\n\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PHARMACOGENOMICS_QUERY from \"./Pharmacogenomics.gql\";\n\nconst useStyles = makeStyles((theme) => ({\n  level: {\n    color: \"white\",\n    padding: theme.spacing(0.5),\n    borderRadius: theme.spacing(0.5),\n  },\n  green: {\n    background: PHARM_GKB_COLOR.green,\n  },\n  red: {\n    background: PHARM_GKB_COLOR.red,\n  },\n  yellow: {\n    background: PHARM_GKB_COLOR.yellow,\n  },\n  blue: {\n    background: theme.palette.primary.main,\n  },\n  blueIcon: {\n    color: theme.palette.primary.main,\n  },\n}));\n\nconst getLevelElementClassName = (level) => {\n  switch (level) {\n    case \"1\":\n      return \"green\";\n    case \"1A\":\n      return \"green\";\n    case \"1B\":\n      return \"green\";\n    case \"2\":\n      return \"blue\";\n    case \"2A\":\n      return \"blue\";\n    case \"2B\":\n      return \"blue\";\n    case \"3\":\n      return \"yellow\";\n    case \"4\":\n      return \"red\";\n    default:\n      return \"red\";\n  }\n};\n\nfunction getColumns(classes) {\n  return [\n    {\n      id: \"variantRsId\",\n      label: \"rsID\",\n      enableHiding: false,\n      renderCell: ({ variantRsId }) =>\n        variantRsId ? (\n          <Link\n            external\n            to={`http://www.ensembl.org/Homo_sapiens/Variation/Explore?v=${variantRsId}`}\n          >\n            {variantRsId}\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"starAllele\",\n      label: \"Star Allele\",\n      renderCell: ({ haplotypeId, haplotypeFromSourceId }) => {\n        const displayId = haplotypeId || haplotypeFromSourceId || naLabel;\n        const LinkComponent = haplotypeFromSourceId && (\n          <Link external to={`https://www.pharmgkb.org/haplotype/${haplotypeFromSourceId}`}>\n            {displayId}\n          </Link>\n        );\n\n        return LinkComponent || displayId || naLabel;\n      },\n    },\n    {\n      id: \"genotypeId\",\n      label: \"Genotype ID\",\n      tooltip: (\n        <>\n          VCF-style(chr_pos_ref_allele1,allele2). See{\" \"}\n          <Link\n            external\n            to=\"https://github.com/apriltuesday/opentargets-pharmgkb/tree/issue-18#variant-coordinate-computation\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      renderCell: ({ genotypeId }) => genotypeId || naLabel,\n    },\n    {\n      id: \"variantConsequence\",\n      label: \"Variant Consequence\",\n      renderCell: ({ variantFunctionalConsequence, genotypeId }) => {\n        const pvparams = genotypeId?.split(\",\")[0].split(\"_\") || [];\n        return (\n          <div style={{ display: \"flex\", gap: \"5px\" }}>\n            {variantFunctionalConsequence ? (\n              <LabelChip\n                label={variantConsequenceSource.VEP.label}\n                value={sentenceCase(variantFunctionalConsequence.label)}\n                tooltip={variantConsequenceSource.VEP.tooltip}\n                to={identifiersOrgLink(\"SO\", variantFunctionalConsequence.id.slice(3))}\n              />\n            ) : (\n              naLabel\n            )}\n            {(variantFunctionalConsequence?.id === \"SO:0001583\" ||\n              variantFunctionalConsequence?.id === \"SO:0001587\") && (\n              <LabelChip\n                label={variantConsequenceSource.ProtVar.label}\n                to={`https://www.ebi.ac.uk/ProtVar/query?chromosome=${pvparams[0]}&genomic_position=${pvparams[1]}&reference_allele=${pvparams[2]}&alternative_allele=${pvparams[3]}`}\n                tooltip={variantConsequenceSource.ProtVar.tooltip}\n              />\n            )}\n          </div>\n        );\n      },\n      filterValue: ({ variantFunctionalConsequence }) =>\n        `${sentenceCase(variantFunctionalConsequence?.label)}`,\n    },\n    {\n      id: \"drug\",\n      label: \"Drug(s)\",\n      renderCell: ({ drugs }) => {\n        if (!drugs || drugs.length <= 0) return naLabel;\n\n        return drugs.map((el, index) => {\n          if (el.drugId)\n            return (\n              <Box sx={{ display: \"inline\" }} key={index}>\n                {index > 0 && <Box sx={{ pr: 0.5, display: \"inline \" }}>,</Box>}\n                <Link asyncTooltip to={`/drug/${el.drugId}`}>\n                  {el.drugFromSource || el.drugId}\n                </Link>\n              </Box>\n            );\n          return el.drugFromSource || el.drugId;\n        });\n      },\n      filterValue: ({ drugId, drugFromSource }) => `${drugFromSource} ${drugId}`,\n    },\n    {\n      id: \"drugResponse\",\n      label: \"Drug Response Phenotype\",\n      renderCell: ({ phenotypeText = naLabel, phenotypeFromSourceId, genotypeAnnotationText }) => {\n        let phenotypeTextElement;\n\n        if (phenotypeText) {\n          phenotypeTextElement = phenotypeText;\n        } else phenotypeTextElement = naLabel;\n\n        if (phenotypeFromSourceId)\n          phenotypeTextElement = (\n            <Link to={`/disease/${phenotypeFromSourceId}`}>{phenotypeTextElement}</Link>\n          );\n\n        if (genotypeAnnotationText)\n          phenotypeTextElement = (\n            <Tooltip title={genotypeAnnotationText} showHelpIcon>\n              {phenotypeTextElement}\n            </Tooltip>\n          );\n\n        return phenotypeTextElement;\n      },\n      filterValue: ({ phenotypeText }) => `${phenotypeText}`,\n    },\n    {\n      id: \"drugResponseCategory\",\n      label: \"Drug Response Category\",\n      renderCell: ({ pgxCategory }) => pgxCategory || naLabel,\n      filterValue: ({ pgxCategory }) => pgxCategory,\n    },\n    {\n      id: \"isDirectTarget\",\n      label: \"Direct Drug Target\",\n      renderCell: ({ isDirectTarget }) => {\n        const ICON_NAME = isDirectTarget ? faCircleCheck : faCircleXmark;\n        return <FontAwesomeIcon icon={ICON_NAME} size=\"lg\" className={classes.blueIcon} />;\n      },\n    },\n    {\n      id: \"evidenceLevel\",\n      label: \"Confidence Level\",\n      comparator: (a, b) => (b.evidenceLevel < a.evidenceLevel ? 1 : -1),\n      sortable: true,\n      tooltip: (\n        <>\n          As defined by\n          <Link external to={\"https://www.pharmgkb.org/page/clinAnnLevels\"}>\n            {\" \"}\n            PharmGKB ClinAnn Levels\n          </Link>\n        </>\n      ),\n      renderCell: ({ evidenceLevel }) => {\n        if (evidenceLevel) {\n          const levelClass = getLevelElementClassName(evidenceLevel);\n          return (\n            <span className={classNames(classes.level, classes[levelClass])}>\n              Level {evidenceLevel}\n            </span>\n          );\n        }\n        return naLabel;\n      },\n      filterValue: ({ evidenceLevel }) => `Level ${evidenceLevel}`,\n    },\n    {\n      id: \"source\",\n      label: \"Source\",\n      renderCell: ({ studyId }) =>\n        studyId ? (\n          <Link external to={`https://www.pharmgkb.org/clinicalAnnotation/${studyId}`}>\n            PharmGKB\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"literature\",\n      label: \"Literature\",\n      renderCell: ({ literature }) => {\n        const literatureList =\n          literature?.reduce((acc, id) => {\n            if (id === \"NA\") return acc;\n\n            return [\n              ...acc,\n              {\n                name: id,\n                url: epmcUrl(id),\n                group: \"literature\",\n              },\n            ];\n          }, []) || [];\n\n        return <PublicationsDrawer entries={literatureList} />;\n      },\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const classes = useStyles();\n  const columns = getColumns(classes);\n  const variables = { ensemblId };\n  const request = useQuery(PHARMACOGENOMICS_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => (\n        <OtTable\n          showGlobalFilter\n          dataDownloader\n          sortBy=\"evidenceLevel\"\n          columns={columns}\n          rows={request.data?.target.pharmacogenomics}\n          query={PHARMACOGENOMICS_QUERY.loc.source.body}\n          variables={variables}\n          loading={request.loading}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Pharmacogenomics/Body.jsx" },
        "span": [4590, 4595],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { makeStyles } from \"@mui/styles\";\nimport classNames from \"classnames\";\nimport { LabelChip, Link, OtTable, PublicationsDrawer, SectionItem, Tooltip } from \"ui\";\n\nimport { faCircleXmark } from \"@fortawesome/free-regular-svg-icons\";\nimport { faCircleCheck } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box } from \"@mui/material\";\nimport { PHARM_GKB_COLOR, naLabel, variantConsequenceSource } from \"@ot/constants\";\nimport { epmcUrl, identifiersOrgLink, sentenceCase } from \"@ot/utils\";\n\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PHARMACOGENOMICS_QUERY from \"./Pharmacogenomics.gql\";\n\nconst useStyles = makeStyles((theme) => ({\n  level: {\n    color: \"white\",\n    padding: theme.spacing(0.5),\n    borderRadius: theme.spacing(0.5),\n  },\n  green: {\n    background: PHARM_GKB_COLOR.green,\n  },\n  red: {\n    background: PHARM_GKB_COLOR.red,\n  },\n  yellow: {\n    background: PHARM_GKB_COLOR.yellow,\n  },\n  blue: {\n    background: theme.palette.primary.main,\n  },\n  blueIcon: {\n    color: theme.palette.primary.main,\n  },\n}));\n\nconst getLevelElementClassName = (level) => {\n  switch (level) {\n    case \"1\":\n      return \"green\";\n    case \"1A\":\n      return \"green\";\n    case \"1B\":\n      return \"green\";\n    case \"2\":\n      return \"blue\";\n    case \"2A\":\n      return \"blue\";\n    case \"2B\":\n      return \"blue\";\n    case \"3\":\n      return \"yellow\";\n    case \"4\":\n      return \"red\";\n    default:\n      return \"red\";\n  }\n};\n\nfunction getColumns(classes) {\n  return [\n    {\n      id: \"variantRsId\",\n      label: \"rsID\",\n      enableHiding: false,\n      renderCell: ({ variantRsId }) =>\n        variantRsId ? (\n          <Link\n            external\n            to={`http://www.ensembl.org/Homo_sapiens/Variation/Explore?v=${variantRsId}`}\n          >\n            {variantRsId}\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"starAllele\",\n      label: \"Star Allele\",\n      renderCell: ({ haplotypeId, haplotypeFromSourceId }) => {\n        const displayId = haplotypeId || haplotypeFromSourceId || naLabel;\n        const LinkComponent = haplotypeFromSourceId && (\n          <Link external to={`https://www.pharmgkb.org/haplotype/${haplotypeFromSourceId}`}>\n            {displayId}\n          </Link>\n        );\n\n        return LinkComponent || displayId || naLabel;\n      },\n    },\n    {\n      id: \"genotypeId\",\n      label: \"Genotype ID\",\n      tooltip: (\n        <>\n          VCF-style(chr_pos_ref_allele1,allele2). See{\" \"}\n          <Link\n            external\n            to=\"https://github.com/apriltuesday/opentargets-pharmgkb/tree/issue-18#variant-coordinate-computation\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      renderCell: ({ genotypeId }) => genotypeId || naLabel,\n    },\n    {\n      id: \"variantConsequence\",\n      label: \"Variant Consequence\",\n      renderCell: ({ variantFunctionalConsequence, genotypeId }) => {\n        const pvparams = genotypeId?.split(\",\")[0].split(\"_\") || [];\n        return (\n          <div style={{ display: \"flex\", gap: \"5px\" }}>\n            {variantFunctionalConsequence ? (\n              <LabelChip\n                label={variantConsequenceSource.VEP.label}\n                value={sentenceCase(variantFunctionalConsequence.label)}\n                tooltip={variantConsequenceSource.VEP.tooltip}\n                to={identifiersOrgLink(\"SO\", variantFunctionalConsequence.id.slice(3))}\n              />\n            ) : (\n              naLabel\n            )}\n            {(variantFunctionalConsequence?.id === \"SO:0001583\" ||\n              variantFunctionalConsequence?.id === \"SO:0001587\") && (\n              <LabelChip\n                label={variantConsequenceSource.ProtVar.label}\n                to={`https://www.ebi.ac.uk/ProtVar/query?chromosome=${pvparams[0]}&genomic_position=${pvparams[1]}&reference_allele=${pvparams[2]}&alternative_allele=${pvparams[3]}`}\n                tooltip={variantConsequenceSource.ProtVar.tooltip}\n              />\n            )}\n          </div>\n        );\n      },\n      filterValue: ({ variantFunctionalConsequence }) =>\n        `${sentenceCase(variantFunctionalConsequence?.label)}`,\n    },\n    {\n      id: \"drug\",\n      label: \"Drug(s)\",\n      renderCell: ({ drugs }) => {\n        if (!drugs || drugs.length <= 0) return naLabel;\n\n        return drugs.map((el, index) => {\n          if (el.drugId)\n            return (\n              <Box sx={{ display: \"inline\" }} key={index}>\n                {index > 0 && <Box sx={{ pr: 0.5, display: \"inline \" }}>,</Box>}\n                <Link asyncTooltip to={`/drug/${el.drugId}`}>\n                  {el.drugFromSource || el.drugId}\n                </Link>\n              </Box>\n            );\n          return el.drugFromSource || el.drugId;\n        });\n      },\n      filterValue: ({ drugId, drugFromSource }) => `${drugFromSource} ${drugId}`,\n    },\n    {\n      id: \"drugResponse\",\n      label: \"Drug Response Phenotype\",\n      renderCell: ({ phenotypeText = naLabel, phenotypeFromSourceId, genotypeAnnotationText }) => {\n        let phenotypeTextElement;\n\n        if (phenotypeText) {\n          phenotypeTextElement = phenotypeText;\n        } else phenotypeTextElement = naLabel;\n\n        if (phenotypeFromSourceId)\n          phenotypeTextElement = (\n            <Link to={`/disease/${phenotypeFromSourceId}`}>{phenotypeTextElement}</Link>\n          );\n\n        if (genotypeAnnotationText)\n          phenotypeTextElement = (\n            <Tooltip title={genotypeAnnotationText} showHelpIcon>\n              {phenotypeTextElement}\n            </Tooltip>\n          );\n\n        return phenotypeTextElement;\n      },\n      filterValue: ({ phenotypeText }) => `${phenotypeText}`,\n    },\n    {\n      id: \"drugResponseCategory\",\n      label: \"Drug Response Category\",\n      renderCell: ({ pgxCategory }) => pgxCategory || naLabel,\n      filterValue: ({ pgxCategory }) => pgxCategory,\n    },\n    {\n      id: \"isDirectTarget\",\n      label: \"Direct Drug Target\",\n      renderCell: ({ isDirectTarget }) => {\n        const ICON_NAME = isDirectTarget ? faCircleCheck : faCircleXmark;\n        return <FontAwesomeIcon icon={ICON_NAME} size=\"lg\" className={classes.blueIcon} />;\n      },\n    },\n    {\n      id: \"evidenceLevel\",\n      label: \"Confidence Level\",\n      comparator: (a, b) => (b.evidenceLevel < a.evidenceLevel ? 1 : -1),\n      sortable: true,\n      tooltip: (\n        <>\n          As defined by\n          <Link external to={\"https://www.pharmgkb.org/page/clinAnnLevels\"}>\n            {\" \"}\n            PharmGKB ClinAnn Levels\n          </Link>\n        </>\n      ),\n      renderCell: ({ evidenceLevel }) => {\n        if (evidenceLevel) {\n          const levelClass = getLevelElementClassName(evidenceLevel);\n          return (\n            <span className={classNames(classes.level, classes[levelClass])}>\n              Level {evidenceLevel}\n            </span>\n          );\n        }\n        return naLabel;\n      },\n      filterValue: ({ evidenceLevel }) => `Level ${evidenceLevel}`,\n    },\n    {\n      id: \"source\",\n      label: \"Source\",\n      renderCell: ({ studyId }) =>\n        studyId ? (\n          <Link external to={`https://www.pharmgkb.org/clinicalAnnotation/${studyId}`}>\n            PharmGKB\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"literature\",\n      label: \"Literature\",\n      renderCell: ({ literature }) => {\n        const literatureList =\n          literature?.reduce((acc, id) => {\n            if (id === \"NA\") return acc;\n\n            return [\n              ...acc,\n              {\n                name: id,\n                url: epmcUrl(id),\n                group: \"literature\",\n              },\n            ];\n          }, []) || [];\n\n        return <PublicationsDrawer entries={literatureList} />;\n      },\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const classes = useStyles();\n  const columns = getColumns(classes);\n  const variables = { ensemblId };\n  const request = useQuery(PHARMACOGENOMICS_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => (\n        <OtTable\n          showGlobalFilter\n          dataDownloader\n          sortBy=\"evidenceLevel\"\n          columns={columns}\n          rows={request.data?.target.pharmacogenomics}\n          query={PHARMACOGENOMICS_QUERY.loc.source.body}\n          variables={variables}\n          loading={request.loading}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/Pharmacogenomics/Body.jsx" },
        "span": [7679, 7685],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { makeStyles } from \"@mui/styles\";\nimport classNames from \"classnames\";\nimport { LabelChip, Link, OtTable, PublicationsDrawer, SectionItem, Tooltip } from \"ui\";\n\nimport { faCircleXmark } from \"@fortawesome/free-regular-svg-icons\";\nimport { faCircleCheck } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box } from \"@mui/material\";\nimport { PHARM_GKB_COLOR, naLabel, variantConsequenceSource } from \"@ot/constants\";\nimport { epmcUrl, identifiersOrgLink, sentenceCase } from \"@ot/utils\";\n\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PHARMACOGENOMICS_QUERY from \"./Pharmacogenomics.gql\";\n\nconst useStyles = makeStyles((theme) => ({\n  level: {\n    color: \"white\",\n    padding: theme.spacing(0.5),\n    borderRadius: theme.spacing(0.5),\n  },\n  green: {\n    background: PHARM_GKB_COLOR.green,\n  },\n  red: {\n    background: PHARM_GKB_COLOR.red,\n  },\n  yellow: {\n    background: PHARM_GKB_COLOR.yellow,\n  },\n  blue: {\n    background: theme.palette.primary.main,\n  },\n  blueIcon: {\n    color: theme.palette.primary.main,\n  },\n}));\n\nconst getLevelElementClassName = (level) => {\n  switch (level) {\n    case \"1\":\n      return \"green\";\n    case \"1A\":\n      return \"green\";\n    case \"1B\":\n      return \"green\";\n    case \"2\":\n      return \"blue\";\n    case \"2A\":\n      return \"blue\";\n    case \"2B\":\n      return \"blue\";\n    case \"3\":\n      return \"yellow\";\n    case \"4\":\n      return \"red\";\n    default:\n      return \"red\";\n  }\n};\n\nfunction getColumns(classes) {\n  return [\n    {\n      id: \"variantRsId\",\n      label: \"rsID\",\n      enableHiding: false,\n      renderCell: ({ variantRsId }) =>\n        variantRsId ? (\n          <Link\n            external\n            to={`http://www.ensembl.org/Homo_sapiens/Variation/Explore?v=${variantRsId}`}\n          >\n            {variantRsId}\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"starAllele\",\n      label: \"Star Allele\",\n      renderCell: ({ haplotypeId, haplotypeFromSourceId }) => {\n        const displayId = haplotypeId || haplotypeFromSourceId || naLabel;\n        const LinkComponent = haplotypeFromSourceId && (\n          <Link external to={`https://www.pharmgkb.org/haplotype/${haplotypeFromSourceId}`}>\n            {displayId}\n          </Link>\n        );\n\n        return LinkComponent || displayId || naLabel;\n      },\n    },\n    {\n      id: \"genotypeId\",\n      label: \"Genotype ID\",\n      tooltip: (\n        <>\n          VCF-style(chr_pos_ref_allele1,allele2). See{\" \"}\n          <Link\n            external\n            to=\"https://github.com/apriltuesday/opentargets-pharmgkb/tree/issue-18#variant-coordinate-computation\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      renderCell: ({ genotypeId }) => genotypeId || naLabel,\n    },\n    {\n      id: \"variantConsequence\",\n      label: \"Variant Consequence\",\n      renderCell: ({ variantFunctionalConsequence, genotypeId }) => {\n        const pvparams = genotypeId?.split(\",\")[0].split(\"_\") || [];\n        return (\n          <div style={{ display: \"flex\", gap: \"5px\" }}>\n            {variantFunctionalConsequence ? (\n              <LabelChip\n                label={variantConsequenceSource.VEP.label}\n                value={sentenceCase(variantFunctionalConsequence.label)}\n                tooltip={variantConsequenceSource.VEP.tooltip}\n                to={identifiersOrgLink(\"SO\", variantFunctionalConsequence.id.slice(3))}\n              />\n            ) : (\n              naLabel\n            )}\n            {(variantFunctionalConsequence?.id === \"SO:0001583\" ||\n              variantFunctionalConsequence?.id === \"SO:0001587\") && (\n              <LabelChip\n                label={variantConsequenceSource.ProtVar.label}\n                to={`https://www.ebi.ac.uk/ProtVar/query?chromosome=${pvparams[0]}&genomic_position=${pvparams[1]}&reference_allele=${pvparams[2]}&alternative_allele=${pvparams[3]}`}\n                tooltip={variantConsequenceSource.ProtVar.tooltip}\n              />\n            )}\n          </div>\n        );\n      },\n      filterValue: ({ variantFunctionalConsequence }) =>\n        `${sentenceCase(variantFunctionalConsequence?.label)}`,\n    },\n    {\n      id: \"drug\",\n      label: \"Drug(s)\",\n      renderCell: ({ drugs }) => {\n        if (!drugs || drugs.length <= 0) return naLabel;\n\n        return drugs.map((el, index) => {\n          if (el.drugId)\n            return (\n              <Box sx={{ display: \"inline\" }} key={index}>\n                {index > 0 && <Box sx={{ pr: 0.5, display: \"inline \" }}>,</Box>}\n                <Link asyncTooltip to={`/drug/${el.drugId}`}>\n                  {el.drugFromSource || el.drugId}\n                </Link>\n              </Box>\n            );\n          return el.drugFromSource || el.drugId;\n        });\n      },\n      filterValue: ({ drugId, drugFromSource }) => `${drugFromSource} ${drugId}`,\n    },\n    {\n      id: \"drugResponse\",\n      label: \"Drug Response Phenotype\",\n      renderCell: ({ phenotypeText = naLabel, phenotypeFromSourceId, genotypeAnnotationText }) => {\n        let phenotypeTextElement;\n\n        if (phenotypeText) {\n          phenotypeTextElement = phenotypeText;\n        } else phenotypeTextElement = naLabel;\n\n        if (phenotypeFromSourceId)\n          phenotypeTextElement = (\n            <Link to={`/disease/${phenotypeFromSourceId}`}>{phenotypeTextElement}</Link>\n          );\n\n        if (genotypeAnnotationText)\n          phenotypeTextElement = (\n            <Tooltip title={genotypeAnnotationText} showHelpIcon>\n              {phenotypeTextElement}\n            </Tooltip>\n          );\n\n        return phenotypeTextElement;\n      },\n      filterValue: ({ phenotypeText }) => `${phenotypeText}`,\n    },\n    {\n      id: \"drugResponseCategory\",\n      label: \"Drug Response Category\",\n      renderCell: ({ pgxCategory }) => pgxCategory || naLabel,\n      filterValue: ({ pgxCategory }) => pgxCategory,\n    },\n    {\n      id: \"isDirectTarget\",\n      label: \"Direct Drug Target\",\n      renderCell: ({ isDirectTarget }) => {\n        const ICON_NAME = isDirectTarget ? faCircleCheck : faCircleXmark;\n        return <FontAwesomeIcon icon={ICON_NAME} size=\"lg\" className={classes.blueIcon} />;\n      },\n    },\n    {\n      id: \"evidenceLevel\",\n      label: \"Confidence Level\",\n      comparator: (a, b) => (b.evidenceLevel < a.evidenceLevel ? 1 : -1),\n      sortable: true,\n      tooltip: (\n        <>\n          As defined by\n          <Link external to={\"https://www.pharmgkb.org/page/clinAnnLevels\"}>\n            {\" \"}\n            PharmGKB ClinAnn Levels\n          </Link>\n        </>\n      ),\n      renderCell: ({ evidenceLevel }) => {\n        if (evidenceLevel) {\n          const levelClass = getLevelElementClassName(evidenceLevel);\n          return (\n            <span className={classNames(classes.level, classes[levelClass])}>\n              Level {evidenceLevel}\n            </span>\n          );\n        }\n        return naLabel;\n      },\n      filterValue: ({ evidenceLevel }) => `Level ${evidenceLevel}`,\n    },\n    {\n      id: \"source\",\n      label: \"Source\",\n      renderCell: ({ studyId }) =>\n        studyId ? (\n          <Link external to={`https://www.pharmgkb.org/clinicalAnnotation/${studyId}`}>\n            PharmGKB\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"literature\",\n      label: \"Literature\",\n      renderCell: ({ literature }) => {\n        const literatureList =\n          literature?.reduce((acc, id) => {\n            if (id === \"NA\") return acc;\n\n            return [\n              ...acc,\n              {\n                name: id,\n                url: epmcUrl(id),\n                group: \"literature\",\n              },\n            ];\n          }, []) || [];\n\n        return <PublicationsDrawer entries={literatureList} />;\n      },\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const classes = useStyles();\n  const columns = getColumns(classes);\n  const variables = { ensemblId };\n  const request = useQuery(PHARMACOGENOMICS_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => (\n        <OtTable\n          showGlobalFilter\n          dataDownloader\n          sortBy=\"evidenceLevel\"\n          columns={columns}\n          rows={request.data?.target.pharmacogenomics}\n          query={PHARMACOGENOMICS_QUERY.loc.source.body}\n          variables={variables}\n          loading={request.loading}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noBannedTypes",
      "severity": "error",
      "description": "Don't use '{}' as a type.",
      "message": [{ "elements": [], "content": "Don't use '{}' as a type." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Prefer explicitly define the object shape. '{}' means \"any non-nullable value\"."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/parseCif.ts" },
        "span": [797, 799],
        "sourceCode": "/*\nTakes a CIF string and returns the parsed data as an object with an entry for\neach data block in the file.\n\nNotes:\n  - all values in returned data are strings\n  - a loop in the CIF file has a property for each header in the data - the\n    value of the property is an array\n  - does not vaildate the CIF file - assumes it is valid\n  - no special handling of \"?\" for missing values or .\" for intentionally\n    omitted values (so these characters will appear as data values)\n  - does not handle square brackets - which can be used for same/similar purpose\n    to semicolons\n  - assumes each data block has a block code (i.e. name) but I think codes are\n    optional in CIF (i.e. can use just data_ for a block)\n*/\n\nexport function parseCif(cifString: string) {\n  const data = {};\n  let blockData: {};\n  let multilineMode = false;\n  let multilineName: null | string;\n  let multilineValue = \"\";\n  let loopMode = false;\n  let loopHeaders = [];\n  let loopData = [];\n  let loopRow = [];\n\n  function closeLoopIfOpen() {\n    if (loopMode) {\n      for (const header of loopHeaders) {\n        blockData[header] = [];\n      }\n      for (const row of loopData) {\n        for (const [index, header] of loopHeaders.entries()) {\n          blockData[header].push(row[index]);\n        }\n      }\n    }\n    loopMode = false;\n    loopHeaders = [];\n    loopData = [];\n    loopRow = [];\n  }\n\n  function splitLoopValues(line) {\n    const values = line.match(/(?:(?:[^\\s\"']+|'[^']+'|\"[^\"]+\"))+/g);\n    for (const [index, value] of values.entries()) {\n      if (value[0] === \"'\" || value[0] === '\"') {\n        values[index] = value.slice(1, -1);\n      }\n    }\n    return values;\n  }\n\n  function addLoopRowIfComplete() {\n    if (loopRow.length === loopHeaders.length) {\n      loopData.push(loopRow);\n      loopRow = [];\n    }\n  }\n\n  const lines = cifString.split(/\\r?\\n/);\n\n  for (let line of lines) {\n    // inside multiline value\n    if (multilineMode) {\n      if (line.startsWith(\";\")) {\n        // close mulitline\n        if (loopMode) {\n          loopRow.push(multilineValue);\n          addLoopRowIfComplete();\n        } else {\n          blockData[multilineName] = multilineValue;\n        }\n        multilineMode = false;\n        multilineName = null;\n        multilineValue = \"\";\n      } else {\n        // add to multiline value\n        multilineValue += line;\n      }\n      continue;\n    }\n\n    // open multiline value\n    if (line.startsWith(\";\")) {\n      multilineMode = true;\n      multilineValue = line.slice(1);\n      continue;\n    }\n\n    // new block\n    if (line.startsWith(\"data_\")) {\n      closeLoopIfOpen();\n      blockData = {};\n      data[line.replace(\"data_\", \"\")] = blockData;\n      continue;\n    }\n\n    // can safely trim whitespace now\n    line = line.trim();\n\n    // skip empty and comment lines\n    if (!line || line.startsWith(\"#\")) {\n      continue;\n    }\n\n    if (line.startsWith(\"_\")) {\n      if (loopMode && loopData.length === 0) {\n        loopHeaders.push(line);\n      } else {\n        // field - split at first space only since field value could be quoted with spaces\n        closeLoopIfOpen();\n        const firstSpace = line.search(/\\s+/);\n        const fieldName = line.slice(0, firstSpace);\n        let fieldValue = line.slice(firstSpace).trim();\n        if (fieldValue) {\n          const [start, end] = [fieldValue[0], fieldValue.at(-1)];\n          if ((start === '\"' && end === '\"') || (start === \"'\" && end === \"'\")) {\n            fieldValue = fieldValue.slice(1, -1);\n          }\n          blockData[fieldName] = fieldValue;\n        } else {\n          // multilinemode will be set to true next line\n          multilineName = fieldName;\n        }\n      }\n      continue;\n    }\n\n    // open loop\n    if (line.startsWith(\"loop_\")) {\n      closeLoopIfOpen();\n      loopMode = true;\n      continue;\n    }\n\n    // inside a loop\n    if (loopMode) {\n      // must be values since know line does not start with \"_\" or \"loop_\"\n      loopRow.push(...splitLoopValues(line));\n      addLoopRowIfComplete();\n    }\n  }\n\n  closeLoopIfOpen();\n\n  return data;\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/SubcellularLocation/SubcellularViz.jsx" },
        "span": [1461, 1645],
        "sourceCode": "import { faMapMarkerAlt } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, List, ListItem, Tab, Tabs, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { Suspense, lazy, useEffect, useRef, useState } from \"react\";\n\nimport { getUniprotIds, identifiersOrgLink } from \"@ot/utils\";\nimport { Link, LoadingBackdrop } from \"ui\";\n\nconst SwissbioViz =\n  \"customElements\" in window ? lazy(() => import(\"./SwissbioViz\")) : ({ children }) => children;\n\nconst useStyles = makeStyles((theme) => ({\n  locationIcon: {\n    paddingRight: \"0.5em\",\n  },\n  locationsList: {\n    cursor: \"pointer\",\n    fontWeight: \"bold\",\n    color: theme.palette.primary.main,\n    \"& .inpicture.lookedAt\": {\n      color: theme.palette.primary.dark,\n    },\n  },\n  tabPanel: {\n    marginTop: \"30px\",\n  },\n}));\n\n// Remove the 'SL-' from a location termSL (e.g. \"SL-0097\")\n// The sib-swissbiopics component (different from what is documented)\n// actually doesn't accept the \"SL-\" part of the term\nconst parseLocationTerm = (term) => term?.substring(3);\n\n// Parse termSL to specific id format used by the text for rollovers\nconst parseTermToTextId = (term) => (term ? `${term.replace(\"-\", \"\")}term` : \"\");\n\n// Parse API response and split locations based on sources. Example:\n// { HPA_main: [], uniprot: [], }\nconst parseLocationData = (subcellularLocations) => {\n  const sourcesLocations = {};\n  subcellularLocations.forEach((sl) => {\n    if (sourcesLocations[sl.source] === undefined) {\n      sourcesLocations[sl.source] = [];\n    }\n    sourcesLocations[sl.source].push(sl);\n  });\n  return sourcesLocations;\n};\n\n// Filter the sources array to only those with data\nconst filterSourcesWithData = (sources, sourcesLocations) =>\n  sources.filter((s) => sourcesLocations[s.id] !== undefined);\n\nconst getTabId = (id) => `${id}-tab`;\n\nfunction LocationLink({ sourceId, id }) {\n  return (\n    <Link external to={identifiersOrgLink(sourceId === \"uniprot\" ? \"uniprot\" : \"hpa\", id)}>\n      {id}\n    </Link>\n  );\n}\n\n/**\n * The text list of locations displayed to the right of the visualiztion\n */\nfunction LocationsList({ sls }) {\n  const classes = useStyles();\n  return (\n    <List className={classes.locationsList}>\n      {sls.map(({ location, termSL }) => (\n        <ListItem key={location} id={parseTermToTextId(termSL)}>\n          <span className={classes.locationIcon}>\n            <FontAwesomeIcon icon={faMapMarkerAlt} size=\"lg\" />\n          </span>\n          {location}\n        </ListItem>\n      ))}\n    </List>\n  );\n}\n\n/**\n * SubcellularVizTabs wraps the MUI tabs to separate the state and\n * trigger tab panels visibility on/off without using the state\n * as this crashes the swissbiopic widget - see note below\n * @param {*} sources the array of source to show in the tabs (i.e. those with data)\n */\nfunction SubcellularVizTabs({ sources: activeSources, children }) {\n  const [activeTab, setActiveTab] = useState(0);\n  const onTabChange = (_event, tabId) => {\n    setActiveTab(tabId);\n  };\n  useEffect(() => {\n    // update tab panels visibility: we change the style of the DOM element directly\n    // to avoid any re-rendering as that causes the swissbiopic component to crash\n    children.forEach((child) => {\n      child.ref.current.setAttribute(\"style\", \"display:none\");\n    });\n    children[activeTab].ref.current.setAttribute(\"style\", \"display:block\");\n  });\n\n  return (\n    <>\n      <Tabs value={activeTab} onChange={onTabChange} aria-label=\"Subcellular location sources\">\n        {activeSources.map((s, i) => (\n          <Tab label={s.label} value={i} key={s.id} />\n        ))}\n      </Tabs>\n      {children}\n    </>\n  );\n}\n\n/**\n * A wrapper for the SwissbioViz component\n * @param {*} data the target object as returned by the API\n */\nfunction SubcellularViz({ data: target }) {\n  const classes = useStyles();\n  // define the sources here so we can have call useRef() and then pass it to the tabs panels\n  const sources = [\n    {\n      id: \"HPA_main\",\n      label: \"HPA main location\",\n      ref: useRef(),\n    },\n    {\n      id: \"HPA_additional\",\n      label: \"HPA additional location\",\n      ref: useRef(),\n    },\n    {\n      id: \"HPA_extracellular_location\",\n      label: \"HPA extracellular location\",\n      ref: useRef(),\n    },\n    {\n      id: \"uniprot\",\n      label: \"UniProt\",\n      ref: useRef(),\n    },\n  ];\n  const uniprotId = getUniprotIds(target.proteinIds)[0];\n  const sourcesLocations = parseLocationData(target.subcellularLocations);\n  const activeSources = filterSourcesWithData(sources, sourcesLocations);\n\n  return (\n    <div>\n      <SubcellularVizTabs sources={activeSources}>\n        {activeSources.map((s) => (\n          <div\n            value={getTabId(s.id)}\n            id={getTabId(s.id)}\n            ref={s.ref}\n            key={s.id}\n            className={classes.tabPanel}\n          >\n            <Suspense fallback={<LoadingBackdrop />}>\n              <SwissbioViz\n                taxonId=\"9606\"\n                locationIds={sourcesLocations[s.id].map((l) => parseLocationTerm(l.termSL)).join()}\n                sourceId={s.id.toLowerCase()}\n              >\n                <Box ml={4} key={s.id}>\n                  <Typography variant=\"h6\">{s.label}</Typography>\n                  Location for{\" \"}\n                  <LocationLink sourceId={s.id} id={s.id === \"uniprot\" ? uniprotId : target.id} />\n                  <LocationsList sls={sourcesLocations[s.id]} />\n                </Box>\n              </SwissbioViz>\n            </Suspense>\n          </div>\n        ))}\n      </SubcellularVizTabs>\n    </div>\n  );\n}\n\nexport default SubcellularViz;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/SubcellularLocation/SubcellularViz.jsx" },
        "span": [3248, 3347],
        "sourceCode": "import { faMapMarkerAlt } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, List, ListItem, Tab, Tabs, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { Suspense, lazy, useEffect, useRef, useState } from \"react\";\n\nimport { getUniprotIds, identifiersOrgLink } from \"@ot/utils\";\nimport { Link, LoadingBackdrop } from \"ui\";\n\nconst SwissbioViz =\n  \"customElements\" in window ? lazy(() => import(\"./SwissbioViz\")) : ({ children }) => children;\n\nconst useStyles = makeStyles((theme) => ({\n  locationIcon: {\n    paddingRight: \"0.5em\",\n  },\n  locationsList: {\n    cursor: \"pointer\",\n    fontWeight: \"bold\",\n    color: theme.palette.primary.main,\n    \"& .inpicture.lookedAt\": {\n      color: theme.palette.primary.dark,\n    },\n  },\n  tabPanel: {\n    marginTop: \"30px\",\n  },\n}));\n\n// Remove the 'SL-' from a location termSL (e.g. \"SL-0097\")\n// The sib-swissbiopics component (different from what is documented)\n// actually doesn't accept the \"SL-\" part of the term\nconst parseLocationTerm = (term) => term?.substring(3);\n\n// Parse termSL to specific id format used by the text for rollovers\nconst parseTermToTextId = (term) => (term ? `${term.replace(\"-\", \"\")}term` : \"\");\n\n// Parse API response and split locations based on sources. Example:\n// { HPA_main: [], uniprot: [], }\nconst parseLocationData = (subcellularLocations) => {\n  const sourcesLocations = {};\n  subcellularLocations.forEach((sl) => {\n    if (sourcesLocations[sl.source] === undefined) {\n      sourcesLocations[sl.source] = [];\n    }\n    sourcesLocations[sl.source].push(sl);\n  });\n  return sourcesLocations;\n};\n\n// Filter the sources array to only those with data\nconst filterSourcesWithData = (sources, sourcesLocations) =>\n  sources.filter((s) => sourcesLocations[s.id] !== undefined);\n\nconst getTabId = (id) => `${id}-tab`;\n\nfunction LocationLink({ sourceId, id }) {\n  return (\n    <Link external to={identifiersOrgLink(sourceId === \"uniprot\" ? \"uniprot\" : \"hpa\", id)}>\n      {id}\n    </Link>\n  );\n}\n\n/**\n * The text list of locations displayed to the right of the visualiztion\n */\nfunction LocationsList({ sls }) {\n  const classes = useStyles();\n  return (\n    <List className={classes.locationsList}>\n      {sls.map(({ location, termSL }) => (\n        <ListItem key={location} id={parseTermToTextId(termSL)}>\n          <span className={classes.locationIcon}>\n            <FontAwesomeIcon icon={faMapMarkerAlt} size=\"lg\" />\n          </span>\n          {location}\n        </ListItem>\n      ))}\n    </List>\n  );\n}\n\n/**\n * SubcellularVizTabs wraps the MUI tabs to separate the state and\n * trigger tab panels visibility on/off without using the state\n * as this crashes the swissbiopic widget - see note below\n * @param {*} sources the array of source to show in the tabs (i.e. those with data)\n */\nfunction SubcellularVizTabs({ sources: activeSources, children }) {\n  const [activeTab, setActiveTab] = useState(0);\n  const onTabChange = (_event, tabId) => {\n    setActiveTab(tabId);\n  };\n  useEffect(() => {\n    // update tab panels visibility: we change the style of the DOM element directly\n    // to avoid any re-rendering as that causes the swissbiopic component to crash\n    children.forEach((child) => {\n      child.ref.current.setAttribute(\"style\", \"display:none\");\n    });\n    children[activeTab].ref.current.setAttribute(\"style\", \"display:block\");\n  });\n\n  return (\n    <>\n      <Tabs value={activeTab} onChange={onTabChange} aria-label=\"Subcellular location sources\">\n        {activeSources.map((s, i) => (\n          <Tab label={s.label} value={i} key={s.id} />\n        ))}\n      </Tabs>\n      {children}\n    </>\n  );\n}\n\n/**\n * A wrapper for the SwissbioViz component\n * @param {*} data the target object as returned by the API\n */\nfunction SubcellularViz({ data: target }) {\n  const classes = useStyles();\n  // define the sources here so we can have call useRef() and then pass it to the tabs panels\n  const sources = [\n    {\n      id: \"HPA_main\",\n      label: \"HPA main location\",\n      ref: useRef(),\n    },\n    {\n      id: \"HPA_additional\",\n      label: \"HPA additional location\",\n      ref: useRef(),\n    },\n    {\n      id: \"HPA_extracellular_location\",\n      label: \"HPA extracellular location\",\n      ref: useRef(),\n    },\n    {\n      id: \"uniprot\",\n      label: \"UniProt\",\n      ref: useRef(),\n    },\n  ];\n  const uniprotId = getUniprotIds(target.proteinIds)[0];\n  const sourcesLocations = parseLocationData(target.subcellularLocations);\n  const activeSources = filterSourcesWithData(sources, sourcesLocations);\n\n  return (\n    <div>\n      <SubcellularVizTabs sources={activeSources}>\n        {activeSources.map((s) => (\n          <div\n            value={getTabId(s.id)}\n            id={getTabId(s.id)}\n            ref={s.ref}\n            key={s.id}\n            className={classes.tabPanel}\n          >\n            <Suspense fallback={<LoadingBackdrop />}>\n              <SwissbioViz\n                taxonId=\"9606\"\n                locationIds={sourcesLocations[s.id].map((l) => parseLocationTerm(l.termSL)).join()}\n                sourceId={s.id.toLowerCase()}\n              >\n                <Box ml={4} key={s.id}>\n                  <Typography variant=\"h6\">{s.label}</Typography>\n                  Location for{\" \"}\n                  <LocationLink sourceId={s.id} id={s.id === \"uniprot\" ? uniprotId : target.id} />\n                  <LocationsList sls={sourcesLocations[s.id]} />\n                </Box>\n              </SwissbioViz>\n            </Suspense>\n          </div>\n        ))}\n      </SubcellularVizTabs>\n    </div>\n  );\n}\n\nexport default SubcellularViz;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/SubcellularLocation/SwissbioViz.jsx" },
        "span": [4946, 5903],
        "sourceCode": "/* eslint-disable */\nimport { memo, useEffect, useRef } from \"react\";\nimport { useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport \"@swissprot/swissbiopics-visualizer\";\n\nconst shapes = [\"path\", \"circle\", \"ellipse\", \"polygon\", \"rect\", \"polyline\", \"line\"];\nconst shapesSelector = shapes.join(\", \");\nconst reMpPart = /(mp|part)_(?<id>\\w+)/;\n\nconst canonicalName = \"sib-swissbiopics-sl\";\nconst CanonicalDefinition = customElements.get(canonicalName);\n\n// Note that these are without leading zeros eg: GO1 (and not GO0000001) so make sure\n// the correct classnames are supplied in SubcellularLocationGOView\nconst getGoTermClassNames = (locationGroup) =>\n  Array.from(locationGroup.classList.values())\n    .filter((className) => className.startsWith(\"GO\"))\n    .map((goId) => `.${goId}`);\n\nconst getUniProtTextSelectors = (subcellularPresentSVG) => [\n  `#${subcellularPresentSVG.id}term`,\n  ...Array.from(subcellularPresentSVG.classList)\n    .map((className) => {\n      const id = className.match(reMpPart)?.groups?.id;\n      return id && `#${id}term`;\n    })\n    .filter((sel) => Boolean(sel)),\n];\n\n/**\n * Visualization wrapper for the SwissBioPic widget.\n * This is taken from Uniprot code whic in turn is based on swissprot approach using custom elements.\n */\nconst SwissbioViz = memo(({ locationIds, taxonId, sourceId, children }) => {\n  const { config } = useConfigContext();\n  const instanceName = useRef(`${canonicalName}-${sourceId}-${v1()}`);\n\n  useEffect(() => {\n    class InstanceClass extends CanonicalDefinition {\n      constructor() {\n        super();\n        this.removedCSSRules = false;\n      }\n\n      deleteCSSRule(selectorText) {\n        for (const styleSheet of super.shadowRoot?.styleSheets || []) {\n          const { cssRules } = styleSheet;\n          for (let index = 0; index < cssRules.length; index += 1) {\n            const cssRule = cssRules[index];\n            if (cssRule instanceof CSSStyleRule && cssRule.selectorText === selectorText) {\n              styleSheet.deleteRule(index);\n              return;\n            }\n          }\n        }\n      }\n\n      // logic for highlighting\n      getHighlights(image) {\n        if (!image) {\n          return [];\n        }\n        const selectors = getGoTermClassNames(image);\n\n        if (image?.id) {\n          selectors.push(`#${image.id}term`);\n        }\n        return this.querySelectorAll(selectors.join(\",\"));\n      }\n\n      highLight(text, image, selector) {\n        if (!this.removedCSSRules) {\n          // Remove the .lookedAt CSS rule to avoid the default styling\n          this.deleteCSSRule(\".lookedAt\");\n          // Undo hard-coded cytoskeleton rule\n          this.deleteCSSRule(\"#SL0090 .lookedAt\");\n          this.removedCSSRules = true;\n        }\n        super.highLight(text, image, selector);\n        // Add \"lookedAt\" classname to image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.add(\"lookedAt\");\n        }\n      }\n\n      // Note that there is no \"h\" in the middle of this method name\n      // This is probably a typo that needs correcting\n      removeHiglight(text, image, selector) {\n        // Remove \"lookedAt\" classname from image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.remove(\"lookedAt\");\n        }\n        super.removeHiglight(text, image, selector);\n      }\n    }\n\n    // customElements.get(instanceName.current) || customElements.define(instanceName.current, InstanceClass);\n    customElements.define(instanceName.current, InstanceClass);\n    const instance = document.querySelector(instanceName.current);\n    const shadowRoot = instance?.shadowRoot;\n\n    const onSvgLoaded = () => {\n      const css = `\n            #fakeContent {\n              display: none;\n            }\n            .subcell_name {\n              display: none;\n            }\n            .subcell_description {\n              display: none;\n            }\n            .subcell_present .coloured {\n              fill: ${config.profile.primaryColor};\n              fill-opacity: 0.3;\n            }\n            .lookedAt {\n              stroke: black !important;\n              fill: ${config.profile.primaryColor} !important;\n              fill-opacity: 1 !important;\n            }\n            #swissbiopic > svg {\n              width: 100%;\n            }\n          `;\n\n      // add styles\n      const style = document.createElement(\"style\");\n      style.innerText = css;\n      shadowRoot?.appendChild(style);\n\n      // add a slot to inject content\n      const slot = document.createElement(\"slot\");\n      const terms = shadowRoot?.querySelector(\".terms\");\n      terms?.appendChild(slot);\n\n      // This finds all subcellular location SVGs for which we have a location\n      const subcellularPresentSVGs =\n        shadowRoot?.querySelectorAll(\n          'svg .subcell_present, svg [class*=\"mp_\"], svg [class*=\"part_\"]'\n        ) || [];\n\n      subcellularPresentSVGs.forEach((subcellularPresentSVG) => {\n        const textSelectors = getUniProtTextSelectors(subcellularPresentSVG);\n        for (const textSelector of textSelectors) {\n          const locationText = instance?.querySelector(textSelector);\n\n          if (locationText) {\n            locationText.classList.add(\"inpicture\");\n            const locationSVG = shadowRoot?.querySelector(`#${subcellularPresentSVG.id}`);\n            // TODO: need to remove event listeners on unmount. Will leave for now until\n            // to see what changes are made to @swissprot/swissbiopics-visualizer\n            locationText.addEventListener(\"mouseenter\", () => {\n              instance?.highLight(locationText, locationSVG, shapesSelector);\n            });\n            locationText.addEventListener(\"mouseleave\", () => {\n              instance?.removeHiglight(locationText, locationSVG, shapesSelector);\n            });\n          }\n        }\n      });\n    };\n    shadowRoot?.addEventListener(\"svgloaded\", onSvgLoaded);\n    return () => {\n      shadowRoot?.removeEventListener(\"svgloaded\", onSvgLoaded);\n    };\n  }, [locationIds]);\n  function Instance(props) {\n    return <instanceName.current {...props} />;\n  }\n  return (\n    <>\n      <div id=\"fakeContent\" />\n\n      <Instance taxid={taxonId} contentid=\"fakeContent\" sls={locationIds}>\n        {children}\n      </Instance>\n    </>\n  );\n});\n\nexport default SwissbioViz;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: config.profile.primaryColor",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: config.profile.primaryColor"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4188, 4215],
              "sourceCode": "/* eslint-disable */\nimport { memo, useEffect, useRef } from \"react\";\nimport { useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport \"@swissprot/swissbiopics-visualizer\";\n\nconst shapes = [\"path\", \"circle\", \"ellipse\", \"polygon\", \"rect\", \"polyline\", \"line\"];\nconst shapesSelector = shapes.join(\", \");\nconst reMpPart = /(mp|part)_(?<id>\\w+)/;\n\nconst canonicalName = \"sib-swissbiopics-sl\";\nconst CanonicalDefinition = customElements.get(canonicalName);\n\n// Note that these are without leading zeros eg: GO1 (and not GO0000001) so make sure\n// the correct classnames are supplied in SubcellularLocationGOView\nconst getGoTermClassNames = (locationGroup) =>\n  Array.from(locationGroup.classList.values())\n    .filter((className) => className.startsWith(\"GO\"))\n    .map((goId) => `.${goId}`);\n\nconst getUniProtTextSelectors = (subcellularPresentSVG) => [\n  `#${subcellularPresentSVG.id}term`,\n  ...Array.from(subcellularPresentSVG.classList)\n    .map((className) => {\n      const id = className.match(reMpPart)?.groups?.id;\n      return id && `#${id}term`;\n    })\n    .filter((sel) => Boolean(sel)),\n];\n\n/**\n * Visualization wrapper for the SwissBioPic widget.\n * This is taken from Uniprot code whic in turn is based on swissprot approach using custom elements.\n */\nconst SwissbioViz = memo(({ locationIds, taxonId, sourceId, children }) => {\n  const { config } = useConfigContext();\n  const instanceName = useRef(`${canonicalName}-${sourceId}-${v1()}`);\n\n  useEffect(() => {\n    class InstanceClass extends CanonicalDefinition {\n      constructor() {\n        super();\n        this.removedCSSRules = false;\n      }\n\n      deleteCSSRule(selectorText) {\n        for (const styleSheet of super.shadowRoot?.styleSheets || []) {\n          const { cssRules } = styleSheet;\n          for (let index = 0; index < cssRules.length; index += 1) {\n            const cssRule = cssRules[index];\n            if (cssRule instanceof CSSStyleRule && cssRule.selectorText === selectorText) {\n              styleSheet.deleteRule(index);\n              return;\n            }\n          }\n        }\n      }\n\n      // logic for highlighting\n      getHighlights(image) {\n        if (!image) {\n          return [];\n        }\n        const selectors = getGoTermClassNames(image);\n\n        if (image?.id) {\n          selectors.push(`#${image.id}term`);\n        }\n        return this.querySelectorAll(selectors.join(\",\"));\n      }\n\n      highLight(text, image, selector) {\n        if (!this.removedCSSRules) {\n          // Remove the .lookedAt CSS rule to avoid the default styling\n          this.deleteCSSRule(\".lookedAt\");\n          // Undo hard-coded cytoskeleton rule\n          this.deleteCSSRule(\"#SL0090 .lookedAt\");\n          this.removedCSSRules = true;\n        }\n        super.highLight(text, image, selector);\n        // Add \"lookedAt\" classname to image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.add(\"lookedAt\");\n        }\n      }\n\n      // Note that there is no \"h\" in the middle of this method name\n      // This is probably a typo that needs correcting\n      removeHiglight(text, image, selector) {\n        // Remove \"lookedAt\" classname from image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.remove(\"lookedAt\");\n        }\n        super.removeHiglight(text, image, selector);\n      }\n    }\n\n    // customElements.get(instanceName.current) || customElements.define(instanceName.current, InstanceClass);\n    customElements.define(instanceName.current, InstanceClass);\n    const instance = document.querySelector(instanceName.current);\n    const shadowRoot = instance?.shadowRoot;\n\n    const onSvgLoaded = () => {\n      const css = `\n            #fakeContent {\n              display: none;\n            }\n            .subcell_name {\n              display: none;\n            }\n            .subcell_description {\n              display: none;\n            }\n            .subcell_present .coloured {\n              fill: ${config.profile.primaryColor};\n              fill-opacity: 0.3;\n            }\n            .lookedAt {\n              stroke: black !important;\n              fill: ${config.profile.primaryColor} !important;\n              fill-opacity: 1 !important;\n            }\n            #swissbiopic > svg {\n              width: 100%;\n            }\n          `;\n\n      // add styles\n      const style = document.createElement(\"style\");\n      style.innerText = css;\n      shadowRoot?.appendChild(style);\n\n      // add a slot to inject content\n      const slot = document.createElement(\"slot\");\n      const terms = shadowRoot?.querySelector(\".terms\");\n      terms?.appendChild(slot);\n\n      // This finds all subcellular location SVGs for which we have a location\n      const subcellularPresentSVGs =\n        shadowRoot?.querySelectorAll(\n          'svg .subcell_present, svg [class*=\"mp_\"], svg [class*=\"part_\"]'\n        ) || [];\n\n      subcellularPresentSVGs.forEach((subcellularPresentSVG) => {\n        const textSelectors = getUniProtTextSelectors(subcellularPresentSVG);\n        for (const textSelector of textSelectors) {\n          const locationText = instance?.querySelector(textSelector);\n\n          if (locationText) {\n            locationText.classList.add(\"inpicture\");\n            const locationSVG = shadowRoot?.querySelector(`#${subcellularPresentSVG.id}`);\n            // TODO: need to remove event listeners on unmount. Will leave for now until\n            // to see what changes are made to @swissprot/swissbiopics-visualizer\n            locationText.addEventListener(\"mouseenter\", () => {\n              instance?.highLight(locationText, locationSVG, shapesSelector);\n            });\n            locationText.addEventListener(\"mouseleave\", () => {\n              instance?.removeHiglight(locationText, locationSVG, shapesSelector);\n            });\n          }\n        }\n      });\n    };\n    shadowRoot?.addEventListener(\"svgloaded\", onSvgLoaded);\n    return () => {\n      shadowRoot?.removeEventListener(\"svgloaded\", onSvgLoaded);\n    };\n  }, [locationIds]);\n  function Instance(props) {\n    return <instanceName.current {...props} />;\n  }\n  return (\n    <>\n      <div id=\"fakeContent\" />\n\n      <Instance taxid={taxonId} contentid=\"fakeContent\" sls={locationIds}>\n        {children}\n      </Instance>\n    </>\n  );\n});\n\nexport default SwissbioViz;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4025, 4052],
              "sourceCode": "/* eslint-disable */\nimport { memo, useEffect, useRef } from \"react\";\nimport { useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport \"@swissprot/swissbiopics-visualizer\";\n\nconst shapes = [\"path\", \"circle\", \"ellipse\", \"polygon\", \"rect\", \"polyline\", \"line\"];\nconst shapesSelector = shapes.join(\", \");\nconst reMpPart = /(mp|part)_(?<id>\\w+)/;\n\nconst canonicalName = \"sib-swissbiopics-sl\";\nconst CanonicalDefinition = customElements.get(canonicalName);\n\n// Note that these are without leading zeros eg: GO1 (and not GO0000001) so make sure\n// the correct classnames are supplied in SubcellularLocationGOView\nconst getGoTermClassNames = (locationGroup) =>\n  Array.from(locationGroup.classList.values())\n    .filter((className) => className.startsWith(\"GO\"))\n    .map((goId) => `.${goId}`);\n\nconst getUniProtTextSelectors = (subcellularPresentSVG) => [\n  `#${subcellularPresentSVG.id}term`,\n  ...Array.from(subcellularPresentSVG.classList)\n    .map((className) => {\n      const id = className.match(reMpPart)?.groups?.id;\n      return id && `#${id}term`;\n    })\n    .filter((sel) => Boolean(sel)),\n];\n\n/**\n * Visualization wrapper for the SwissBioPic widget.\n * This is taken from Uniprot code whic in turn is based on swissprot approach using custom elements.\n */\nconst SwissbioViz = memo(({ locationIds, taxonId, sourceId, children }) => {\n  const { config } = useConfigContext();\n  const instanceName = useRef(`${canonicalName}-${sourceId}-${v1()}`);\n\n  useEffect(() => {\n    class InstanceClass extends CanonicalDefinition {\n      constructor() {\n        super();\n        this.removedCSSRules = false;\n      }\n\n      deleteCSSRule(selectorText) {\n        for (const styleSheet of super.shadowRoot?.styleSheets || []) {\n          const { cssRules } = styleSheet;\n          for (let index = 0; index < cssRules.length; index += 1) {\n            const cssRule = cssRules[index];\n            if (cssRule instanceof CSSStyleRule && cssRule.selectorText === selectorText) {\n              styleSheet.deleteRule(index);\n              return;\n            }\n          }\n        }\n      }\n\n      // logic for highlighting\n      getHighlights(image) {\n        if (!image) {\n          return [];\n        }\n        const selectors = getGoTermClassNames(image);\n\n        if (image?.id) {\n          selectors.push(`#${image.id}term`);\n        }\n        return this.querySelectorAll(selectors.join(\",\"));\n      }\n\n      highLight(text, image, selector) {\n        if (!this.removedCSSRules) {\n          // Remove the .lookedAt CSS rule to avoid the default styling\n          this.deleteCSSRule(\".lookedAt\");\n          // Undo hard-coded cytoskeleton rule\n          this.deleteCSSRule(\"#SL0090 .lookedAt\");\n          this.removedCSSRules = true;\n        }\n        super.highLight(text, image, selector);\n        // Add \"lookedAt\" classname to image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.add(\"lookedAt\");\n        }\n      }\n\n      // Note that there is no \"h\" in the middle of this method name\n      // This is probably a typo that needs correcting\n      removeHiglight(text, image, selector) {\n        // Remove \"lookedAt\" classname from image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.remove(\"lookedAt\");\n        }\n        super.removeHiglight(text, image, selector);\n      }\n    }\n\n    // customElements.get(instanceName.current) || customElements.define(instanceName.current, InstanceClass);\n    customElements.define(instanceName.current, InstanceClass);\n    const instance = document.querySelector(instanceName.current);\n    const shadowRoot = instance?.shadowRoot;\n\n    const onSvgLoaded = () => {\n      const css = `\n            #fakeContent {\n              display: none;\n            }\n            .subcell_name {\n              display: none;\n            }\n            .subcell_description {\n              display: none;\n            }\n            .subcell_present .coloured {\n              fill: ${config.profile.primaryColor};\n              fill-opacity: 0.3;\n            }\n            .lookedAt {\n              stroke: black !important;\n              fill: ${config.profile.primaryColor} !important;\n              fill-opacity: 1 !important;\n            }\n            #swissbiopic > svg {\n              width: 100%;\n            }\n          `;\n\n      // add styles\n      const style = document.createElement(\"style\");\n      style.innerText = css;\n      shadowRoot?.appendChild(style);\n\n      // add a slot to inject content\n      const slot = document.createElement(\"slot\");\n      const terms = shadowRoot?.querySelector(\".terms\");\n      terms?.appendChild(slot);\n\n      // This finds all subcellular location SVGs for which we have a location\n      const subcellularPresentSVGs =\n        shadowRoot?.querySelectorAll(\n          'svg .subcell_present, svg [class*=\"mp_\"], svg [class*=\"part_\"]'\n        ) || [];\n\n      subcellularPresentSVGs.forEach((subcellularPresentSVG) => {\n        const textSelectors = getUniProtTextSelectors(subcellularPresentSVG);\n        for (const textSelector of textSelectors) {\n          const locationText = instance?.querySelector(textSelector);\n\n          if (locationText) {\n            locationText.classList.add(\"inpicture\");\n            const locationSVG = shadowRoot?.querySelector(`#${subcellularPresentSVG.id}`);\n            // TODO: need to remove event listeners on unmount. Will leave for now until\n            // to see what changes are made to @swissprot/swissbiopics-visualizer\n            locationText.addEventListener(\"mouseenter\", () => {\n              instance?.highLight(locationText, locationSVG, shapesSelector);\n            });\n            locationText.addEventListener(\"mouseleave\", () => {\n              instance?.removeHiglight(locationText, locationSVG, shapesSelector);\n            });\n          }\n        }\n      });\n    };\n    shadowRoot?.addEventListener(\"svgloaded\", onSvgLoaded);\n    return () => {\n      shadowRoot?.removeEventListener(\"svgloaded\", onSvgLoaded);\n    };\n  }, [locationIds]);\n  function Instance(props) {\n    return <instanceName.current {...props} />;\n  }\n  return (\n    <>\n      <div id=\"fakeContent\" />\n\n      <Instance taxid={taxonId} contentid=\"fakeContent\" sls={locationIds}>\n        {children}\n      </Instance>\n    </>\n  );\n});\n\nexport default SwissbioViz;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/SubcellularLocation/SwissbioViz.jsx" },
        "span": [1462, 1471],
        "sourceCode": "/* eslint-disable */\nimport { memo, useEffect, useRef } from \"react\";\nimport { useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport \"@swissprot/swissbiopics-visualizer\";\n\nconst shapes = [\"path\", \"circle\", \"ellipse\", \"polygon\", \"rect\", \"polyline\", \"line\"];\nconst shapesSelector = shapes.join(\", \");\nconst reMpPart = /(mp|part)_(?<id>\\w+)/;\n\nconst canonicalName = \"sib-swissbiopics-sl\";\nconst CanonicalDefinition = customElements.get(canonicalName);\n\n// Note that these are without leading zeros eg: GO1 (and not GO0000001) so make sure\n// the correct classnames are supplied in SubcellularLocationGOView\nconst getGoTermClassNames = (locationGroup) =>\n  Array.from(locationGroup.classList.values())\n    .filter((className) => className.startsWith(\"GO\"))\n    .map((goId) => `.${goId}`);\n\nconst getUniProtTextSelectors = (subcellularPresentSVG) => [\n  `#${subcellularPresentSVG.id}term`,\n  ...Array.from(subcellularPresentSVG.classList)\n    .map((className) => {\n      const id = className.match(reMpPart)?.groups?.id;\n      return id && `#${id}term`;\n    })\n    .filter((sel) => Boolean(sel)),\n];\n\n/**\n * Visualization wrapper for the SwissBioPic widget.\n * This is taken from Uniprot code whic in turn is based on swissprot approach using custom elements.\n */\nconst SwissbioViz = memo(({ locationIds, taxonId, sourceId, children }) => {\n  const { config } = useConfigContext();\n  const instanceName = useRef(`${canonicalName}-${sourceId}-${v1()}`);\n\n  useEffect(() => {\n    class InstanceClass extends CanonicalDefinition {\n      constructor() {\n        super();\n        this.removedCSSRules = false;\n      }\n\n      deleteCSSRule(selectorText) {\n        for (const styleSheet of super.shadowRoot?.styleSheets || []) {\n          const { cssRules } = styleSheet;\n          for (let index = 0; index < cssRules.length; index += 1) {\n            const cssRule = cssRules[index];\n            if (cssRule instanceof CSSStyleRule && cssRule.selectorText === selectorText) {\n              styleSheet.deleteRule(index);\n              return;\n            }\n          }\n        }\n      }\n\n      // logic for highlighting\n      getHighlights(image) {\n        if (!image) {\n          return [];\n        }\n        const selectors = getGoTermClassNames(image);\n\n        if (image?.id) {\n          selectors.push(`#${image.id}term`);\n        }\n        return this.querySelectorAll(selectors.join(\",\"));\n      }\n\n      highLight(text, image, selector) {\n        if (!this.removedCSSRules) {\n          // Remove the .lookedAt CSS rule to avoid the default styling\n          this.deleteCSSRule(\".lookedAt\");\n          // Undo hard-coded cytoskeleton rule\n          this.deleteCSSRule(\"#SL0090 .lookedAt\");\n          this.removedCSSRules = true;\n        }\n        super.highLight(text, image, selector);\n        // Add \"lookedAt\" classname to image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.add(\"lookedAt\");\n        }\n      }\n\n      // Note that there is no \"h\" in the middle of this method name\n      // This is probably a typo that needs correcting\n      removeHiglight(text, image, selector) {\n        // Remove \"lookedAt\" classname from image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.remove(\"lookedAt\");\n        }\n        super.removeHiglight(text, image, selector);\n      }\n    }\n\n    // customElements.get(instanceName.current) || customElements.define(instanceName.current, InstanceClass);\n    customElements.define(instanceName.current, InstanceClass);\n    const instance = document.querySelector(instanceName.current);\n    const shadowRoot = instance?.shadowRoot;\n\n    const onSvgLoaded = () => {\n      const css = `\n            #fakeContent {\n              display: none;\n            }\n            .subcell_name {\n              display: none;\n            }\n            .subcell_description {\n              display: none;\n            }\n            .subcell_present .coloured {\n              fill: ${config.profile.primaryColor};\n              fill-opacity: 0.3;\n            }\n            .lookedAt {\n              stroke: black !important;\n              fill: ${config.profile.primaryColor} !important;\n              fill-opacity: 1 !important;\n            }\n            #swissbiopic > svg {\n              width: 100%;\n            }\n          `;\n\n      // add styles\n      const style = document.createElement(\"style\");\n      style.innerText = css;\n      shadowRoot?.appendChild(style);\n\n      // add a slot to inject content\n      const slot = document.createElement(\"slot\");\n      const terms = shadowRoot?.querySelector(\".terms\");\n      terms?.appendChild(slot);\n\n      // This finds all subcellular location SVGs for which we have a location\n      const subcellularPresentSVGs =\n        shadowRoot?.querySelectorAll(\n          'svg .subcell_present, svg [class*=\"mp_\"], svg [class*=\"part_\"]'\n        ) || [];\n\n      subcellularPresentSVGs.forEach((subcellularPresentSVG) => {\n        const textSelectors = getUniProtTextSelectors(subcellularPresentSVG);\n        for (const textSelector of textSelectors) {\n          const locationText = instance?.querySelector(textSelector);\n\n          if (locationText) {\n            locationText.classList.add(\"inpicture\");\n            const locationSVG = shadowRoot?.querySelector(`#${subcellularPresentSVG.id}`);\n            // TODO: need to remove event listeners on unmount. Will leave for now until\n            // to see what changes are made to @swissprot/swissbiopics-visualizer\n            locationText.addEventListener(\"mouseenter\", () => {\n              instance?.highLight(locationText, locationSVG, shapesSelector);\n            });\n            locationText.addEventListener(\"mouseleave\", () => {\n              instance?.removeHiglight(locationText, locationSVG, shapesSelector);\n            });\n          }\n        }\n      });\n    };\n    shadowRoot?.addEventListener(\"svgloaded\", onSvgLoaded);\n    return () => {\n      shadowRoot?.removeEventListener(\"svgloaded\", onSvgLoaded);\n    };\n  }, [locationIds]);\n  function Instance(props) {\n    return <instanceName.current {...props} />;\n  }\n  return (\n    <>\n      <div id=\"fakeContent\" />\n\n      <Instance taxid={taxonId} contentid=\"fakeContent\" sls={locationIds}>\n        {children}\n      </Instance>\n    </>\n  );\n});\n\nexport default SwissbioViz;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: locationIds",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: locationIds"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Outer scope values aren't valid dependencies because mutating them doesn't re-render the component."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6069, 6080],
              "sourceCode": "/* eslint-disable */\nimport { memo, useEffect, useRef } from \"react\";\nimport { useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport \"@swissprot/swissbiopics-visualizer\";\n\nconst shapes = [\"path\", \"circle\", \"ellipse\", \"polygon\", \"rect\", \"polyline\", \"line\"];\nconst shapesSelector = shapes.join(\", \");\nconst reMpPart = /(mp|part)_(?<id>\\w+)/;\n\nconst canonicalName = \"sib-swissbiopics-sl\";\nconst CanonicalDefinition = customElements.get(canonicalName);\n\n// Note that these are without leading zeros eg: GO1 (and not GO0000001) so make sure\n// the correct classnames are supplied in SubcellularLocationGOView\nconst getGoTermClassNames = (locationGroup) =>\n  Array.from(locationGroup.classList.values())\n    .filter((className) => className.startsWith(\"GO\"))\n    .map((goId) => `.${goId}`);\n\nconst getUniProtTextSelectors = (subcellularPresentSVG) => [\n  `#${subcellularPresentSVG.id}term`,\n  ...Array.from(subcellularPresentSVG.classList)\n    .map((className) => {\n      const id = className.match(reMpPart)?.groups?.id;\n      return id && `#${id}term`;\n    })\n    .filter((sel) => Boolean(sel)),\n];\n\n/**\n * Visualization wrapper for the SwissBioPic widget.\n * This is taken from Uniprot code whic in turn is based on swissprot approach using custom elements.\n */\nconst SwissbioViz = memo(({ locationIds, taxonId, sourceId, children }) => {\n  const { config } = useConfigContext();\n  const instanceName = useRef(`${canonicalName}-${sourceId}-${v1()}`);\n\n  useEffect(() => {\n    class InstanceClass extends CanonicalDefinition {\n      constructor() {\n        super();\n        this.removedCSSRules = false;\n      }\n\n      deleteCSSRule(selectorText) {\n        for (const styleSheet of super.shadowRoot?.styleSheets || []) {\n          const { cssRules } = styleSheet;\n          for (let index = 0; index < cssRules.length; index += 1) {\n            const cssRule = cssRules[index];\n            if (cssRule instanceof CSSStyleRule && cssRule.selectorText === selectorText) {\n              styleSheet.deleteRule(index);\n              return;\n            }\n          }\n        }\n      }\n\n      // logic for highlighting\n      getHighlights(image) {\n        if (!image) {\n          return [];\n        }\n        const selectors = getGoTermClassNames(image);\n\n        if (image?.id) {\n          selectors.push(`#${image.id}term`);\n        }\n        return this.querySelectorAll(selectors.join(\",\"));\n      }\n\n      highLight(text, image, selector) {\n        if (!this.removedCSSRules) {\n          // Remove the .lookedAt CSS rule to avoid the default styling\n          this.deleteCSSRule(\".lookedAt\");\n          // Undo hard-coded cytoskeleton rule\n          this.deleteCSSRule(\"#SL0090 .lookedAt\");\n          this.removedCSSRules = true;\n        }\n        super.highLight(text, image, selector);\n        // Add \"lookedAt\" classname to image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.add(\"lookedAt\");\n        }\n      }\n\n      // Note that there is no \"h\" in the middle of this method name\n      // This is probably a typo that needs correcting\n      removeHiglight(text, image, selector) {\n        // Remove \"lookedAt\" classname from image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.remove(\"lookedAt\");\n        }\n        super.removeHiglight(text, image, selector);\n      }\n    }\n\n    // customElements.get(instanceName.current) || customElements.define(instanceName.current, InstanceClass);\n    customElements.define(instanceName.current, InstanceClass);\n    const instance = document.querySelector(instanceName.current);\n    const shadowRoot = instance?.shadowRoot;\n\n    const onSvgLoaded = () => {\n      const css = `\n            #fakeContent {\n              display: none;\n            }\n            .subcell_name {\n              display: none;\n            }\n            .subcell_description {\n              display: none;\n            }\n            .subcell_present .coloured {\n              fill: ${config.profile.primaryColor};\n              fill-opacity: 0.3;\n            }\n            .lookedAt {\n              stroke: black !important;\n              fill: ${config.profile.primaryColor} !important;\n              fill-opacity: 1 !important;\n            }\n            #swissbiopic > svg {\n              width: 100%;\n            }\n          `;\n\n      // add styles\n      const style = document.createElement(\"style\");\n      style.innerText = css;\n      shadowRoot?.appendChild(style);\n\n      // add a slot to inject content\n      const slot = document.createElement(\"slot\");\n      const terms = shadowRoot?.querySelector(\".terms\");\n      terms?.appendChild(slot);\n\n      // This finds all subcellular location SVGs for which we have a location\n      const subcellularPresentSVGs =\n        shadowRoot?.querySelectorAll(\n          'svg .subcell_present, svg [class*=\"mp_\"], svg [class*=\"part_\"]'\n        ) || [];\n\n      subcellularPresentSVGs.forEach((subcellularPresentSVG) => {\n        const textSelectors = getUniProtTextSelectors(subcellularPresentSVG);\n        for (const textSelector of textSelectors) {\n          const locationText = instance?.querySelector(textSelector);\n\n          if (locationText) {\n            locationText.classList.add(\"inpicture\");\n            const locationSVG = shadowRoot?.querySelector(`#${subcellularPresentSVG.id}`);\n            // TODO: need to remove event listeners on unmount. Will leave for now until\n            // to see what changes are made to @swissprot/swissbiopics-visualizer\n            locationText.addEventListener(\"mouseenter\", () => {\n              instance?.highLight(locationText, locationSVG, shapesSelector);\n            });\n            locationText.addEventListener(\"mouseleave\", () => {\n              instance?.removeHiglight(locationText, locationSVG, shapesSelector);\n            });\n          }\n        }\n      });\n    };\n    shadowRoot?.addEventListener(\"svgloaded\", onSvgLoaded);\n    return () => {\n      shadowRoot?.removeEventListener(\"svgloaded\", onSvgLoaded);\n    };\n  }, [locationIds]);\n  function Instance(props) {\n    return <instanceName.current {...props} />;\n  }\n  return (\n    <>\n      <div id=\"fakeContent\" />\n\n      <Instance taxid={taxonId} contentid=\"fakeContent\" sls={locationIds}>\n        {children}\n      </Instance>\n    </>\n  );\n});\n\nexport default SwissbioViz;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/SubcellularLocation/SwissbioViz.jsx" },
        "span": [1462, 1471],
        "sourceCode": "/* eslint-disable */\nimport { memo, useEffect, useRef } from \"react\";\nimport { useConfigContext } from \"ui\";\nimport { v1 } from \"uuid\";\n\nimport \"@swissprot/swissbiopics-visualizer\";\n\nconst shapes = [\"path\", \"circle\", \"ellipse\", \"polygon\", \"rect\", \"polyline\", \"line\"];\nconst shapesSelector = shapes.join(\", \");\nconst reMpPart = /(mp|part)_(?<id>\\w+)/;\n\nconst canonicalName = \"sib-swissbiopics-sl\";\nconst CanonicalDefinition = customElements.get(canonicalName);\n\n// Note that these are without leading zeros eg: GO1 (and not GO0000001) so make sure\n// the correct classnames are supplied in SubcellularLocationGOView\nconst getGoTermClassNames = (locationGroup) =>\n  Array.from(locationGroup.classList.values())\n    .filter((className) => className.startsWith(\"GO\"))\n    .map((goId) => `.${goId}`);\n\nconst getUniProtTextSelectors = (subcellularPresentSVG) => [\n  `#${subcellularPresentSVG.id}term`,\n  ...Array.from(subcellularPresentSVG.classList)\n    .map((className) => {\n      const id = className.match(reMpPart)?.groups?.id;\n      return id && `#${id}term`;\n    })\n    .filter((sel) => Boolean(sel)),\n];\n\n/**\n * Visualization wrapper for the SwissBioPic widget.\n * This is taken from Uniprot code whic in turn is based on swissprot approach using custom elements.\n */\nconst SwissbioViz = memo(({ locationIds, taxonId, sourceId, children }) => {\n  const { config } = useConfigContext();\n  const instanceName = useRef(`${canonicalName}-${sourceId}-${v1()}`);\n\n  useEffect(() => {\n    class InstanceClass extends CanonicalDefinition {\n      constructor() {\n        super();\n        this.removedCSSRules = false;\n      }\n\n      deleteCSSRule(selectorText) {\n        for (const styleSheet of super.shadowRoot?.styleSheets || []) {\n          const { cssRules } = styleSheet;\n          for (let index = 0; index < cssRules.length; index += 1) {\n            const cssRule = cssRules[index];\n            if (cssRule instanceof CSSStyleRule && cssRule.selectorText === selectorText) {\n              styleSheet.deleteRule(index);\n              return;\n            }\n          }\n        }\n      }\n\n      // logic for highlighting\n      getHighlights(image) {\n        if (!image) {\n          return [];\n        }\n        const selectors = getGoTermClassNames(image);\n\n        if (image?.id) {\n          selectors.push(`#${image.id}term`);\n        }\n        return this.querySelectorAll(selectors.join(\",\"));\n      }\n\n      highLight(text, image, selector) {\n        if (!this.removedCSSRules) {\n          // Remove the .lookedAt CSS rule to avoid the default styling\n          this.deleteCSSRule(\".lookedAt\");\n          // Undo hard-coded cytoskeleton rule\n          this.deleteCSSRule(\"#SL0090 .lookedAt\");\n          this.removedCSSRules = true;\n        }\n        super.highLight(text, image, selector);\n        // Add \"lookedAt\" classname to image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.add(\"lookedAt\");\n        }\n      }\n\n      // Note that there is no \"h\" in the middle of this method name\n      // This is probably a typo that needs correcting\n      removeHiglight(text, image, selector) {\n        // Remove \"lookedAt\" classname from image SVG and text\n        for (const highlight of this.getHighlights(image)) {\n          highlight?.classList.remove(\"lookedAt\");\n        }\n        super.removeHiglight(text, image, selector);\n      }\n    }\n\n    // customElements.get(instanceName.current) || customElements.define(instanceName.current, InstanceClass);\n    customElements.define(instanceName.current, InstanceClass);\n    const instance = document.querySelector(instanceName.current);\n    const shadowRoot = instance?.shadowRoot;\n\n    const onSvgLoaded = () => {\n      const css = `\n            #fakeContent {\n              display: none;\n            }\n            .subcell_name {\n              display: none;\n            }\n            .subcell_description {\n              display: none;\n            }\n            .subcell_present .coloured {\n              fill: ${config.profile.primaryColor};\n              fill-opacity: 0.3;\n            }\n            .lookedAt {\n              stroke: black !important;\n              fill: ${config.profile.primaryColor} !important;\n              fill-opacity: 1 !important;\n            }\n            #swissbiopic > svg {\n              width: 100%;\n            }\n          `;\n\n      // add styles\n      const style = document.createElement(\"style\");\n      style.innerText = css;\n      shadowRoot?.appendChild(style);\n\n      // add a slot to inject content\n      const slot = document.createElement(\"slot\");\n      const terms = shadowRoot?.querySelector(\".terms\");\n      terms?.appendChild(slot);\n\n      // This finds all subcellular location SVGs for which we have a location\n      const subcellularPresentSVGs =\n        shadowRoot?.querySelectorAll(\n          'svg .subcell_present, svg [class*=\"mp_\"], svg [class*=\"part_\"]'\n        ) || [];\n\n      subcellularPresentSVGs.forEach((subcellularPresentSVG) => {\n        const textSelectors = getUniProtTextSelectors(subcellularPresentSVG);\n        for (const textSelector of textSelectors) {\n          const locationText = instance?.querySelector(textSelector);\n\n          if (locationText) {\n            locationText.classList.add(\"inpicture\");\n            const locationSVG = shadowRoot?.querySelector(`#${subcellularPresentSVG.id}`);\n            // TODO: need to remove event listeners on unmount. Will leave for now until\n            // to see what changes are made to @swissprot/swissbiopics-visualizer\n            locationText.addEventListener(\"mouseenter\", () => {\n              instance?.highLight(locationText, locationSVG, shapesSelector);\n            });\n            locationText.addEventListener(\"mouseleave\", () => {\n              instance?.removeHiglight(locationText, locationSVG, shapesSelector);\n            });\n          }\n        }\n      });\n    };\n    shadowRoot?.addEventListener(\"svgloaded\", onSvgLoaded);\n    return () => {\n      shadowRoot?.removeEventListener(\"svgloaded\", onSvgLoaded);\n    };\n  }, [locationIds]);\n  function Instance(props) {\n    return <instanceName.current {...props} />;\n  }\n  return (\n    <>\n      <div id=\"fakeContent\" />\n\n      <Instance taxid={taxonId} contentid=\"fakeContent\" sls={locationIds}>\n        {children}\n      </Instance>\n    </>\n  );\n});\n\nexport default SwissbioViz;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [3054, 3078],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [9983, 10077],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [10054, 10075],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/style/noParameterAssign",
      "severity": "error",
      "description": "Reassigning a function parameter is confusing.",
      "message": [
        { "elements": [], "content": "Reassigning a " },
        { "elements": ["Emphasis"], "content": "function parameter" },
        { "elements": [], "content": " is confusing." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "The " },
                { "elements": ["Emphasis"], "content": "parameter" },
                { "elements": [], "content": " is declared here:" }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2902, 2906],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          { "log": ["info", [{ "elements": [], "content": "Use a local variable instead." }]] }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [2962, 2966],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/style/noParameterAssign",
      "severity": "error",
      "description": "Reassigning a function parameter is confusing.",
      "message": [
        { "elements": [], "content": "Reassigning a " },
        { "elements": ["Emphasis"], "content": "function parameter" },
        { "elements": [], "content": " is confusing." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "The " },
                { "elements": ["Emphasis"], "content": "parameter" },
                { "elements": [], "content": " is declared here:" }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2908, 2912],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          { "log": ["info", [{ "elements": [], "content": "Use a local variable instead." }]] }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [3005, 3009],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: setExperimentalResults, setSegments, setSelectedStructure",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: setExperimentalResults, setSegments, setSelectedStructure"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12160, 12182],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12184, 12195],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12197, 12217],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [10118, 10127],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: viewer?.clear",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: viewer?.clear"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12518, 12531],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [12243, 12252],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: setViewer",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: setViewer"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12592, 12601],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [12243, 12252],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: clearStructureInfo",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: clearStructureInfo"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12755, 12773],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [12650, 12659],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: hideLoadingMessage",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: hideLoadingMessage"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [20873, 20891],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [12650, 12659],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: hideAtomInfo",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: hideAtomInfo"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [21125, 21137],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [19223, 19235],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [12650, 12659],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: showLoadingMessage",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: showLoadingMessage"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [12785, 12803],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [20997, 21015],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [13614, 13632],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [13275, 13293],
              "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/target/ProtVista/Body.jsx" },
        "span": [12650, 12659],
        "sourceCode": "import { createViewer } from \"3dmol\";\nimport { useQuery } from \"@apollo/client\";\nimport { faCamera } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Button, Grid, Typography } from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { getUniprotIds, nanComparator } from \"@ot/utils\";\nimport { schemeDark2, schemeSet1 } from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { Link, OtTable, SectionItem } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PROTVISTA_QUERY from \"./ProtVista.gql\";\nimport { parseCif } from \"./parseCif\";\n\nconst experimentalResultsStem = \"https://www.ebi.ac.uk/proteins/api/proteins/\";\nconst experimentalStructureStem = \"https://www.ebi.ac.uk/pdbe/entry-files/download/\";\nconst experimentalStructureSuffix = \".cif\";\nconst alphaFoldResultsStem = \"https://alphafold.ebi.ac.uk/api/prediction/\";\nconst alphaFoldStructureStem = \"https://alphafold.ebi.ac.uk/files/\";\nconst alphaFoldStructureSuffix = \"-model_v4.cif\";\n\nfunction getSegments(_id, chainsAndPositions) {\n  const printChains = [];\n  const printSegments = [];\n  const details = {};\n  const substrings = chainsAndPositions.split(/,\\s*/);\n  let maxLengthSegment = Number.NEGATIVE_INFINITY;\n  for (const substr of substrings) {\n    const eqIndex = substr.indexOf(\"=\");\n    const chains = substr.slice(0, eqIndex);\n    printChains.push(chains);\n    const sepChains = chains.split(\"/\");\n    const interval = substr.slice(eqIndex + 1);\n    printSegments.push(substrings.length === 1 ? interval : `${chains}=${interval}`);\n    const [from, to] = interval.split(\"-\");\n    maxLengthSegment = Math.max(maxLengthSegment, to - from);\n    for (const chain of sepChains) {\n      details[chain] ??= [];\n      details[chain].push({ from, to });\n    }\n  }\n  return {\n    rawString: chainsAndPositions, // !! REMOVE !!\n    chainsString: printChains.join(\", \"),\n    segmentsString: printSegments.join(\", \"),\n    details,\n    uniqueChains: new Set(Object.keys(details)),\n    maxLengthSegment,\n  };\n}\n\nconst alphaFoldConfidenceBands = [\n  { lowerLimit: 90, label: \"Very high\", sublabel: \"pLDDT > 90\", color: \"rgb(0, 83, 214)\" },\n  {\n    lowerLimit: 70,\n    label: \"Confident\",\n    sublabel: \"90 > pLDDT > 70\",\n    color: \"rgb(101, 203, 243)\",\n  },\n  { lowerLimit: 50, label: \"Low\", sublabel: \"70 > pLDDT > 50\", color: \"rgb(255, 219, 19)\" },\n  { lowerLimit: 0, label: \"Very low \", sublabel: \"pLDDT < 50\", color: \"rgb(255, 125, 69)\" },\n];\n\nfunction getConfidence(atom, propertyName = \"label\") {\n  for (const obj of alphaFoldConfidenceBands) {\n    if (atom.b > obj.lowerLimit) return obj[propertyName];\n  }\n  return alphaFoldConfidenceBands[0][propertyName];\n}\n\nconst chainColorScheme = [\n  ...schemeDark2.slice(0, -1),\n  ...[1, 2, 3, 4, 0, 6, 7].map((i) => schemeSet1[i]),\n];\n\nfunction zipToObject(arr1, arr2) {\n  const obj = {};\n  if (!Array.isArray(arr1)) arr1 = [arr1];\n  if (!Array.isArray(arr2)) arr2 = [arr2];\n  arr1.forEach((value, index) => (obj[value] = arr2[index]));\n  return obj;\n}\n\nfunction isAlphaFold(selectedStructure) {\n  return selectedStructure?.type?.toLowerCase?.() === \"alphafold\";\n}\n\nfunction AlphaFoldLegend() {\n  return (\n    <Box display=\"flex\">\n      <Box display=\"flex\" flexDirection=\"column\" ml={2} gap={0.75}>\n        <Typography variant=\"subtitle2\">Model Confidence</Typography>\n        <Box display=\"flex\" gap={3.5}>\n          {alphaFoldConfidenceBands.map(({ label, sublabel, color }) => (\n            <Box key={label}>\n              <Box display=\"flex\" gap={0.75} alignItems=\"center\">\n                <Box width=\"12px\" height=\"12px\" bgcolor={color} />\n                <Box display=\"flex\" flexDirection=\"column\">\n                  <Typography variant=\"caption\" fontWeight={500} lineHeight={1}>\n                    {label}\n                  </Typography>\n                </Box>\n              </Box>\n              <Typography variant=\"caption\" fontSize={11.5} lineHeight={1}>\n                {sublabel}\n              </Typography>\n            </Box>\n          ))}\n        </Box>\n\n        <Typography variant=\"caption\" mt={1}>\n          AlphaFold produces a per-residue model confidence score (pLDDT) between 0 and 100. Some\n          regions below 50 pLDDT may be unstructured in isolation.\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// keep as closure since may need local state in future - such as hovered on atom\n// for highlighting\nfunction hoverManagerFactory({\n  viewer,\n  atomInfoRef,\n  parsedCif,\n  showModel,\n  chainToEntityDesc,\n  isAF,\n}) {\n  return [\n    {},\n    true,\n    (atom) => {\n      const infoElmt = atomInfoRef.current;\n      if (infoElmt) {\n        infoElmt.style.display = \"block\";\n        const fieldElmts = [...infoElmt.querySelectorAll(\"p\")];\n        const pdbModel = parsedCif[\"_atom_site.pdbx_PDB_model_num\"][atom.index];\n        const authChain = parsedCif[\"_atom_site.auth_asym_id\"][atom.index];\n        const pdbChain = parsedCif[\"_atom_site.label_asym_id\"][atom.index];\n        const authAtom = parsedCif[\"_atom_site.auth_seq_id\"][atom.index];\n        const pdbAtom = parsedCif[\"_atom_site.label_seq_id\"][atom.index];\n        fieldElmts[0].textContent = chainToEntityDesc[pdbChain];\n        fieldElmts[1].textContent = `${showModel ? `Model: ${pdbModel} | ` : \"\"}${pdbChain}${\n          authChain && authChain !== pdbChain ? ` (auth: ${authChain})` : \"\"\n        } | ${atom.resn} ${pdbAtom}${\n          authAtom && authAtom !== pdbAtom ? ` (auth: ${authAtom})` : \"\"\n        }`;\n        fieldElmts[2].textContent = isAF ? `Confidence: ${atom.b} (${getConfidence(atom)})` : \"\";\n      }\n    },\n    () => {\n      if (atomInfoRef.current) {\n        atomInfoRef.current.style.display = \"none\";\n      }\n    },\n  ];\n}\n\nfunction Body({ id: ensemblId, label: symbol, entity }) {\n  const [experimentalResults, setExperimentalResults] = useState(null);\n  const [segments, setSegments] = useState(null);\n  const [selectedStructure, setSelectedStructure] = useState(null);\n  const [viewer, setViewer] = useState(null);\n  const [structureLoading, setStructureLoading] = useState(true);\n\n  const viewerRef = useRef(null);\n  const structureInfoRef = useRef(null);\n  const atomInfoRef = useRef(null);\n  const messageRef = useRef(null);\n\n  const variables = { ensemblId };\n  const request = useQuery(PROTVISTA_QUERY, {\n    variables,\n  });\n\n  const uniprotId = request?.data?.target\n    ? getUniprotIds(request?.data?.target?.proteinIds)?.[0]\n    : null;\n\n  const columns = [\n    {\n      id: \"id\",\n      label: \"ID\",\n      sortable: true,\n    },\n    {\n      id: \"properties.method\",\n      label: \"Method\",\n      sortable: true,\n    },\n    {\n      id: \"properties.resolution\",\n      label: \"Resolution\",\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      comparator: nanComparator(\n        (a, b) => a - b,\n        (row) => +row?.properties?.resolution?.replace(/\\s*A/, \"\"),\n        false\n      ),\n      renderCell: ({ properties: { resolution } }) => {\n        return resolution != null ? resolution.replace(\"A\", \"Å\") : naLabel;\n      },\n      exportValue: ({ properties: { resolution } }) => {\n        return resolution?.replace(\"A\", \"Å\");\n      },\n    },\n    {\n      id: \"properties.chains\",\n      label: \"Chain\",\n      filterValue: false,\n      renderCell: ({ id }) => segments[id].chainsString,\n      exportValue: ({ id }) => segments[id].chainsString,\n    },\n    {\n      id: \"positions\",\n      label: \"Positions\",\n      sortable: true,\n      comparator: (a, b) => {\n        return segments?.[a?.id]?.maxLengthSegment - segments?.[b?.id]?.maxLengthSegment;\n      },\n      renderCell: ({ id }) => segments[id].segmentsString,\n      exportValue: ({ id }) => segments[id].segmentsString,\n    },\n    {\n      id: \"type\",\n      label: \"Source\",\n      sortable: true,\n      renderCell: ({ id, type }) => {\n        const url = isAlphaFold({ type })\n          ? `https://www.alphafold.ebi.ac.uk/entry/${uniprotId}`\n          : `https://www.ebi.ac.uk/pdbe/entry/pdb/${id}`;\n        return (\n          <Link external to={url}>\n            {type}\n          </Link>\n        );\n      },\n    },\n  ];\n\n  function getSelectedRows(selectedRows) {\n    selectedRows.length > 0 && setSelectedStructure(selectedRows[0]?.original);\n  }\n\n  function hideAtomInfo() {\n    if (atomInfoRef.current) atomInfoRef.current.style.display = \"none\";\n  }\n\n  function showLoadingMessage(message = \"Loading structure ...\") {\n    if (messageRef.current) {\n      setStructureLoading(true);\n      messageRef.current.style.display = \"flex\";\n      messageRef.current.textContent = message;\n    }\n  }\n\n  function hideLoadingMessage() {\n    if (messageRef.current) {\n      messageRef.current.style.display = \"none\";\n      setStructureLoading(false);\n    }\n  }\n\n  function onClickCapture() {\n    if (!viewerRef.current) return;\n\n    try {\n      // Get the canvas element from the container\n      const canvas = viewerRef.current.querySelector(\"canvas\");\n\n      if (!canvas) {\n        console.error(\"Canvas element not found\");\n        return;\n      }\n\n      // Create a new canvas with proper background\n      const newCanvas = document.createElement(\"canvas\");\n      newCanvas.width = canvas.width;\n      newCanvas.height = canvas.height;\n\n      const ctx = newCanvas.getContext(\"2d\");\n\n      // Draw background\n      ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);\n\n      // Draw original canvas content on top\n      ctx.drawImage(canvas, 0, 0);\n\n      // Convert the new canvas to data URL\n      const dataUrl = newCanvas.toDataURL(\"image/png\");\n\n      // Create a temporary link and trigger download\n      const link = document.createElement(\"a\");\n      link.href = dataUrl;\n      link.download = `${ensemblId}-molecular-structure.png`;\n      link.click();\n    } catch (error) {\n      console.error(\"Error taking screenshot:\", error);\n    } finally {\n      // setLoading(false);\n    }\n  }\n\n  function clearStructureInfo() {\n    structureInfoRef.current?.querySelectorAll(\"span\")?.forEach((span) => (span.textContent = \"\"));\n  }\n\n  // fetch experimental results\n  useEffect(() => {\n    const results = [];\n    async function fetchAlphaFoldResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${alphaFoldResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (AlphaFold request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            if (json.length > 0) {\n              results.unshift({\n                id: json[0].entryId,\n                type: \"AlphaFold\",\n                properties: {\n                  chains: `A=${json[0].uniprotStart}-${json[0].uniprotEnd}`,\n                  method: \"Prediction\",\n                  resolution: undefined,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchExperimentalResults() {\n      if (uniprotId) {\n        try {\n          const response = await fetch(`${experimentalResultsStem}${uniprotId}`);\n          if (!response.ok) {\n            console.error(`Response status (PDB request): ${response.status}`);\n          } else {\n            const json = await response.json();\n            const pdbResults = json?.dbReferences?.filter((row) => row.type === \"PDB\") ?? [];\n            results.push(...pdbResults);\n          }\n        } catch (error) {\n          console.error(error.message);\n        }\n      }\n    }\n    async function fetchAllResults() {\n      await Promise.allSettled([fetchAlphaFoldResults(), fetchExperimentalResults()]);\n      if (results.length) {\n        setExperimentalResults(results);\n        const _segments = {};\n        for (const row of results) {\n          _segments[row.id] = getSegments(row.id, row.properties.chains);\n        }\n        setSegments(_segments);\n        setSelectedStructure(results[0]);\n      }\n    }\n    fetchAllResults();\n    return () => {\n      setExperimentalResults(null);\n      setSegments(null);\n      setSelectedStructure(null);\n    };\n  }, [uniprotId, setExperimentalResults, setSegments, setSelectedStructure]);\n\n  // create viewer\n  useEffect(() => {\n    if (viewerRef.current && experimentalResults) {\n      setViewer(\n        createViewer(viewerRef.current, {\n          backgroundColor: \"#f8f8f8\",\n          antialias: true,\n          cartoonQuality: 10,\n        })\n      );\n    }\n    return () => {\n      viewer?.clear();\n      setViewer(null);\n    };\n  }, [experimentalResults, setViewer]);\n\n  // fetch selected structure and view it\n  useEffect(() => {\n    async function fetchStructure() {\n      if (selectedStructure && viewer) {\n        clearStructureInfo();\n        showLoadingMessage();\n\n        const isAF = isAlphaFold(selectedStructure);\n        const pdbUri = isAF\n          ? `${alphaFoldStructureStem}${selectedStructure.id}${alphaFoldStructureSuffix}`\n          : `${experimentalStructureStem}${selectedStructure.id.toLowerCase()}${experimentalStructureSuffix}`;\n\n        try {\n          const response = await fetch(pdbUri);\n          if (!response.ok) {\n            console.error(`Response status (CIF request): ${response.status}`);\n            showLoadingMessage(\"Failed to download structure data\");\n          } else {\n            let data;\n            let parsedCif;\n            try {\n              data = await response.text();\n              parsedCif = parseCif(data)[selectedStructure.id];\n            } catch (error) {\n              console.error(error.message);\n              showLoadingMessage(\"Failed to parse structure data\");\n            }\n            if (data && parsedCif) {\n              if (structureInfoRef.current) {\n                const [idElmt, titleElmt] = structureInfoRef.current.querySelectorAll(\"span\");\n                const title = isAF ? \"AlphaFold prediction\" : (parsedCif[\"_struct.title\"] ?? \"\");\n                idElmt.textContent = `${selectedStructure.id}${title ? \":\" : \"\"}`;\n                titleElmt.textContent = title;\n              }\n\n              // pdb <-> auth chains\n              // - may only need pdb -> auth, but is 1-to-many so get auth->pdb first\n              let authToPdbChain = null;\n              let pdbToAuthChain = null;\n              {\n                const authChains = parsedCif[\"_atom_site.auth_asym_id\"];\n                if (authChains) {\n                  const pdbChains = parsedCif[\"_atom_site.label_asym_id\"];\n                  const authChainsToMap = new Set(authChains);\n                  authToPdbChain = {};\n                  for (const [index, pdbChain] of pdbChains.entries()) {\n                    const authChain = authChains[index];\n                    if (authChainsToMap.has(authChain)) {\n                      authToPdbChain[authChain] = pdbChain;\n                      authChainsToMap.delete(authChain);\n                      if (authChainsToMap.size === 0) break;\n                    }\n                  }\n                  pdbToAuthChain = {};\n                  for (const [authChain, pdbChain] of Object.entries(authToPdbChain)) {\n                    pdbToAuthChain[pdbChain] ??= [];\n                    pdbToAuthChain[pdbChain].push(authChain);\n                  }\n                }\n              }\n\n              // structure chains - pdb chain names\n              const structureChains = parsedCif[\"_pdbx_struct_assembly_gen.asym_id_list\"];\n              let firstStructureChains;\n              let firstStructureTargetChains = [];\n              let firstStructureNonTargetChains = [];\n              let otherStructureChains;\n              const targetChains = segments[selectedStructure.id].uniqueChains; // auth names\n              const targetChainsPdb = new Set(\n                [...targetChains].map((chain) => authToPdbChain[chain])\n              );\n              if (structureChains) {\n                if (Array.isArray(structureChains)) {\n                  firstStructureChains = structureChains[0].split(\",\");\n                  otherStructureChains = structureChains.slice(1).join(\",\").split(\",\");\n                  const firstStructureChainsSet = new Set(firstStructureChains);\n                  otherStructureChains = otherStructureChains.filter(\n                    (chain) => !firstStructureChainsSet.has(chain)\n                  );\n                } else {\n                  firstStructureChains = structureChains.split(\",\");\n                  otherStructureChains = [];\n                }\n                for (const chain of firstStructureChains) {\n                  (targetChainsPdb.has(chain)\n                    ? firstStructureTargetChains\n                    : firstStructureNonTargetChains\n                  ).push(chain);\n                }\n              } else {\n                const allChains = new Set(parsedCif[\"_atom_site.label_asym_id\"]);\n                firstStructureChains = [...allChains];\n                firstStructureTargetChains.push(...targetChainsPdb);\n                firstStructureNonTargetChains = firstStructureChains.filter(\n                  (chain) => !targetChainsPdb.has(chain)\n                );\n                otherStructureChains = [];\n              }\n              if (pdbToAuthChain) {\n                firstStructureChains = firstStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureTargetChains = firstStructureTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                firstStructureNonTargetChains = firstStructureNonTargetChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n                otherStructureChains = otherStructureChains.flatMap(\n                  (chain) => pdbToAuthChain[chain]\n                );\n              }\n\n              // entities\n              const entityIdToDesc = zipToObject(\n                parsedCif[\"_entity.id\"],\n                parsedCif[\"_entity.pdbx_description\"]\n              );\n              const chainToEntityId = zipToObject(\n                parsedCif[\"_struct_asym.id\"],\n                parsedCif[\"_struct_asym.entity_id\"]\n              );\n              const chainToEntityDesc = {};\n              for (const chain of parsedCif[\"_struct_asym.id\"]) {\n                chainToEntityDesc[chain] = entityIdToDesc[chainToEntityId[chain]];\n              }\n\n              const scheme = {};\n              if (!isAF) {\n                firstStructureTargetChains.forEach((chain, index) => {\n                  scheme[chain] = chainColorScheme[index % chainColorScheme.length];\n                });\n              }\n\n              function resetViewer(duration = 0) {\n                viewer.zoomTo(\n                  {\n                    chain: firstStructureTargetChains.length\n                      ? firstStructureTargetChains\n                      : firstStructureChains,\n                  },\n                  duration\n                );\n                viewer.zoom(isAlphaFold(selectedStructure) ? 1.4 : 1, duration);\n              }\n\n              const hoverDuration = 50;\n              viewer.getCanvas().onmouseleave = () => {\n                setTimeout(hideAtomInfo, hoverDuration + 50);\n              };\n              viewer.getCanvas().ondblclick = () => resetViewer(200); // use ondblclick so replaces existing\n              viewer.addModel(data, \"cif\"); /* load data */\n              viewer.setHoverDuration(hoverDuration);\n              viewer.setHoverable(\n                ...hoverManagerFactory({\n                  viewer,\n                  atomInfoRef,\n                  parsedCif,\n                  showModel: new Set(parsedCif[\"_atom_site.pdbx_PDB_model_num\"]).size > 1,\n                  chainToEntityDesc,\n                  isAF,\n                })\n              );\n\n              if (isAF) {\n                viewer.setStyle(\n                  {},\n                  {\n                    cartoon: {\n                      colorfunc: (atom) => getConfidence(atom, \"color\"),\n                      arrows: true,\n                    },\n                  }\n                );\n              } else {\n                viewer.setStyle(\n                  { chain: firstStructureTargetChains },\n                  { cartoon: { colorfunc: (atom) => scheme[atom.chain], arrows: true } }\n                );\n                viewer.setStyle(\n                  { chain: firstStructureNonTargetChains },\n                  {\n                    cartoon: {\n                      color: \"#eee\",\n                      arrows: true,\n                      opacity: 0.8,\n                    },\n                  }\n                );\n                viewer.getModel().setStyle({ chain: otherStructureChains }, { hidden: true });\n              }\n              resetViewer();\n              viewer.render();\n              hideLoadingMessage();\n            }\n          }\n        } catch (error) {\n          console.error(error.message);\n          showLoadingMessage(\"Failed to download structure data\");\n        }\n      }\n    }\n    fetchStructure();\n    return () => {\n      hideAtomInfo();\n      viewer?.clear();\n    };\n  }, [selectedStructure, viewer, segments]);\n\n  if (!uniprotId) return null;\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => <Description symbol={symbol} />}\n      renderBody={() => {\n        if (!experimentalResults && !request.loading && uniprotId)\n          return <NoStructureAvailable uniprotId={uniprotId} />;\n\n        return (\n          <Grid container columnSpacing={2}>\n            <Grid item xs={12} lg={6}>\n              <OtTable\n                dataDownloader\n                showGlobalFilter\n                sortBy=\"positions\"\n                order=\"desc\"\n                columns={columns}\n                loading={request.loading}\n                rows={experimentalResults}\n                getSelectedRows={getSelectedRows}\n                query={PROTVISTA_QUERY.loc.source.body}\n                variables={variables}\n              />\n            </Grid>\n            <Grid item xs={12} lg={6}>\n              <Box\n                ref={structureInfoRef}\n                display=\"flex\"\n                alignItems=\"baseline\"\n                minHeight={22}\n                gap={0.5}\n                ml={2}\n                mt={0.75}\n                mb={1}\n              >\n                <Typography variant=\"subtitle2\" component=\"span\" />\n                <Typography variant=\"body2\" component=\"span\" />\n              </Box>\n              <Box position=\"relative\" display=\"flex\" justifyContent=\"center\" pb={2}>\n                <Box ref={viewerRef} position=\"relative\" width=\"100%\" height=\"400px\">\n                  <Typography\n                    ref={messageRef}\n                    variant=\"body2\"\n                    component=\"div\"\n                    sx={{\n                      top: 0,\n                      bottom: 0,\n                      left: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                    }}\n                  />\n                  <Box\n                    sx={{\n                      top: 0,\n                      right: 0,\n                      position: \"absolute\",\n                      zIndex: 1,\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\",\n                      background: \"white\",\n                      m: 1,\n                    }}\n                  >\n                    <Button\n                      sx={{ display: \"flex\", gap: 1 }}\n                      disabled={structureLoading}\n                      onClick={onClickCapture}\n                    >\n                      <FontAwesomeIcon icon={faCamera} /> Screenshot\n                    </Button>\n                  </Box>\n                  <Box\n                    ref={atomInfoRef}\n                    position=\"absolute\"\n                    bottom={0}\n                    right={0}\n                    p=\"0.6rem 0.8rem\"\n                    zIndex={100}\n                    bgcolor=\"#f8f8f8c8\"\n                    sx={{ borderTopLeftRadius: \"0.2rem\", pointerEvents: \"none\" }}\n                    fontSize={14}\n                  >\n                    <Box display=\"flex\" flexDirection=\"column\">\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                      <Typography variant=\"caption\" component=\"p\" textAlign=\"right\" />\n                    </Box>\n                  </Box>\n                </Box>\n              </Box>\n              {isAlphaFold(selectedStructure) && <AlphaFoldLegend />}\n            </Grid>\n          </Grid>\n        );\n      }}\n    />\n  );\n}\n\nfunction NoStructureAvailable({ uniprotId }) {\n  return (\n    <Box sx={{ display: \"flex\", justifyContent: \"center\", fontStyle: \"italic\" }}>\n      No Structure Available for {uniprotId}\n    </Box>\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noUnsafeOptionalChaining",
      "severity": "error",
      "description": "Unsafe usage of optional chaining.",
      "message": [{ "elements": [], "content": "Unsafe usage of optional chaining." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "If it short-circuits with 'undefined' the evaluation will throw TypeError here:"
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [6907, 6943],
              "sourceCode": "import { Box, Chip } from \"@mui/material\";\nimport { credsetConfidenceMap, naLabel, table5HChunkSize } from \"@ot/constants\";\nimport { mantissaExponentComparator, nullishComparator, variantComparator } from \"@ot/utils\";\nimport { Fragment } from \"react/jsx-runtime\";\nimport {\n  ClinvarStars,\n  DisplayVariantId,\n  L2GScoreIndicator,\n  Link,\n  Navigate,\n  OtTable,\n  ScientificNotation,\n  SectionItem,\n  Tooltip,\n  useBatchQuery,\n} from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport GWAS_CREDIBLE_SETS_QUERY from \"./GWASCredibleSetsQuery.gql\";\nimport PheWasPlot from \"./PheWasPlot\";\n\ntype getColumnsType = {\n  id: string;\n  referenceAllele: string;\n  alternateAllele: string;\n};\n\nfunction getColumns({ id, referenceAllele, alternateAllele }: getColumnsType) {\n  return [\n    {\n      id: \"studyLocusId\",\n      label: \"Credible set\",\n      sticky: true,\n      enableHiding: false,\n      renderCell: ({ studyLocusId }) => <Navigate to={`/credible-set/${studyLocusId}`} />,\n    },\n    {\n      id: \"leadVariant\",\n      label: \"Lead variant\",\n      enableHiding: false,\n      comparator: variantComparator((d) => d?.variant),\n      sortable: true,\n      filterValue: ({ variant: v }) =>\n        `${v?.chromosome}_${v?.position}_${v?.referenceAllele}_${v?.alternateAllele}`,\n      renderCell: ({ variant }) => {\n        if (!variant) return naLabel;\n        const { id: variantId, referenceAllele, alternateAllele } = variant;\n        const displayElement = (\n          <DisplayVariantId\n            variantId={variantId}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n        );\n        if (variantId === id) {\n          return (\n            <Box display=\"flex\" alignItems=\"center\" gap={0.5}>\n              {displayElement}\n              <Chip label=\"self\" variant=\"outlined\" size=\"small\" />\n            </Box>\n          );\n        }\n        return (\n          <Link asyncTooltip to={`/variant/${variantId}`}>\n            {displayElement}\n          </Link>\n        );\n      },\n      exportValue: ({ variant }) => variant?.id,\n    },\n    {\n      id: \"trait\",\n      label: \"Reported trait\",\n      filterValue: ({ study }) => study?.traitFromSource,\n      renderCell: ({ study }) => {\n        if (!study?.traitFromSource) return naLabel;\n        return study.traitFromSource;\n      },\n      exportValue: ({ study }) => study?.traitFromSource,\n    },\n    {\n      id: \"disease\",\n      label: \"Disease/phenotype\",\n      filterValue: ({ study }) => study?.diseases.map((d) => d.name).join(\", \"),\n      renderCell: ({ study }) => {\n        if (!study?.diseases?.length) return naLabel;\n        return (\n          <>\n            {study.diseases.map((d, i) => (\n              <Fragment key={d.id}>\n                {i > 0 && \", \"}\n                <Link asyncTooltip to={`../disease/${d.id}`}>\n                  {d.name}\n                </Link>\n              </Fragment>\n            ))}\n          </>\n        );\n      },\n      exportValue: ({ study }) => study?.diseases?.map((d) => d.name).join(\", \"),\n    },\n    {\n      id: \"studyId\",\n      label: \"Study\",\n      renderCell: ({ study }) => {\n        if (!study) return naLabel;\n        return (\n          <Link asyncTooltip to={`../study/${study.id}`}>\n            {study.id}\n          </Link>\n        );\n      },\n      exportValue: ({ study }) => study?.id,\n    },\n    {\n      id: \"pValue\",\n      label: \"P-value\",\n      numeric: true,\n      comparator: (a, b) =>\n        mantissaExponentComparator(\n          a?.pValueMantissa,\n          a?.pValueExponent,\n          b?.pValueMantissa,\n          b?.pValueExponent\n        ),\n      sortable: true,\n      filterValue: false,\n      renderCell: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\")\n          return naLabel;\n        return <ScientificNotation number={[pValueMantissa, pValueExponent]} dp={2} />;\n      },\n      exportValue: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\") return null;\n        return `${pValueMantissa}x10${pValueExponent}`;\n      },\n    },\n    {\n      id: \"beta\",\n      label: \"Beta\",\n      numeric: true,\n      filterValue: false,\n      tooltip: \"Beta with respect to the ALT allele\",\n      sortable: true,\n      renderCell: ({ beta }) => {\n        if (typeof beta !== \"number\") return naLabel;\n        return beta.toPrecision(3);\n      },\n    },\n    {\n      id: \"posteriorProbability\",\n      label: \"Posterior probability\",\n      numeric: true,\n      filterValue: false,\n      tooltip: (\n        <>\n          Posterior inclusion probability that the fixed page variant (\n          <DisplayVariantId\n            variantId={id}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n          ) is causal.\n        </>\n      ),\n      comparator: (a, b) => {\n        return (\n          a?.locus?.rows?.[0]?.posteriorProbability - b?.locus?.rows?.[0]?.posteriorProbability\n        );\n      },\n      sortable: true,\n      renderCell: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability.toPrecision(3) : naLabel,\n      exportValue: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability : naLabel,\n    },\n    {\n      id: \"finemappingMethod\",\n      label: \"Fine-mapping method\",\n    },\n    {\n      id: \"confidence\",\n      label: \"Fine-mapping confidence\",\n      tooltip: (\n        <>\n          Fine-mapping confidence based on the suitability of the linkage-disequilibrium information\n          and fine-mapping method. See{\" \"}\n          <Link\n            external\n            to=\"https://platform-docs.opentargets.org/credible-set#credible-set-confidence\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      sortable: true,\n      renderCell: ({ confidence }) => {\n        if (!confidence) return naLabel;\n        return (\n          <Tooltip title={confidence} style=\"\">\n            <ClinvarStars num={credsetConfidenceMap[confidence]} />\n          </Tooltip>\n        );\n      },\n      filterValue: ({ confidence }) => credsetConfidenceMap[confidence],\n    },\n    {\n      id: \"l2Gpredictions\",\n      label: \"Top L2G\",\n      filterValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target?.approvedSymbol,\n      tooltip: (\n        <>\n          Top gene prioritised by our locus-to-gene model. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ l2GPredictions }) => {\n        if (!l2GPredictions?.rows[0]?.target) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return (\n          <Link asyncTooltip to={`/target/${target.id}`}>\n            {target.approvedSymbol}\n          </Link>\n        );\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target.approvedSymbol,\n    },\n    {\n      id: \"l2gScore\",\n      label: \"L2G score\",\n      comparator: nullishComparator(\n        (a, b) => a - b,\n        (row) => row?.l2GPredictions?.rows[0]?.score,\n        false\n      ),\n      sortable: true,\n      tooltip: (\n        <>\n          Machine learning prediction linking a gene to a credible set using all features. Score\n          range [0,1]. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ studyLocusId, l2GPredictions }) => {\n        if (!l2GPredictions || !l2GPredictions.rows.length) return naLabel;\n        const score = l2GPredictions?.rows[0]?.score;\n        if (!score) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return <L2GScoreIndicator score={score} studyLocusId={studyLocusId} targetId={target.id} />;\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.score,\n    },\n    {\n      id: \"credibleSetSize\",\n      label: \"Credible set size\",\n      comparator: (a, b) => a.locusSize?.count - b.locusSize?.count,\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      renderCell: ({ locusSize }) => {\n        return typeof locusSize?.count === \"number\" ? locusSize.count.toLocaleString() : naLabel;\n      },\n      exportValue: ({ locusSize }) => locusSize?.count,\n    },\n  ];\n}\n\ntype BodyProps = {\n  id: string;\n  entity: string;\n};\n\nfunction Body({ id, entity }: BodyProps) {\n  const variables = {\n    variantId: id,\n    size: table5HChunkSize,\n    index: 0,\n  };\n\n  const request = useBatchQuery({\n    id,\n    query: GWAS_CREDIBLE_SETS_QUERY,\n    variables,\n    dataPath: \"variant.gwasCredibleSets\",\n    size: table5HChunkSize,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading\n      loadingMessage=\"Loading data. This may take some time...\"\n      renderDescription={() => (\n        <Description\n          variantId={request.data?.variant.id}\n          referenceAllele={request.data?.variant.referenceAllele}\n          alternateAllele={request.data?.variant.alternateAllele}\n        />\n      )}\n      renderChart={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <Box mb={1} ml={2}>\n            <PheWasPlot\n              columns={columns}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n              loading={request.loading}\n              data={request.data?.variant.gwasCredibleSets.rows}\n              pageId={id}\n              pageReferenceAllele={request.data?.variant.referenceAllele}\n              pageAlternateAllele={request.data?.variant.alternateAllele}\n            />\n          </Box>\n        );\n      }}\n      renderBody={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <>\n            <OtTable\n              dataDownloader\n              showGlobalFilter\n              sortBy=\"l2gScore\"\n              order=\"desc\"\n              columns={columns}\n              rows={request.data?.variant.gwasCredibleSets.rows}\n              loading={request.loading}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n            />\n          </>\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/variant/GWASCredibleSets/Body.tsx" },
        "span": [6934, 6936],
        "sourceCode": "import { Box, Chip } from \"@mui/material\";\nimport { credsetConfidenceMap, naLabel, table5HChunkSize } from \"@ot/constants\";\nimport { mantissaExponentComparator, nullishComparator, variantComparator } from \"@ot/utils\";\nimport { Fragment } from \"react/jsx-runtime\";\nimport {\n  ClinvarStars,\n  DisplayVariantId,\n  L2GScoreIndicator,\n  Link,\n  Navigate,\n  OtTable,\n  ScientificNotation,\n  SectionItem,\n  Tooltip,\n  useBatchQuery,\n} from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport GWAS_CREDIBLE_SETS_QUERY from \"./GWASCredibleSetsQuery.gql\";\nimport PheWasPlot from \"./PheWasPlot\";\n\ntype getColumnsType = {\n  id: string;\n  referenceAllele: string;\n  alternateAllele: string;\n};\n\nfunction getColumns({ id, referenceAllele, alternateAllele }: getColumnsType) {\n  return [\n    {\n      id: \"studyLocusId\",\n      label: \"Credible set\",\n      sticky: true,\n      enableHiding: false,\n      renderCell: ({ studyLocusId }) => <Navigate to={`/credible-set/${studyLocusId}`} />,\n    },\n    {\n      id: \"leadVariant\",\n      label: \"Lead variant\",\n      enableHiding: false,\n      comparator: variantComparator((d) => d?.variant),\n      sortable: true,\n      filterValue: ({ variant: v }) =>\n        `${v?.chromosome}_${v?.position}_${v?.referenceAllele}_${v?.alternateAllele}`,\n      renderCell: ({ variant }) => {\n        if (!variant) return naLabel;\n        const { id: variantId, referenceAllele, alternateAllele } = variant;\n        const displayElement = (\n          <DisplayVariantId\n            variantId={variantId}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n        );\n        if (variantId === id) {\n          return (\n            <Box display=\"flex\" alignItems=\"center\" gap={0.5}>\n              {displayElement}\n              <Chip label=\"self\" variant=\"outlined\" size=\"small\" />\n            </Box>\n          );\n        }\n        return (\n          <Link asyncTooltip to={`/variant/${variantId}`}>\n            {displayElement}\n          </Link>\n        );\n      },\n      exportValue: ({ variant }) => variant?.id,\n    },\n    {\n      id: \"trait\",\n      label: \"Reported trait\",\n      filterValue: ({ study }) => study?.traitFromSource,\n      renderCell: ({ study }) => {\n        if (!study?.traitFromSource) return naLabel;\n        return study.traitFromSource;\n      },\n      exportValue: ({ study }) => study?.traitFromSource,\n    },\n    {\n      id: \"disease\",\n      label: \"Disease/phenotype\",\n      filterValue: ({ study }) => study?.diseases.map((d) => d.name).join(\", \"),\n      renderCell: ({ study }) => {\n        if (!study?.diseases?.length) return naLabel;\n        return (\n          <>\n            {study.diseases.map((d, i) => (\n              <Fragment key={d.id}>\n                {i > 0 && \", \"}\n                <Link asyncTooltip to={`../disease/${d.id}`}>\n                  {d.name}\n                </Link>\n              </Fragment>\n            ))}\n          </>\n        );\n      },\n      exportValue: ({ study }) => study?.diseases?.map((d) => d.name).join(\", \"),\n    },\n    {\n      id: \"studyId\",\n      label: \"Study\",\n      renderCell: ({ study }) => {\n        if (!study) return naLabel;\n        return (\n          <Link asyncTooltip to={`../study/${study.id}`}>\n            {study.id}\n          </Link>\n        );\n      },\n      exportValue: ({ study }) => study?.id,\n    },\n    {\n      id: \"pValue\",\n      label: \"P-value\",\n      numeric: true,\n      comparator: (a, b) =>\n        mantissaExponentComparator(\n          a?.pValueMantissa,\n          a?.pValueExponent,\n          b?.pValueMantissa,\n          b?.pValueExponent\n        ),\n      sortable: true,\n      filterValue: false,\n      renderCell: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\")\n          return naLabel;\n        return <ScientificNotation number={[pValueMantissa, pValueExponent]} dp={2} />;\n      },\n      exportValue: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\") return null;\n        return `${pValueMantissa}x10${pValueExponent}`;\n      },\n    },\n    {\n      id: \"beta\",\n      label: \"Beta\",\n      numeric: true,\n      filterValue: false,\n      tooltip: \"Beta with respect to the ALT allele\",\n      sortable: true,\n      renderCell: ({ beta }) => {\n        if (typeof beta !== \"number\") return naLabel;\n        return beta.toPrecision(3);\n      },\n    },\n    {\n      id: \"posteriorProbability\",\n      label: \"Posterior probability\",\n      numeric: true,\n      filterValue: false,\n      tooltip: (\n        <>\n          Posterior inclusion probability that the fixed page variant (\n          <DisplayVariantId\n            variantId={id}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n          ) is causal.\n        </>\n      ),\n      comparator: (a, b) => {\n        return (\n          a?.locus?.rows?.[0]?.posteriorProbability - b?.locus?.rows?.[0]?.posteriorProbability\n        );\n      },\n      sortable: true,\n      renderCell: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability.toPrecision(3) : naLabel,\n      exportValue: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability : naLabel,\n    },\n    {\n      id: \"finemappingMethod\",\n      label: \"Fine-mapping method\",\n    },\n    {\n      id: \"confidence\",\n      label: \"Fine-mapping confidence\",\n      tooltip: (\n        <>\n          Fine-mapping confidence based on the suitability of the linkage-disequilibrium information\n          and fine-mapping method. See{\" \"}\n          <Link\n            external\n            to=\"https://platform-docs.opentargets.org/credible-set#credible-set-confidence\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      sortable: true,\n      renderCell: ({ confidence }) => {\n        if (!confidence) return naLabel;\n        return (\n          <Tooltip title={confidence} style=\"\">\n            <ClinvarStars num={credsetConfidenceMap[confidence]} />\n          </Tooltip>\n        );\n      },\n      filterValue: ({ confidence }) => credsetConfidenceMap[confidence],\n    },\n    {\n      id: \"l2Gpredictions\",\n      label: \"Top L2G\",\n      filterValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target?.approvedSymbol,\n      tooltip: (\n        <>\n          Top gene prioritised by our locus-to-gene model. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ l2GPredictions }) => {\n        if (!l2GPredictions?.rows[0]?.target) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return (\n          <Link asyncTooltip to={`/target/${target.id}`}>\n            {target.approvedSymbol}\n          </Link>\n        );\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target.approvedSymbol,\n    },\n    {\n      id: \"l2gScore\",\n      label: \"L2G score\",\n      comparator: nullishComparator(\n        (a, b) => a - b,\n        (row) => row?.l2GPredictions?.rows[0]?.score,\n        false\n      ),\n      sortable: true,\n      tooltip: (\n        <>\n          Machine learning prediction linking a gene to a credible set using all features. Score\n          range [0,1]. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ studyLocusId, l2GPredictions }) => {\n        if (!l2GPredictions || !l2GPredictions.rows.length) return naLabel;\n        const score = l2GPredictions?.rows[0]?.score;\n        if (!score) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return <L2GScoreIndicator score={score} studyLocusId={studyLocusId} targetId={target.id} />;\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.score,\n    },\n    {\n      id: \"credibleSetSize\",\n      label: \"Credible set size\",\n      comparator: (a, b) => a.locusSize?.count - b.locusSize?.count,\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      renderCell: ({ locusSize }) => {\n        return typeof locusSize?.count === \"number\" ? locusSize.count.toLocaleString() : naLabel;\n      },\n      exportValue: ({ locusSize }) => locusSize?.count,\n    },\n  ];\n}\n\ntype BodyProps = {\n  id: string;\n  entity: string;\n};\n\nfunction Body({ id, entity }: BodyProps) {\n  const variables = {\n    variantId: id,\n    size: table5HChunkSize,\n    index: 0,\n  };\n\n  const request = useBatchQuery({\n    id,\n    query: GWAS_CREDIBLE_SETS_QUERY,\n    variables,\n    dataPath: \"variant.gwasCredibleSets\",\n    size: table5HChunkSize,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading\n      loadingMessage=\"Loading data. This may take some time...\"\n      renderDescription={() => (\n        <Description\n          variantId={request.data?.variant.id}\n          referenceAllele={request.data?.variant.referenceAllele}\n          alternateAllele={request.data?.variant.alternateAllele}\n        />\n      )}\n      renderChart={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <Box mb={1} ml={2}>\n            <PheWasPlot\n              columns={columns}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n              loading={request.loading}\n              data={request.data?.variant.gwasCredibleSets.rows}\n              pageId={id}\n              pageReferenceAllele={request.data?.variant.referenceAllele}\n              pageAlternateAllele={request.data?.variant.alternateAllele}\n            />\n          </Box>\n        );\n      }}\n      renderBody={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <>\n            <OtTable\n              dataDownloader\n              showGlobalFilter\n              sortBy=\"l2gScore\"\n              order=\"desc\"\n              columns={columns}\n              rows={request.data?.variant.gwasCredibleSets.rows}\n              loading={request.loading}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n            />\n          </>\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noUnsafeOptionalChaining",
      "severity": "error",
      "description": "Unsafe usage of optional chaining.",
      "message": [{ "elements": [], "content": "Unsafe usage of optional chaining." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "If it short-circuits with 'undefined' the evaluation will throw TypeError here:"
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [8004, 8040],
              "sourceCode": "import { Box, Chip } from \"@mui/material\";\nimport { credsetConfidenceMap, naLabel, table5HChunkSize } from \"@ot/constants\";\nimport { mantissaExponentComparator, nullishComparator, variantComparator } from \"@ot/utils\";\nimport { Fragment } from \"react/jsx-runtime\";\nimport {\n  ClinvarStars,\n  DisplayVariantId,\n  L2GScoreIndicator,\n  Link,\n  Navigate,\n  OtTable,\n  ScientificNotation,\n  SectionItem,\n  Tooltip,\n  useBatchQuery,\n} from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport GWAS_CREDIBLE_SETS_QUERY from \"./GWASCredibleSetsQuery.gql\";\nimport PheWasPlot from \"./PheWasPlot\";\n\ntype getColumnsType = {\n  id: string;\n  referenceAllele: string;\n  alternateAllele: string;\n};\n\nfunction getColumns({ id, referenceAllele, alternateAllele }: getColumnsType) {\n  return [\n    {\n      id: \"studyLocusId\",\n      label: \"Credible set\",\n      sticky: true,\n      enableHiding: false,\n      renderCell: ({ studyLocusId }) => <Navigate to={`/credible-set/${studyLocusId}`} />,\n    },\n    {\n      id: \"leadVariant\",\n      label: \"Lead variant\",\n      enableHiding: false,\n      comparator: variantComparator((d) => d?.variant),\n      sortable: true,\n      filterValue: ({ variant: v }) =>\n        `${v?.chromosome}_${v?.position}_${v?.referenceAllele}_${v?.alternateAllele}`,\n      renderCell: ({ variant }) => {\n        if (!variant) return naLabel;\n        const { id: variantId, referenceAllele, alternateAllele } = variant;\n        const displayElement = (\n          <DisplayVariantId\n            variantId={variantId}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n        );\n        if (variantId === id) {\n          return (\n            <Box display=\"flex\" alignItems=\"center\" gap={0.5}>\n              {displayElement}\n              <Chip label=\"self\" variant=\"outlined\" size=\"small\" />\n            </Box>\n          );\n        }\n        return (\n          <Link asyncTooltip to={`/variant/${variantId}`}>\n            {displayElement}\n          </Link>\n        );\n      },\n      exportValue: ({ variant }) => variant?.id,\n    },\n    {\n      id: \"trait\",\n      label: \"Reported trait\",\n      filterValue: ({ study }) => study?.traitFromSource,\n      renderCell: ({ study }) => {\n        if (!study?.traitFromSource) return naLabel;\n        return study.traitFromSource;\n      },\n      exportValue: ({ study }) => study?.traitFromSource,\n    },\n    {\n      id: \"disease\",\n      label: \"Disease/phenotype\",\n      filterValue: ({ study }) => study?.diseases.map((d) => d.name).join(\", \"),\n      renderCell: ({ study }) => {\n        if (!study?.diseases?.length) return naLabel;\n        return (\n          <>\n            {study.diseases.map((d, i) => (\n              <Fragment key={d.id}>\n                {i > 0 && \", \"}\n                <Link asyncTooltip to={`../disease/${d.id}`}>\n                  {d.name}\n                </Link>\n              </Fragment>\n            ))}\n          </>\n        );\n      },\n      exportValue: ({ study }) => study?.diseases?.map((d) => d.name).join(\", \"),\n    },\n    {\n      id: \"studyId\",\n      label: \"Study\",\n      renderCell: ({ study }) => {\n        if (!study) return naLabel;\n        return (\n          <Link asyncTooltip to={`../study/${study.id}`}>\n            {study.id}\n          </Link>\n        );\n      },\n      exportValue: ({ study }) => study?.id,\n    },\n    {\n      id: \"pValue\",\n      label: \"P-value\",\n      numeric: true,\n      comparator: (a, b) =>\n        mantissaExponentComparator(\n          a?.pValueMantissa,\n          a?.pValueExponent,\n          b?.pValueMantissa,\n          b?.pValueExponent\n        ),\n      sortable: true,\n      filterValue: false,\n      renderCell: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\")\n          return naLabel;\n        return <ScientificNotation number={[pValueMantissa, pValueExponent]} dp={2} />;\n      },\n      exportValue: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\") return null;\n        return `${pValueMantissa}x10${pValueExponent}`;\n      },\n    },\n    {\n      id: \"beta\",\n      label: \"Beta\",\n      numeric: true,\n      filterValue: false,\n      tooltip: \"Beta with respect to the ALT allele\",\n      sortable: true,\n      renderCell: ({ beta }) => {\n        if (typeof beta !== \"number\") return naLabel;\n        return beta.toPrecision(3);\n      },\n    },\n    {\n      id: \"posteriorProbability\",\n      label: \"Posterior probability\",\n      numeric: true,\n      filterValue: false,\n      tooltip: (\n        <>\n          Posterior inclusion probability that the fixed page variant (\n          <DisplayVariantId\n            variantId={id}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n          ) is causal.\n        </>\n      ),\n      comparator: (a, b) => {\n        return (\n          a?.locus?.rows?.[0]?.posteriorProbability - b?.locus?.rows?.[0]?.posteriorProbability\n        );\n      },\n      sortable: true,\n      renderCell: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability.toPrecision(3) : naLabel,\n      exportValue: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability : naLabel,\n    },\n    {\n      id: \"finemappingMethod\",\n      label: \"Fine-mapping method\",\n    },\n    {\n      id: \"confidence\",\n      label: \"Fine-mapping confidence\",\n      tooltip: (\n        <>\n          Fine-mapping confidence based on the suitability of the linkage-disequilibrium information\n          and fine-mapping method. See{\" \"}\n          <Link\n            external\n            to=\"https://platform-docs.opentargets.org/credible-set#credible-set-confidence\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      sortable: true,\n      renderCell: ({ confidence }) => {\n        if (!confidence) return naLabel;\n        return (\n          <Tooltip title={confidence} style=\"\">\n            <ClinvarStars num={credsetConfidenceMap[confidence]} />\n          </Tooltip>\n        );\n      },\n      filterValue: ({ confidence }) => credsetConfidenceMap[confidence],\n    },\n    {\n      id: \"l2Gpredictions\",\n      label: \"Top L2G\",\n      filterValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target?.approvedSymbol,\n      tooltip: (\n        <>\n          Top gene prioritised by our locus-to-gene model. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ l2GPredictions }) => {\n        if (!l2GPredictions?.rows[0]?.target) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return (\n          <Link asyncTooltip to={`/target/${target.id}`}>\n            {target.approvedSymbol}\n          </Link>\n        );\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target.approvedSymbol,\n    },\n    {\n      id: \"l2gScore\",\n      label: \"L2G score\",\n      comparator: nullishComparator(\n        (a, b) => a - b,\n        (row) => row?.l2GPredictions?.rows[0]?.score,\n        false\n      ),\n      sortable: true,\n      tooltip: (\n        <>\n          Machine learning prediction linking a gene to a credible set using all features. Score\n          range [0,1]. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ studyLocusId, l2GPredictions }) => {\n        if (!l2GPredictions || !l2GPredictions.rows.length) return naLabel;\n        const score = l2GPredictions?.rows[0]?.score;\n        if (!score) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return <L2GScoreIndicator score={score} studyLocusId={studyLocusId} targetId={target.id} />;\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.score,\n    },\n    {\n      id: \"credibleSetSize\",\n      label: \"Credible set size\",\n      comparator: (a, b) => a.locusSize?.count - b.locusSize?.count,\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      renderCell: ({ locusSize }) => {\n        return typeof locusSize?.count === \"number\" ? locusSize.count.toLocaleString() : naLabel;\n      },\n      exportValue: ({ locusSize }) => locusSize?.count,\n    },\n  ];\n}\n\ntype BodyProps = {\n  id: string;\n  entity: string;\n};\n\nfunction Body({ id, entity }: BodyProps) {\n  const variables = {\n    variantId: id,\n    size: table5HChunkSize,\n    index: 0,\n  };\n\n  const request = useBatchQuery({\n    id,\n    query: GWAS_CREDIBLE_SETS_QUERY,\n    variables,\n    dataPath: \"variant.gwasCredibleSets\",\n    size: table5HChunkSize,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading\n      loadingMessage=\"Loading data. This may take some time...\"\n      renderDescription={() => (\n        <Description\n          variantId={request.data?.variant.id}\n          referenceAllele={request.data?.variant.referenceAllele}\n          alternateAllele={request.data?.variant.alternateAllele}\n        />\n      )}\n      renderChart={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <Box mb={1} ml={2}>\n            <PheWasPlot\n              columns={columns}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n              loading={request.loading}\n              data={request.data?.variant.gwasCredibleSets.rows}\n              pageId={id}\n              pageReferenceAllele={request.data?.variant.referenceAllele}\n              pageAlternateAllele={request.data?.variant.alternateAllele}\n            />\n          </Box>\n        );\n      }}\n      renderBody={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <>\n            <OtTable\n              dataDownloader\n              showGlobalFilter\n              sortBy=\"l2gScore\"\n              order=\"desc\"\n              columns={columns}\n              rows={request.data?.variant.gwasCredibleSets.rows}\n              loading={request.loading}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n            />\n          </>\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/variant/GWASCredibleSets/Body.tsx" },
        "span": [8031, 8033],
        "sourceCode": "import { Box, Chip } from \"@mui/material\";\nimport { credsetConfidenceMap, naLabel, table5HChunkSize } from \"@ot/constants\";\nimport { mantissaExponentComparator, nullishComparator, variantComparator } from \"@ot/utils\";\nimport { Fragment } from \"react/jsx-runtime\";\nimport {\n  ClinvarStars,\n  DisplayVariantId,\n  L2GScoreIndicator,\n  Link,\n  Navigate,\n  OtTable,\n  ScientificNotation,\n  SectionItem,\n  Tooltip,\n  useBatchQuery,\n} from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport GWAS_CREDIBLE_SETS_QUERY from \"./GWASCredibleSetsQuery.gql\";\nimport PheWasPlot from \"./PheWasPlot\";\n\ntype getColumnsType = {\n  id: string;\n  referenceAllele: string;\n  alternateAllele: string;\n};\n\nfunction getColumns({ id, referenceAllele, alternateAllele }: getColumnsType) {\n  return [\n    {\n      id: \"studyLocusId\",\n      label: \"Credible set\",\n      sticky: true,\n      enableHiding: false,\n      renderCell: ({ studyLocusId }) => <Navigate to={`/credible-set/${studyLocusId}`} />,\n    },\n    {\n      id: \"leadVariant\",\n      label: \"Lead variant\",\n      enableHiding: false,\n      comparator: variantComparator((d) => d?.variant),\n      sortable: true,\n      filterValue: ({ variant: v }) =>\n        `${v?.chromosome}_${v?.position}_${v?.referenceAllele}_${v?.alternateAllele}`,\n      renderCell: ({ variant }) => {\n        if (!variant) return naLabel;\n        const { id: variantId, referenceAllele, alternateAllele } = variant;\n        const displayElement = (\n          <DisplayVariantId\n            variantId={variantId}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n        );\n        if (variantId === id) {\n          return (\n            <Box display=\"flex\" alignItems=\"center\" gap={0.5}>\n              {displayElement}\n              <Chip label=\"self\" variant=\"outlined\" size=\"small\" />\n            </Box>\n          );\n        }\n        return (\n          <Link asyncTooltip to={`/variant/${variantId}`}>\n            {displayElement}\n          </Link>\n        );\n      },\n      exportValue: ({ variant }) => variant?.id,\n    },\n    {\n      id: \"trait\",\n      label: \"Reported trait\",\n      filterValue: ({ study }) => study?.traitFromSource,\n      renderCell: ({ study }) => {\n        if (!study?.traitFromSource) return naLabel;\n        return study.traitFromSource;\n      },\n      exportValue: ({ study }) => study?.traitFromSource,\n    },\n    {\n      id: \"disease\",\n      label: \"Disease/phenotype\",\n      filterValue: ({ study }) => study?.diseases.map((d) => d.name).join(\", \"),\n      renderCell: ({ study }) => {\n        if (!study?.diseases?.length) return naLabel;\n        return (\n          <>\n            {study.diseases.map((d, i) => (\n              <Fragment key={d.id}>\n                {i > 0 && \", \"}\n                <Link asyncTooltip to={`../disease/${d.id}`}>\n                  {d.name}\n                </Link>\n              </Fragment>\n            ))}\n          </>\n        );\n      },\n      exportValue: ({ study }) => study?.diseases?.map((d) => d.name).join(\", \"),\n    },\n    {\n      id: \"studyId\",\n      label: \"Study\",\n      renderCell: ({ study }) => {\n        if (!study) return naLabel;\n        return (\n          <Link asyncTooltip to={`../study/${study.id}`}>\n            {study.id}\n          </Link>\n        );\n      },\n      exportValue: ({ study }) => study?.id,\n    },\n    {\n      id: \"pValue\",\n      label: \"P-value\",\n      numeric: true,\n      comparator: (a, b) =>\n        mantissaExponentComparator(\n          a?.pValueMantissa,\n          a?.pValueExponent,\n          b?.pValueMantissa,\n          b?.pValueExponent\n        ),\n      sortable: true,\n      filterValue: false,\n      renderCell: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\")\n          return naLabel;\n        return <ScientificNotation number={[pValueMantissa, pValueExponent]} dp={2} />;\n      },\n      exportValue: ({ pValueMantissa, pValueExponent }) => {\n        if (typeof pValueMantissa !== \"number\" || typeof pValueExponent !== \"number\") return null;\n        return `${pValueMantissa}x10${pValueExponent}`;\n      },\n    },\n    {\n      id: \"beta\",\n      label: \"Beta\",\n      numeric: true,\n      filterValue: false,\n      tooltip: \"Beta with respect to the ALT allele\",\n      sortable: true,\n      renderCell: ({ beta }) => {\n        if (typeof beta !== \"number\") return naLabel;\n        return beta.toPrecision(3);\n      },\n    },\n    {\n      id: \"posteriorProbability\",\n      label: \"Posterior probability\",\n      numeric: true,\n      filterValue: false,\n      tooltip: (\n        <>\n          Posterior inclusion probability that the fixed page variant (\n          <DisplayVariantId\n            variantId={id}\n            referenceAllele={referenceAllele}\n            alternateAllele={alternateAllele}\n            expand={false}\n          />\n          ) is causal.\n        </>\n      ),\n      comparator: (a, b) => {\n        return (\n          a?.locus?.rows?.[0]?.posteriorProbability - b?.locus?.rows?.[0]?.posteriorProbability\n        );\n      },\n      sortable: true,\n      renderCell: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability.toPrecision(3) : naLabel,\n      exportValue: ({ locus }) =>\n        locus.rows.length > 0 ? locus?.rows[0]?.posteriorProbability : naLabel,\n    },\n    {\n      id: \"finemappingMethod\",\n      label: \"Fine-mapping method\",\n    },\n    {\n      id: \"confidence\",\n      label: \"Fine-mapping confidence\",\n      tooltip: (\n        <>\n          Fine-mapping confidence based on the suitability of the linkage-disequilibrium information\n          and fine-mapping method. See{\" \"}\n          <Link\n            external\n            to=\"https://platform-docs.opentargets.org/credible-set#credible-set-confidence\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      sortable: true,\n      renderCell: ({ confidence }) => {\n        if (!confidence) return naLabel;\n        return (\n          <Tooltip title={confidence} style=\"\">\n            <ClinvarStars num={credsetConfidenceMap[confidence]} />\n          </Tooltip>\n        );\n      },\n      filterValue: ({ confidence }) => credsetConfidenceMap[confidence],\n    },\n    {\n      id: \"l2Gpredictions\",\n      label: \"Top L2G\",\n      filterValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target?.approvedSymbol,\n      tooltip: (\n        <>\n          Top gene prioritised by our locus-to-gene model. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ l2GPredictions }) => {\n        if (!l2GPredictions?.rows[0]?.target) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return (\n          <Link asyncTooltip to={`/target/${target.id}`}>\n            {target.approvedSymbol}\n          </Link>\n        );\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.target.approvedSymbol,\n    },\n    {\n      id: \"l2gScore\",\n      label: \"L2G score\",\n      comparator: nullishComparator(\n        (a, b) => a - b,\n        (row) => row?.l2GPredictions?.rows[0]?.score,\n        false\n      ),\n      sortable: true,\n      tooltip: (\n        <>\n          Machine learning prediction linking a gene to a credible set using all features. Score\n          range [0,1]. See{\" \"}\n          <Link external to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g\">\n            our documentation\n          </Link>{\" \"}\n          for more information.\n        </>\n      ),\n      renderCell: ({ studyLocusId, l2GPredictions }) => {\n        if (!l2GPredictions || !l2GPredictions.rows.length) return naLabel;\n        const score = l2GPredictions?.rows[0]?.score;\n        if (!score) return naLabel;\n        const { target } = l2GPredictions?.rows[0];\n        return <L2GScoreIndicator score={score} studyLocusId={studyLocusId} targetId={target.id} />;\n      },\n      exportValue: ({ l2GPredictions }) => l2GPredictions?.rows[0]?.score,\n    },\n    {\n      id: \"credibleSetSize\",\n      label: \"Credible set size\",\n      comparator: (a, b) => a.locusSize?.count - b.locusSize?.count,\n      sortable: true,\n      numeric: true,\n      filterValue: false,\n      renderCell: ({ locusSize }) => {\n        return typeof locusSize?.count === \"number\" ? locusSize.count.toLocaleString() : naLabel;\n      },\n      exportValue: ({ locusSize }) => locusSize?.count,\n    },\n  ];\n}\n\ntype BodyProps = {\n  id: string;\n  entity: string;\n};\n\nfunction Body({ id, entity }: BodyProps) {\n  const variables = {\n    variantId: id,\n    size: table5HChunkSize,\n    index: 0,\n  };\n\n  const request = useBatchQuery({\n    id,\n    query: GWAS_CREDIBLE_SETS_QUERY,\n    variables,\n    dataPath: \"variant.gwasCredibleSets\",\n    size: table5HChunkSize,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      showContentLoading\n      loadingMessage=\"Loading data. This may take some time...\"\n      renderDescription={() => (\n        <Description\n          variantId={request.data?.variant.id}\n          referenceAllele={request.data?.variant.referenceAllele}\n          alternateAllele={request.data?.variant.alternateAllele}\n        />\n      )}\n      renderChart={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <Box mb={1} ml={2}>\n            <PheWasPlot\n              columns={columns}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n              loading={request.loading}\n              data={request.data?.variant.gwasCredibleSets.rows}\n              pageId={id}\n              pageReferenceAllele={request.data?.variant.referenceAllele}\n              pageAlternateAllele={request.data?.variant.alternateAllele}\n            />\n          </Box>\n        );\n      }}\n      renderBody={() => {\n        const columns = getColumns({\n          id,\n          referenceAllele: request.data?.variant.referenceAllele,\n          alternateAllele: request.data?.variant.alternateAllele,\n        });\n        return (\n          <>\n            <OtTable\n              dataDownloader\n              showGlobalFilter\n              sortBy=\"l2gScore\"\n              order=\"desc\"\n              columns={columns}\n              rows={request.data?.variant.gwasCredibleSets.rows}\n              loading={request.loading}\n              query={GWAS_CREDIBLE_SETS_QUERY.loc.source.body}\n              variables={variables}\n            />\n          </>\n        );\n      }}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/sections/src/variant/Pharmacogenomics/Body.tsx" },
        "span": [6110, 6116],
        "sourceCode": "import { useQuery } from \"@apollo/client\";\nimport { faCircleXmark } from \"@fortawesome/free-regular-svg-icons\";\nimport { faCircleCheck } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { makeStyles } from \"@mui/styles\";\nimport { PHARM_GKB_COLOR, naLabel } from \"@ot/constants\";\nimport { epmcUrl } from \"@ot/utils\";\nimport classNames from \"classnames\";\nimport { Fragment } from \"react\";\nimport { Link, OtTable, PublicationsDrawer, SectionItem, Tooltip } from \"ui\";\nimport { definition } from \".\";\nimport Description from \"./Description\";\nimport PHARMACOGENOMICS_QUERY from \"./PharmacogenomicsQuery.gql\";\n\nconst useStyles = makeStyles((theme) => ({\n  level: {\n    color: \"white\",\n    padding: theme.spacing(0.5),\n    borderRadius: theme.spacing(0.5),\n  },\n  green: {\n    background: PHARM_GKB_COLOR.green,\n  },\n  red: {\n    background: PHARM_GKB_COLOR.red,\n  },\n  yellow: {\n    background: PHARM_GKB_COLOR.yellow,\n  },\n  blue: {\n    background: theme.palette.primary.main,\n  },\n  blueIcon: {\n    color: theme.palette.primary.main,\n  },\n}));\n\nconst getLevelElementClassName = (level: string) => {\n  switch (level) {\n    case \"1\":\n      return \"green\";\n    case \"1A\":\n      return \"green\";\n    case \"1B\":\n      return \"green\";\n    case \"2\":\n      return \"blue\";\n    case \"2A\":\n      return \"blue\";\n    case \"2B\":\n      return \"blue\";\n    case \"3\":\n      return \"yellow\";\n    case \"4\":\n      return \"red\";\n    default:\n      return \"red\";\n  }\n};\n\ntype BodyProps = {\n  id: string;\n  entity: string;\n};\n\nfunction Body({ id, entity }: BodyProps) {\n  const variables = { variantId: id };\n\n  const classes = useStyles();\n  const columns = [\n    {\n      id: \"genotypeId\",\n      label: \"Genotype ID\",\n      enableHiding: false,\n      tooltip: (\n        <>\n          VCF-style(chr_pos_ref_allele1,allele2). See{\" \"}\n          <Link\n            external\n            to=\"https://github.com/apriltuesday/opentargets-pharmgkb/tree/issue-18#variant-coordinate-computation\"\n          >\n            here\n          </Link>{\" \"}\n          for more details.\n        </>\n      ),\n      renderCell: ({ genotypeId }) => genotypeId || naLabel,\n    },\n    {\n      id: \"drugs\",\n      label: \"Drug(s)\",\n      renderCell: ({ drugs }) => {\n        const drugsInfo = drugs.filter((d) => d.drugId || d.drugFromSource);\n        if (!drugsInfo.length) return naLabel;\n        return (\n          <>\n            {drugsInfo.map(({ drugId, drugFromSource }, i) => {\n              const drugText = drugFromSource ? drugFromSource.toUpperCase() : drugId;\n              return (\n                <Fragment key={drugText}>\n                  {i > 0 && \", \"}\n                  {drugId ? (\n                    <Link asyncTooltip to={`/drug/${drugId}`}>\n                      {drugText}\n                    </Link>\n                  ) : (\n                    drugText\n                  )}\n                </Fragment>\n              );\n            })}\n          </>\n        );\n      },\n      filterValue: ({ drugs }) =>\n        drugs.map((d) => `${d.drugFromSource ?? \"\"} ${d.drugId ?? \"\"}`).join(\" \"),\n    },\n    {\n      id: \"genotypeAnnotationText\",\n      label: \"Drug response phenotype\",\n      renderCell: ({ phenotypeText, phenotypeFromSourceId, genotypeAnnotationText }) => {\n        if (!phenotypeText) return naLabel;\n        let phenotypeTextElement = phenotypeText;\n        if (phenotypeFromSourceId)\n          phenotypeTextElement = (\n            <Link asyncTooltip to={`/disease/${phenotypeFromSourceId}`}>\n              {phenotypeTextElement}\n            </Link>\n          );\n        if (genotypeAnnotationText)\n          phenotypeTextElement = (\n            <Tooltip style=\"\" title={genotypeAnnotationText} showHelpIcon>\n              {phenotypeTextElement}\n            </Tooltip>\n          );\n        return phenotypeTextElement;\n      },\n      filterValue: ({ phenotypeText }) => phenotypeText,\n    },\n    {\n      id: \"pgxCategory\",\n      label: \"Drug response category\",\n      renderCell: ({ pgxCategory }) => pgxCategory || naLabel,\n      filterValue: ({ pgxCategory }) => pgxCategory,\n    },\n    {\n      id: \"target.approvedSymbol\",\n      label: \"Gene\",\n      renderCell: ({ target }) => {\n        if (!target) return naLabel;\n        return (\n          <Link asyncTooltip to={`/target/${target.id}`}>\n            {target.approvedSymbol}\n          </Link>\n        );\n      },\n      filterValue: ({ target }) => target.approvedSymbol,\n    },\n    {\n      id: \"isDirectTarget\",\n      label: \"Direct drug target\",\n      renderCell: ({ isDirectTarget }) => {\n        const ICON_NAME = isDirectTarget ? faCircleCheck : faCircleXmark;\n        return <FontAwesomeIcon icon={ICON_NAME} size=\"lg\" className={classes.blueIcon} />;\n      },\n    },\n    {\n      id: \"evidenceLevel\",\n      label: \"Confidence level\",\n      comparator: (a, b) => (b.evidenceLevel < a.evidenceLevel ? 1 : -1),\n      sortable: true,\n      tooltip: (\n        <>\n          As defined by\n          <Link external to={\"https://www.pharmgkb.org/page/clinAnnLevels\"}>\n            {\" \"}\n            PharmGKB ClinAnn Levels\n          </Link>\n        </>\n      ),\n      renderCell: ({ evidenceLevel }) => {\n        if (evidenceLevel) {\n          const levelClass = getLevelElementClassName(evidenceLevel);\n          return (\n            <span className={classNames(classes.level, classes[levelClass])}>\n              Level {evidenceLevel}\n            </span>\n          );\n        }\n        return naLabel;\n      },\n      filterValue: ({ evidenceLevel }) => `Level ${evidenceLevel}`,\n    },\n    {\n      id: \"source\",\n      label: \"Source\",\n      renderCell: ({ studyId }) =>\n        studyId ? (\n          <Link external to={`https://www.pharmgkb.org/clinicalAnnotation/${studyId}`}>\n            PharmGKB\n          </Link>\n        ) : (\n          naLabel\n        ),\n    },\n    {\n      id: \"literature\",\n      label: \"Literature\",\n      renderCell: ({ literature }) => {\n        const literatureList =\n          literature?.reduce((acc, id) => {\n            if (id === \"NA\") return acc;\n            return [\n              ...acc,\n              {\n                name: id,\n                url: epmcUrl(id),\n                group: \"literature\",\n              },\n            ];\n          }, []) || [];\n        return <PublicationsDrawer entries={literatureList} />;\n      },\n    },\n  ];\n\n  const request = useQuery(PHARMACOGENOMICS_QUERY, {\n    variables,\n  });\n\n  return (\n    <SectionItem\n      definition={definition}\n      entity={entity}\n      request={request}\n      renderDescription={() => (\n        <Description\n          variantId={request.data?.variant.id}\n          referenceAllele={request.data?.variant.referenceAllele}\n          alternateAllele={request.data?.variant.alternateAllele}\n        />\n      )}\n      renderBody={() => (\n        <OtTable\n          showGlobalFilter\n          dataDownloader\n          sortBy=\"evidenceLevel\"\n          columns={columns}\n          rows={request.data?.variant.pharmacogenomics}\n          query={PHARMACOGENOMICS_QUERY.loc.source.body}\n          variables={variables}\n          loading={request.loading}\n        />\n      )}\n    />\n  );\n}\n\nexport default Body;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/utils/tableUtils.ts" },
        "span": [501, 774],
        "sourceCode": "import type { DefaultSortProp, loadingTableRows } from \"./table.types\";\n\n/*********************************************************************\n * FN TO CONVERT CLASSIC MUI TABLE COLUMNS TO TANSTACK TABLE COLUMNS *\n * RECURSIVE FN TO CHECK IF COLUMNS ARE NESTED\n *********************************************************************/\nexport function mapTableColumnToTanstackColumns(\n  allColumns: Record<string, unknown>[]\n): Record<string, unknown>[] {\n  const arr: Record<string, unknown>[] = [];\n  allColumns.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: mapTableColumnToTanstackColumns(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push(mapToTanstackColumnObject(e));\n  });\n  return arr;\n}\n\n/******************************************************\n * FLATTENS THE OBJECT RETURNS THE VALUES AS A STRING *\n * @param: object \n * const ob = {\n    disease: {\n        name: \"cancer\"\n        id: \"MONDO_0004992\"\n    }\n  };\n  @example: getFilterValueFromObject(ob)\n  @return: 'cancer MONDO_0004992'\n ******************************************************/\nexport function getFilterValueFromObject(obj: Record<string, unknown>): string {\n  const flatObj = flattenObj(obj);\n  return Object.values(flatObj).join(\" \");\n}\n\n/**********************************************************\n * FN TO RETURN SORT OBJECT REQUIRED BY TANSTACK TABLE STATE *\n * @param:\n *  sortBy: type string\n *  order: type string\n * @example: getDefaultSortObj(\"pValue\", \"asc\")\n * @return: { id: \"pValue\", desc: false}: type DefaultSortProp\n **********************************************************/\nexport function getDefaultSortObj(sortBy: string, order: string): DefaultSortProp {\n  if (!sortBy) return undefined;\n  return [\n    {\n      id: sortBy,\n      desc: order === \"desc\",\n    },\n  ];\n}\n\n/*****************************************************\n * CONVERT THE NESTED OBJECT TO FLAT OBJECT *\n * @param: object \n *  const ob = {\n      disease: {\n          name: \"cancer\"\n      }\n    };\n  @example: flattenObj(ob)\n  @return: { 'disease.name': 'cancer' }\n *****************************************************/\nexport function flattenObj(ob: Record<string, unknown>): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n\n  for (const i in ob) {\n    if (typeof ob[i] === \"object\") {\n      const temp = flattenObj(ob[i]);\n      for (const j in temp) result[`${i}.${j}`] = temp[j];\n    } else result[i] = ob[i];\n  }\n  return result;\n}\n\n/**********************************************************************\n * CALCULATE POSITION OF CURRENT PAGE AS PER PAGE SIZE AND TOTAL ROWS *\n * @param:\n *  pageIndex : number\n *  pageSize : number\n *  totalRows : number\n * @return: string\n *  EXAMPLE 1: 31-40 OF 45\n *  EXAMPLE 2: 41-45 OF 45\n **********************************************************************/\n\nexport function getCurrentPagePosition(\n  pageIndex: number,\n  pageSize: number,\n  totalRows: number\n): string {\n  const currentPageStartRange = pageIndex * pageSize + 1;\n  const currentPageEndRange = pageIndex * pageSize + pageSize;\n  const pageEndResultSize = Math.min(currentPageEndRange, totalRows);\n\n  return `${currentPageStartRange} - ${pageEndResultSize} of ${totalRows}`;\n}\n\n/*****************************************************************\n * CREATES EMPTY ROWS WITH COLUMN OBJECT TO IMITATE LOADING ROWS *\n *****************************************************************/\nexport function getLoadingRows(size = 10): loadingTableRows[] {\n  const rows = new Array(size).fill({});\n  return rows;\n}\n\n/***********************************\n * CHECK IF THE COLUMNS ARE NESTED *\n * @param:\n * column: object\n * @return: boolean\n ***********************************/\nexport function isNestedColumns(column: Record<string, unknown>): boolean {\n  return Object.hasOwn(column, \"columns\");\n}\n\n/****************************************************************************\n * FN TO MAP EACH KEY FROM CLASSIC MUI COLUMN OBJECT TO NEW TANSTACK COLUMN *\n ****************************************************************************/\nfunction mapToTanstackColumnObject(\n  originalTableObject: Record<string, unknown>\n): Record<string, unknown> {\n  const newTanstackObject: Record<string, unknown> = {\n    id: originalTableObject.id,\n    header: originalTableObject.label,\n    enableSorting: originalTableObject.sortable || false,\n    enableColumnFilter: originalTableObject.enableColumnFilter || false,\n    filterFn: \"equalsString\",\n    ...(originalTableObject.comparator && {\n      sortingFn: (rowA, rowB, _column) =>\n        originalTableObject.comparator(rowA.original, rowB.original),\n    }),\n    accessorFn: (row: Record<string, unknown>) => {\n      // ASSIGN EITHER CUSTOM FILTERVALUE OR ID\n      if (originalTableObject.filterValue) return originalTableObject.filterValue(row);\n      return getValueFromChainedId(originalTableObject.id, row);\n    },\n    cell: ({ row }: { row: Record<string, unknown> }) => {\n      // ASSIGN CELL EITHER CUSTOM RENDER CELL OR ID\n      if (originalTableObject.renderCell) return originalTableObject.renderCell(row.original);\n      return getValueFromChainedId(originalTableObject.id, row.original);\n    },\n    ...originalTableObject,\n  };\n  return { ...newTanstackObject };\n}\n\n/***********************************************\n * EXTRACT OBJECT VALUE FROM STRING IDENTIFIER *\n * @params :\n *  id: type string\n *  obj: type object\n * @example : getValueFromChainedId(\"disease.name\", {disease: { \"name\": \"cancer\"}})*\n * @return: cancer\n ***********************************************/\nfunction getValueFromChainedId(id: string, obj: Record<string, unknown>) {\n  const accessorKeys = id.split(\".\");\n  const filterValue = accessorKeys.reduce(\n    (accumulator, currentValue) => accumulator[currentValue],\n    obj\n  );\n  return filterValue;\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/DataDownloader.jsx" },
        "span": [830, 844],
        "sourceCode": "import { faCode, faFileArrowDown, faTable } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  ListItemIcon,\n  ListItemText,\n  Menu,\n  MenuItem,\n  Slide,\n  Snackbar,\n  Typography,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport FileSaver from \"file-saver\";\nimport _ from \"lodash\";\nimport { useState } from \"react\";\nimport \"graphiql/graphiql.min.css\";\nimport ApiPlaygroundDrawer from \"./ApiPlaygroundDrawer\";\n\nconst asJSON = (columns, rows) => {\n  const rowStrings = rows.map((row) =>\n    columns.reduce((accumulator, newKey) => {\n      if (newKey.exportValue === false) return accumulator;\n\n      const newLabel = _.camelCase(newKey.exportLabel || newKey.label || newKey.id);\n\n      return {\n        ...accumulator,\n        [newLabel]: newKey.exportValue\n          ? newKey.exportValue(row)\n          : _.get(row, newKey.propertyPath || newKey.id, \"\"),\n      };\n    }, {})\n  );\n\n  return JSON.stringify(rowStrings);\n};\n\nconst asDSV = (columns, rows, separator = \",\", quoteStrings = true) => {\n  const quoteString = (d) => {\n    let result = d;\n    // converts arrays to strings\n    if (Array.isArray(d)) {\n      result = d.join(\",\");\n    }\n    return quoteStrings && typeof result === \"string\" ? `\"${result}\"` : result;\n  };\n\n  const lineSeparator = \"\\n\";\n\n  const headerString = columns\n    .reduce((accHeaderString, column) => {\n      if (column.exportValue === false) return accHeaderString;\n\n      const newLabel = quoteString(_.camelCase(column.exportLabel || column.label || column.id));\n\n      return [...accHeaderString, newLabel];\n    }, [])\n    .join(separator);\n\n  const rowStrings = rows\n    .map((row) =>\n      columns\n        .reduce((rowString, column) => {\n          if (column.exportValue === false) return rowString;\n\n          const newValue = quoteString(\n            column.exportValue\n              ? column.exportValue(row)\n              : _.get(row, column.propertyPath || column.id, \"\")\n          );\n\n          return [...rowString, newValue];\n        }, [])\n        .join(separator)\n    )\n    .join(lineSeparator);\n\n  return [headerString, rowStrings].join(lineSeparator);\n};\n\nconst createBlob = (format) =>\n  ({\n    json: (columns, rows) =>\n      new Blob([asJSON(columns, rows)], {\n        type: \"application/json;charset=utf-8\",\n      }),\n    csv: (columns, rows) =>\n      new Blob([asDSV(columns, rows)], {\n        type: \"text/csv;charset=utf-8\",\n      }),\n    tsv: (columns, rows) =>\n      new Blob([asDSV(columns, rows, \"\\t\", false)], {\n        type: \"text/tab-separated-values;charset=utf-8\",\n      }),\n  })[format];\n\nconst styles = makeStyles((_theme) => ({\n  messageProgress: {\n    marginRight: \"1rem\",\n    color: \"white !important\",\n  },\n  snackbarContentMessage: {\n    display: \"flex\",\n    justifyContent: \"flex-start\",\n    alignItems: \"center\",\n    padding: \".75rem 1rem\",\n    width: \"100%\",\n  },\n  snackbarContentRoot: {\n    padding: 0,\n  },\n}));\n\nfunction DataDownloader({ columns, rows, fileStem, query, variables, btnLabel = \"Export\" }) {\n  const [downloading, setDownloading] = useState(false);\n  const [anchorEl, setAnchorEl] = useState(null);\n\n  const classes = styles();\n  const open = Boolean(anchorEl);\n\n  const handleClickExportButton = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const downloadData = async (format, dataColumns, dataRows, dataFileStem) => {\n    let allRows = dataRows;\n\n    if (typeof dataRows === \"function\") {\n      setDownloading(true);\n      allRows = await dataRows();\n      setDownloading(false);\n    }\n\n    if (!allRows || allRows.length === 0) {\n      return;\n    }\n\n    const blob = createBlob(format)(dataColumns, allRows);\n\n    FileSaver.saveAs(blob, `${dataFileStem}.${format}`, { autoBOM: false });\n  };\n\n  const handleClickDownloadJSON = async () => {\n    downloadData(\"json\", columns, rows, fileStem);\n    handleClose();\n  };\n\n  const handleClickDownloadTSV = async () => {\n    downloadData(\"tsv\", columns, rows, fileStem);\n    handleClose();\n  };\n\n  return (\n    <>\n      <Box>\n        <Button\n          aria-controls={open ? \"basic-menu\" : undefined}\n          aria-haspopup=\"true\"\n          aria-expanded={open ? \"true\" : undefined}\n          onClick={handleClickExportButton}\n          sx={{ display: \"flex\", gap: 1 }}\n          variant=\"outlined\"\n        >\n          <FontAwesomeIcon icon={faFileArrowDown} /> {btnLabel}\n        </Button>\n      </Box>\n      {query ? <ApiPlaygroundDrawer query={query} variables={variables} /> : null}\n\n      <Menu id=\"export-data-menu\" anchorEl={anchorEl} open={open} onClose={handleClose}>\n        <MenuItem onClick={handleClickDownloadJSON}>\n          <ListItemIcon>\n            <FontAwesomeIcon icon={faCode} size=\"sm\" />\n          </ListItemIcon>\n          <ListItemText>\n            <Typography noWrap variant=\"body2\">\n              Json\n            </Typography>\n          </ListItemText>\n        </MenuItem>\n        <MenuItem onClick={handleClickDownloadTSV}>\n          <ListItemIcon>\n            <FontAwesomeIcon icon={faTable} size=\"sm\" />\n          </ListItemIcon>\n          <ListItemText>\n            <Typography noWrap variant=\"body2\">\n              TSV\n            </Typography>\n          </ListItemText>\n        </MenuItem>\n        <Box sx={{ typography: \"caption\", px: 2 }}>\n          * Column settings and filters will not affect export\n        </Box>\n      </Menu>\n\n      <Snackbar\n        anchorOrigin={{ vertical: \"bottom\", horizontal: \"left\" }}\n        open={downloading}\n        TransitionComponent={Slide}\n        ContentProps={{\n          classes: {\n            root: classes.snackbarContentRoot,\n            message: classes.snackbarContentMessage,\n          },\n        }}\n        message={\n          <>\n            <CircularProgress className={classes.messageProgress} />\n            Preparing data...\n          </>\n        }\n      />\n    </>\n  );\n}\n\nexport default DataDownloader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/DataDownloader.jsx" },
        "span": [1639, 1657],
        "sourceCode": "import { faCode, faFileArrowDown, faTable } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  ListItemIcon,\n  ListItemText,\n  Menu,\n  MenuItem,\n  Slide,\n  Snackbar,\n  Typography,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport FileSaver from \"file-saver\";\nimport _ from \"lodash\";\nimport { useState } from \"react\";\nimport \"graphiql/graphiql.min.css\";\nimport ApiPlaygroundDrawer from \"./ApiPlaygroundDrawer\";\n\nconst asJSON = (columns, rows) => {\n  const rowStrings = rows.map((row) =>\n    columns.reduce((accumulator, newKey) => {\n      if (newKey.exportValue === false) return accumulator;\n\n      const newLabel = _.camelCase(newKey.exportLabel || newKey.label || newKey.id);\n\n      return {\n        ...accumulator,\n        [newLabel]: newKey.exportValue\n          ? newKey.exportValue(row)\n          : _.get(row, newKey.propertyPath || newKey.id, \"\"),\n      };\n    }, {})\n  );\n\n  return JSON.stringify(rowStrings);\n};\n\nconst asDSV = (columns, rows, separator = \",\", quoteStrings = true) => {\n  const quoteString = (d) => {\n    let result = d;\n    // converts arrays to strings\n    if (Array.isArray(d)) {\n      result = d.join(\",\");\n    }\n    return quoteStrings && typeof result === \"string\" ? `\"${result}\"` : result;\n  };\n\n  const lineSeparator = \"\\n\";\n\n  const headerString = columns\n    .reduce((accHeaderString, column) => {\n      if (column.exportValue === false) return accHeaderString;\n\n      const newLabel = quoteString(_.camelCase(column.exportLabel || column.label || column.id));\n\n      return [...accHeaderString, newLabel];\n    }, [])\n    .join(separator);\n\n  const rowStrings = rows\n    .map((row) =>\n      columns\n        .reduce((rowString, column) => {\n          if (column.exportValue === false) return rowString;\n\n          const newValue = quoteString(\n            column.exportValue\n              ? column.exportValue(row)\n              : _.get(row, column.propertyPath || column.id, \"\")\n          );\n\n          return [...rowString, newValue];\n        }, [])\n        .join(separator)\n    )\n    .join(lineSeparator);\n\n  return [headerString, rowStrings].join(lineSeparator);\n};\n\nconst createBlob = (format) =>\n  ({\n    json: (columns, rows) =>\n      new Blob([asJSON(columns, rows)], {\n        type: \"application/json;charset=utf-8\",\n      }),\n    csv: (columns, rows) =>\n      new Blob([asDSV(columns, rows)], {\n        type: \"text/csv;charset=utf-8\",\n      }),\n    tsv: (columns, rows) =>\n      new Blob([asDSV(columns, rows, \"\\t\", false)], {\n        type: \"text/tab-separated-values;charset=utf-8\",\n      }),\n  })[format];\n\nconst styles = makeStyles((_theme) => ({\n  messageProgress: {\n    marginRight: \"1rem\",\n    color: \"white !important\",\n  },\n  snackbarContentMessage: {\n    display: \"flex\",\n    justifyContent: \"flex-start\",\n    alignItems: \"center\",\n    padding: \".75rem 1rem\",\n    width: \"100%\",\n  },\n  snackbarContentRoot: {\n    padding: 0,\n  },\n}));\n\nfunction DataDownloader({ columns, rows, fileStem, query, variables, btnLabel = \"Export\" }) {\n  const [downloading, setDownloading] = useState(false);\n  const [anchorEl, setAnchorEl] = useState(null);\n\n  const classes = styles();\n  const open = Boolean(anchorEl);\n\n  const handleClickExportButton = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const downloadData = async (format, dataColumns, dataRows, dataFileStem) => {\n    let allRows = dataRows;\n\n    if (typeof dataRows === \"function\") {\n      setDownloading(true);\n      allRows = await dataRows();\n      setDownloading(false);\n    }\n\n    if (!allRows || allRows.length === 0) {\n      return;\n    }\n\n    const blob = createBlob(format)(dataColumns, allRows);\n\n    FileSaver.saveAs(blob, `${dataFileStem}.${format}`, { autoBOM: false });\n  };\n\n  const handleClickDownloadJSON = async () => {\n    downloadData(\"json\", columns, rows, fileStem);\n    handleClose();\n  };\n\n  const handleClickDownloadTSV = async () => {\n    downloadData(\"tsv\", columns, rows, fileStem);\n    handleClose();\n  };\n\n  return (\n    <>\n      <Box>\n        <Button\n          aria-controls={open ? \"basic-menu\" : undefined}\n          aria-haspopup=\"true\"\n          aria-expanded={open ? \"true\" : undefined}\n          onClick={handleClickExportButton}\n          sx={{ display: \"flex\", gap: 1 }}\n          variant=\"outlined\"\n        >\n          <FontAwesomeIcon icon={faFileArrowDown} /> {btnLabel}\n        </Button>\n      </Box>\n      {query ? <ApiPlaygroundDrawer query={query} variables={variables} /> : null}\n\n      <Menu id=\"export-data-menu\" anchorEl={anchorEl} open={open} onClose={handleClose}>\n        <MenuItem onClick={handleClickDownloadJSON}>\n          <ListItemIcon>\n            <FontAwesomeIcon icon={faCode} size=\"sm\" />\n          </ListItemIcon>\n          <ListItemText>\n            <Typography noWrap variant=\"body2\">\n              Json\n            </Typography>\n          </ListItemText>\n        </MenuItem>\n        <MenuItem onClick={handleClickDownloadTSV}>\n          <ListItemIcon>\n            <FontAwesomeIcon icon={faTable} size=\"sm\" />\n          </ListItemIcon>\n          <ListItemText>\n            <Typography noWrap variant=\"body2\">\n              TSV\n            </Typography>\n          </ListItemText>\n        </MenuItem>\n        <Box sx={{ typography: \"caption\", px: 2 }}>\n          * Column settings and filters will not affect export\n        </Box>\n      </Menu>\n\n      <Snackbar\n        anchorOrigin={{ vertical: \"bottom\", horizontal: \"left\" }}\n        open={downloading}\n        TransitionComponent={Slide}\n        ContentProps={{\n          classes: {\n            root: classes.snackbarContentRoot,\n            message: classes.snackbarContentMessage,\n          },\n        }}\n        message={\n          <>\n            <CircularProgress className={classes.messageProgress} />\n            Preparing data...\n          </>\n        }\n      />\n    </>\n  );\n}\n\nexport default DataDownloader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/performance/noAccumulatingSpread",
      "severity": "error",
      "description": "Avoid the use of spread (`...`) syntax on accumulators.",
      "message": [
        { "elements": [], "content": "Avoid the use of spread (`...`) syntax on accumulators." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Spread syntax should be avoided on accumulators (like those in `.reduce`) because it causes a time complexity of `O(n^2)`."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Consider methods such as .splice or .push instead." }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/DataDownloader.jsx" },
        "span": [2074, 2086],
        "sourceCode": "import { faCode, faFileArrowDown, faTable } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Button,\n  CircularProgress,\n  ListItemIcon,\n  ListItemText,\n  Menu,\n  MenuItem,\n  Slide,\n  Snackbar,\n  Typography,\n} from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport FileSaver from \"file-saver\";\nimport _ from \"lodash\";\nimport { useState } from \"react\";\nimport \"graphiql/graphiql.min.css\";\nimport ApiPlaygroundDrawer from \"./ApiPlaygroundDrawer\";\n\nconst asJSON = (columns, rows) => {\n  const rowStrings = rows.map((row) =>\n    columns.reduce((accumulator, newKey) => {\n      if (newKey.exportValue === false) return accumulator;\n\n      const newLabel = _.camelCase(newKey.exportLabel || newKey.label || newKey.id);\n\n      return {\n        ...accumulator,\n        [newLabel]: newKey.exportValue\n          ? newKey.exportValue(row)\n          : _.get(row, newKey.propertyPath || newKey.id, \"\"),\n      };\n    }, {})\n  );\n\n  return JSON.stringify(rowStrings);\n};\n\nconst asDSV = (columns, rows, separator = \",\", quoteStrings = true) => {\n  const quoteString = (d) => {\n    let result = d;\n    // converts arrays to strings\n    if (Array.isArray(d)) {\n      result = d.join(\",\");\n    }\n    return quoteStrings && typeof result === \"string\" ? `\"${result}\"` : result;\n  };\n\n  const lineSeparator = \"\\n\";\n\n  const headerString = columns\n    .reduce((accHeaderString, column) => {\n      if (column.exportValue === false) return accHeaderString;\n\n      const newLabel = quoteString(_.camelCase(column.exportLabel || column.label || column.id));\n\n      return [...accHeaderString, newLabel];\n    }, [])\n    .join(separator);\n\n  const rowStrings = rows\n    .map((row) =>\n      columns\n        .reduce((rowString, column) => {\n          if (column.exportValue === false) return rowString;\n\n          const newValue = quoteString(\n            column.exportValue\n              ? column.exportValue(row)\n              : _.get(row, column.propertyPath || column.id, \"\")\n          );\n\n          return [...rowString, newValue];\n        }, [])\n        .join(separator)\n    )\n    .join(lineSeparator);\n\n  return [headerString, rowStrings].join(lineSeparator);\n};\n\nconst createBlob = (format) =>\n  ({\n    json: (columns, rows) =>\n      new Blob([asJSON(columns, rows)], {\n        type: \"application/json;charset=utf-8\",\n      }),\n    csv: (columns, rows) =>\n      new Blob([asDSV(columns, rows)], {\n        type: \"text/csv;charset=utf-8\",\n      }),\n    tsv: (columns, rows) =>\n      new Blob([asDSV(columns, rows, \"\\t\", false)], {\n        type: \"text/tab-separated-values;charset=utf-8\",\n      }),\n  })[format];\n\nconst styles = makeStyles((_theme) => ({\n  messageProgress: {\n    marginRight: \"1rem\",\n    color: \"white !important\",\n  },\n  snackbarContentMessage: {\n    display: \"flex\",\n    justifyContent: \"flex-start\",\n    alignItems: \"center\",\n    padding: \".75rem 1rem\",\n    width: \"100%\",\n  },\n  snackbarContentRoot: {\n    padding: 0,\n  },\n}));\n\nfunction DataDownloader({ columns, rows, fileStem, query, variables, btnLabel = \"Export\" }) {\n  const [downloading, setDownloading] = useState(false);\n  const [anchorEl, setAnchorEl] = useState(null);\n\n  const classes = styles();\n  const open = Boolean(anchorEl);\n\n  const handleClickExportButton = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const downloadData = async (format, dataColumns, dataRows, dataFileStem) => {\n    let allRows = dataRows;\n\n    if (typeof dataRows === \"function\") {\n      setDownloading(true);\n      allRows = await dataRows();\n      setDownloading(false);\n    }\n\n    if (!allRows || allRows.length === 0) {\n      return;\n    }\n\n    const blob = createBlob(format)(dataColumns, allRows);\n\n    FileSaver.saveAs(blob, `${dataFileStem}.${format}`, { autoBOM: false });\n  };\n\n  const handleClickDownloadJSON = async () => {\n    downloadData(\"json\", columns, rows, fileStem);\n    handleClose();\n  };\n\n  const handleClickDownloadTSV = async () => {\n    downloadData(\"tsv\", columns, rows, fileStem);\n    handleClose();\n  };\n\n  return (\n    <>\n      <Box>\n        <Button\n          aria-controls={open ? \"basic-menu\" : undefined}\n          aria-haspopup=\"true\"\n          aria-expanded={open ? \"true\" : undefined}\n          onClick={handleClickExportButton}\n          sx={{ display: \"flex\", gap: 1 }}\n          variant=\"outlined\"\n        >\n          <FontAwesomeIcon icon={faFileArrowDown} /> {btnLabel}\n        </Button>\n      </Box>\n      {query ? <ApiPlaygroundDrawer query={query} variables={variables} /> : null}\n\n      <Menu id=\"export-data-menu\" anchorEl={anchorEl} open={open} onClose={handleClose}>\n        <MenuItem onClick={handleClickDownloadJSON}>\n          <ListItemIcon>\n            <FontAwesomeIcon icon={faCode} size=\"sm\" />\n          </ListItemIcon>\n          <ListItemText>\n            <Typography noWrap variant=\"body2\">\n              Json\n            </Typography>\n          </ListItemText>\n        </MenuItem>\n        <MenuItem onClick={handleClickDownloadTSV}>\n          <ListItemIcon>\n            <FontAwesomeIcon icon={faTable} size=\"sm\" />\n          </ListItemIcon>\n          <ListItemText>\n            <Typography noWrap variant=\"body2\">\n              TSV\n            </Typography>\n          </ListItemText>\n        </MenuItem>\n        <Box sx={{ typography: \"caption\", px: 2 }}>\n          * Column settings and filters will not affect export\n        </Box>\n      </Menu>\n\n      <Snackbar\n        anchorOrigin={{ vertical: \"bottom\", horizontal: \"left\" }}\n        open={downloading}\n        TransitionComponent={Slide}\n        ContentProps={{\n          classes: {\n            root: classes.snackbarContentRoot,\n            message: classes.snackbarContentMessage,\n          },\n        }}\n        message={\n          <>\n            <CircularProgress className={classes.messageProgress} />\n            Preparing data...\n          </>\n        }\n      />\n    </>\n  );\n}\n\nexport default DataDownloader;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/DisplayVariantId.tsx" },
        "span": [1399, 1407],
        "sourceCode": "import { faClipboard } from \"@fortawesome/free-regular-svg-icons\";\nimport { faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Dialog,\n  DialogContent,\n  DialogTitle,\n  IconButton,\n  Snackbar,\n  Typography,\n} from \"@mui/material\";\nimport { lighten } from \"polished\";\nimport { type ReactNode, useState } from \"react\";\nimport { Tooltip } from \"ui\";\n\nconst highlightBackground = (theme) => lighten(0.4, theme.palette.primary.main);\n\ntype DisplayVariantIdProps = {\n  variantId: string;\n  referenceAllele: string;\n  alternateAllele: string;\n  maxChars?: number;\n  expand?: boolean;\n};\n\nfunction DisplayVariantId({\n  variantId: otVariantId,\n  referenceAllele,\n  alternateAllele,\n  maxChars = 6,\n  expand = true,\n}: DisplayVariantIdProps): ReactNode {\n  const [open, setOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n\n  if (!otVariantId || !referenceAllele || !alternateAllele) return null;\n\n  function handleClick() {\n    setOpen(true);\n  }\n\n  function handleClose() {\n    setOpen(false);\n  }\n\n  function handleCloseSnackbar() {\n    setSnackbarOpen(false);\n  }\n\n  function copyToClipboard(text: string) {\n    setSnackbarOpen(true);\n    navigator.clipboard.writeText(text);\n  }\n\n  const idParts = otVariantId.split(\"_\");\n  if (idParts[0] === \"OTVAR\") {\n    idParts.shift();\n  }\n  let isHashed;\n  let stem;\n  if (idParts.at(-2) === referenceAllele && idParts.at(-1) === alternateAllele) {\n    isHashed = false;\n    stem = idParts.slice(0, -2).join(\"_\");\n  } else {\n    isHashed = true;\n    stem = idParts.slice(0, -1).join(\"_\");\n  }\n\n  const longReferenceAllele = referenceAllele.length > maxChars;\n  const longAlternateAllele = alternateAllele.length > maxChars;\n\n  if (isHashed || longReferenceAllele || longAlternateAllele) {\n    return (\n      <>\n        <Box\n          component=\"span\"\n          onClick={expand ? handleClick : null}\n          title=\"Show variant ID\"\n          sx={{\n            cursor: expand ? \"pointer\" : \"inherit\",\n            padding: \"0 0.06em\",\n            borderRadius: \"0.3em\",\n            \"&:hover\": {\n              background: expand ? highlightBackground : \"transparent\",\n            },\n          }}\n        >\n          {stem}_\n          {longReferenceAllele ? (\n            <HighlightBox hlight={expand}>\n              <span style={{ fontSize: \"0.94em\", fontStyle: \"italic\" }}>DEL</span>\n            </HighlightBox>\n          ) : (\n            referenceAllele\n          )}\n          _\n          {longAlternateAllele ? (\n            <HighlightBox hlight={expand}>\n              <span style={{ fontSize: \"0.94em\", fontStyle: \"italic\" }}>INS</span>\n            </HighlightBox>\n          ) : (\n            alternateAllele\n          )}\n        </Box>\n        {expand && (\n          <>\n            <Dialog\n              open={open}\n              onClose={handleClose}\n              scroll=\"paper\"\n              aria-labelledby=\"dialog-title\"\n              aria-describedby=\"dialog-description\"\n              maxWidth=\"md\"\n            >\n              <DialogTitle id=\"dialog-title\">\n                <Typography variant=\"h6\" component=\"span\">\n                  Variant ID\n                </Typography>\n                <IconButton\n                  onClick={handleClose}\n                  sx={{\n                    zIndex: \"2\",\n                    position: \"absolute\",\n                    top: \"0\",\n                    right: \"0\",\n                    padding: \"0.7em\",\n                  }}\n                >\n                  <FontAwesomeIcon icon={faXmark} />\n                </IconButton>\n              </DialogTitle>\n              <DialogContent dividers={true} sx={{ padding: \"0 1.5em 3em\" }}>\n                {isHashed && (\n                  <CopyPanel\n                    label=\"Hashed Variant ID\"\n                    tooltipText=\"Variant ID used in Open Targets data.\"\n                    text={otVariantId}\n                    copyToClipboard={copyToClipboard}\n                  />\n                )}\n                <CopyPanel\n                  label=\"Full Variant ID\"\n                  text={`${stem}_${referenceAllele}_${alternateAllele}`}\n                  copyToClipboard={copyToClipboard}\n                />\n              </DialogContent>\n            </Dialog>\n            <Snackbar\n              open={snackbarOpen}\n              onClose={handleCloseSnackbar}\n              message=\"Copied to clipboard\"\n              autoHideDuration={3000}\n            />\n          </>\n        )}\n      </>\n    );\n  }\n\n  return `${stem}_${referenceAllele}_${alternateAllele}`;\n}\n\nfunction HighlightBox({ children, hlight = true }) {\n  return (\n    <Box\n      component=\"span\"\n      borderRadius=\"0.3em\"\n      mx={hlight ? \"0.1em\" : 0}\n      px=\"0.15em\"\n      bgcolor={hlight ? highlightBackground : \"transparent\"}\n    >\n      {children}\n    </Box>\n  );\n}\n\ntype CopyPanelProps = {\n  label: string;\n  text: string;\n  tooltipText?: string;\n  copyToClipboard: (text: string) => void;\n};\n\nfunction CopyPanel({ label, text, tooltipText, copyToClipboard }: CopyPanelProps) {\n  return (\n    <Box mt={2}>\n      {tooltipText ? (\n        <Tooltip title={tooltipText} showHelpIcon>\n          <Typography variant=\"subtitle1\" component=\"span\">\n            {label}\n          </Typography>\n        </Tooltip>\n      ) : (\n        <Typography variant=\"subtitle1\">{label}</Typography>\n      )}\n      <Box\n        sx={{\n          marginTop: \"0.1em\",\n          backgroundColor: (theme) => theme.palette.grey[300],\n          position: \"relative\",\n        }}\n      >\n        <Box position=\"absolute\" top={0} right={0}>\n          <Tooltip title=\"Copy to clipboard\">\n            <IconButton\n              onClick={() => copyToClipboard(text)}\n              sx={{ padding: \"0.4em 0.5em !important\" }}\n            >\n              <FontAwesomeIcon icon={faClipboard} />\n            </IconButton>\n          </Tooltip>\n        </Box>\n        <Typography\n          variant=\"body2\"\n          sx={{\n            padding: \"1em 3.2em 1em 1em\",\n            textWrap: \"wrap\",\n            wordWrap: \"break-word\",\n          }}\n        >\n          {text}\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\nexport default DisplayVariantId;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/DisplayVariantId.tsx" },
        "span": [1415, 1419],
        "sourceCode": "import { faClipboard } from \"@fortawesome/free-regular-svg-icons\";\nimport { faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Dialog,\n  DialogContent,\n  DialogTitle,\n  IconButton,\n  Snackbar,\n  Typography,\n} from \"@mui/material\";\nimport { lighten } from \"polished\";\nimport { type ReactNode, useState } from \"react\";\nimport { Tooltip } from \"ui\";\n\nconst highlightBackground = (theme) => lighten(0.4, theme.palette.primary.main);\n\ntype DisplayVariantIdProps = {\n  variantId: string;\n  referenceAllele: string;\n  alternateAllele: string;\n  maxChars?: number;\n  expand?: boolean;\n};\n\nfunction DisplayVariantId({\n  variantId: otVariantId,\n  referenceAllele,\n  alternateAllele,\n  maxChars = 6,\n  expand = true,\n}: DisplayVariantIdProps): ReactNode {\n  const [open, setOpen] = useState(false);\n  const [snackbarOpen, setSnackbarOpen] = useState(false);\n\n  if (!otVariantId || !referenceAllele || !alternateAllele) return null;\n\n  function handleClick() {\n    setOpen(true);\n  }\n\n  function handleClose() {\n    setOpen(false);\n  }\n\n  function handleCloseSnackbar() {\n    setSnackbarOpen(false);\n  }\n\n  function copyToClipboard(text: string) {\n    setSnackbarOpen(true);\n    navigator.clipboard.writeText(text);\n  }\n\n  const idParts = otVariantId.split(\"_\");\n  if (idParts[0] === \"OTVAR\") {\n    idParts.shift();\n  }\n  let isHashed;\n  let stem;\n  if (idParts.at(-2) === referenceAllele && idParts.at(-1) === alternateAllele) {\n    isHashed = false;\n    stem = idParts.slice(0, -2).join(\"_\");\n  } else {\n    isHashed = true;\n    stem = idParts.slice(0, -1).join(\"_\");\n  }\n\n  const longReferenceAllele = referenceAllele.length > maxChars;\n  const longAlternateAllele = alternateAllele.length > maxChars;\n\n  if (isHashed || longReferenceAllele || longAlternateAllele) {\n    return (\n      <>\n        <Box\n          component=\"span\"\n          onClick={expand ? handleClick : null}\n          title=\"Show variant ID\"\n          sx={{\n            cursor: expand ? \"pointer\" : \"inherit\",\n            padding: \"0 0.06em\",\n            borderRadius: \"0.3em\",\n            \"&:hover\": {\n              background: expand ? highlightBackground : \"transparent\",\n            },\n          }}\n        >\n          {stem}_\n          {longReferenceAllele ? (\n            <HighlightBox hlight={expand}>\n              <span style={{ fontSize: \"0.94em\", fontStyle: \"italic\" }}>DEL</span>\n            </HighlightBox>\n          ) : (\n            referenceAllele\n          )}\n          _\n          {longAlternateAllele ? (\n            <HighlightBox hlight={expand}>\n              <span style={{ fontSize: \"0.94em\", fontStyle: \"italic\" }}>INS</span>\n            </HighlightBox>\n          ) : (\n            alternateAllele\n          )}\n        </Box>\n        {expand && (\n          <>\n            <Dialog\n              open={open}\n              onClose={handleClose}\n              scroll=\"paper\"\n              aria-labelledby=\"dialog-title\"\n              aria-describedby=\"dialog-description\"\n              maxWidth=\"md\"\n            >\n              <DialogTitle id=\"dialog-title\">\n                <Typography variant=\"h6\" component=\"span\">\n                  Variant ID\n                </Typography>\n                <IconButton\n                  onClick={handleClose}\n                  sx={{\n                    zIndex: \"2\",\n                    position: \"absolute\",\n                    top: \"0\",\n                    right: \"0\",\n                    padding: \"0.7em\",\n                  }}\n                >\n                  <FontAwesomeIcon icon={faXmark} />\n                </IconButton>\n              </DialogTitle>\n              <DialogContent dividers={true} sx={{ padding: \"0 1.5em 3em\" }}>\n                {isHashed && (\n                  <CopyPanel\n                    label=\"Hashed Variant ID\"\n                    tooltipText=\"Variant ID used in Open Targets data.\"\n                    text={otVariantId}\n                    copyToClipboard={copyToClipboard}\n                  />\n                )}\n                <CopyPanel\n                  label=\"Full Variant ID\"\n                  text={`${stem}_${referenceAllele}_${alternateAllele}`}\n                  copyToClipboard={copyToClipboard}\n                />\n              </DialogContent>\n            </Dialog>\n            <Snackbar\n              open={snackbarOpen}\n              onClose={handleCloseSnackbar}\n              message=\"Copied to clipboard\"\n              autoHideDuration={3000}\n            />\n          </>\n        )}\n      </>\n    );\n  }\n\n  return `${stem}_${referenceAllele}_${alternateAllele}`;\n}\n\nfunction HighlightBox({ children, hlight = true }) {\n  return (\n    <Box\n      component=\"span\"\n      borderRadius=\"0.3em\"\n      mx={hlight ? \"0.1em\" : 0}\n      px=\"0.15em\"\n      bgcolor={hlight ? highlightBackground : \"transparent\"}\n    >\n      {children}\n    </Box>\n  );\n}\n\ntype CopyPanelProps = {\n  label: string;\n  text: string;\n  tooltipText?: string;\n  copyToClipboard: (text: string) => void;\n};\n\nfunction CopyPanel({ label, text, tooltipText, copyToClipboard }: CopyPanelProps) {\n  return (\n    <Box mt={2}>\n      {tooltipText ? (\n        <Tooltip title={tooltipText} showHelpIcon>\n          <Typography variant=\"subtitle1\" component=\"span\">\n            {label}\n          </Typography>\n        </Tooltip>\n      ) : (\n        <Typography variant=\"subtitle1\">{label}</Typography>\n      )}\n      <Box\n        sx={{\n          marginTop: \"0.1em\",\n          backgroundColor: (theme) => theme.palette.grey[300],\n          position: \"relative\",\n        }}\n      >\n        <Box position=\"absolute\" top={0} right={0}>\n          <Tooltip title=\"Copy to clipboard\">\n            <IconButton\n              onClick={() => copyToClipboard(text)}\n              sx={{ padding: \"0.4em 0.5em !important\" }}\n            >\n              <FontAwesomeIcon icon={faClipboard} />\n            </IconButton>\n          </Tooltip>\n        </Box>\n        <Typography\n          variant=\"body2\"\n          sx={{\n            padding: \"1em 3.2em 1em 1em\",\n            textWrap: \"wrap\",\n            wordWrap: \"break-word\",\n          }}\n        >\n          {text}\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n\nexport default DisplayVariantId;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/useKeyWithClickEvents",
      "severity": "error",
      "description": "Enforce to have the onClick mouse event with the onKeyUp, the onKeyDown, or the onKeyPress keyboard event.",
      "message": [
        { "elements": [], "content": "Enforce to have the " },
        { "elements": ["Emphasis"], "content": "onClick" },
        { "elements": [], "content": " mouse event with the " },
        { "elements": ["Emphasis"], "content": "onKeyUp" },
        { "elements": [], "content": ", the " },
        { "elements": ["Emphasis"], "content": "onKeyDown" },
        { "elements": [], "content": ", or the " },
        { "elements": ["Emphasis"], "content": "onKeyPress" },
        { "elements": [], "content": " keyboard event." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ExternalLink/XRefLinks.tsx" },
        "span": [1045, 1119],
        "sourceCode": "import { makeStyles } from \"@mui/styles\";\nimport { useState } from \"react\";\n\nimport Link from \"../Link\";\n\nconst useStyles = makeStyles((theme) => ({\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n}));\n\ntype XRefLinksProps = {\n  label: string;\n  urlBuilder?: (id: string) => string;\n  urlStem: string;\n  ids: string[];\n  names?: string[];\n  limit: number;\n};\n\nfunction XRefLinks({ label, urlBuilder, urlStem, ids, names, limit }: XRefLinksProps) {\n  const [showMore, setShowMore] = useState(false);\n  const classes = useStyles();\n  const displayNone = {\n    display: \"none\",\n  };\n\n  return (\n    <span>\n      {label}:{\" \"}\n      {ids.map((id, i) => (\n        <span key={id} style={i > limit - 1 && !showMore ? displayNone : {}}>\n          <Link external to={urlBuilder?.(id) ?? `${urlStem}${id}`}>\n            {names?.[i] ?? id}\n          </Link>\n          {i < ids.length - 1 ? \", \" : \"\"}\n        </span>\n      ))}\n      {ids.length > limit ? (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      ) : null}\n    </span>\n  );\n}\n\nexport default XRefLinks;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: openListItem",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: openListItem"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1329, 1341],
              "sourceCode": "import { Box, Typography, styled } from \"@mui/material\";\nimport { useCallback, useContext } from \"react\";\n\nimport useListOption from \"../../hooks/useListOption\";\nimport ArrowTurnDownLeft from \"../icons/ArrowTurnDownLeft\";\nimport { SearchContext, SearchInputContext } from \"./SearchContext\";\n\nconst FreeSearchListItem = styled(\"li\")(({ theme }) => ({\n  cursor: \"pointer\",\n  width: \"100%\",\n  listStyle: \"none\",\n  padding: `${theme.spacing(1.5)}`,\n  borderRadius: theme.spacing(0.5),\n  color: theme.palette.grey[\"900\"],\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n  wordBreak: \"break-word\",\n  \"&:hover\": {\n    background: theme.palette.grey[\"200\"],\n  },\n  \"&.search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"&.search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n    border: 1,\n  },\n}));\n\nconst SearchListItemText = styled(\"span\")({\n  maxWidth: \"90%\",\n});\n\nfunction GlobalSearchFreeListItem() {\n  const { inputValue } = useContext(SearchInputContext);\n\n  const { setOpen } = useContext(SearchContext);\n  const [openListItem] = useListOption();\n\n  const freeSearchTermObject = {\n    symbol: `Search for: ${inputValue}`,\n    name: inputValue,\n    entity: \"search\",\n    type: \"\",\n  };\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  if (!inputValue) return null;\n  return (\n    <FreeSearchListItem\n      className=\"search-list-item search-list-item-active\"\n      role=\"menuitem\"\n      tabIndex=\"0\"\n      data-item-details={JSON.stringify(freeSearchTermObject)}\n      onClick={() => handleItemClick(freeSearchTermObject)}\n    >\n      <SearchListItemText>\n        <Typography variant=\"subtitle1\">\n          <Box sx={{ fontStyle: \"oblique\" }}>{freeSearchTermObject.symbol}</Box>\n        </Typography>\n      </SearchListItemText>\n      <ArrowTurnDownLeft />\n    </FreeSearchListItem>\n  );\n}\nexport default GlobalSearchFreeListItem;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchFreeListItem.jsx"
        },
        "span": [1281, 1292],
        "sourceCode": "import { Box, Typography, styled } from \"@mui/material\";\nimport { useCallback, useContext } from \"react\";\n\nimport useListOption from \"../../hooks/useListOption\";\nimport ArrowTurnDownLeft from \"../icons/ArrowTurnDownLeft\";\nimport { SearchContext, SearchInputContext } from \"./SearchContext\";\n\nconst FreeSearchListItem = styled(\"li\")(({ theme }) => ({\n  cursor: \"pointer\",\n  width: \"100%\",\n  listStyle: \"none\",\n  padding: `${theme.spacing(1.5)}`,\n  borderRadius: theme.spacing(0.5),\n  color: theme.palette.grey[\"900\"],\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n  wordBreak: \"break-word\",\n  \"&:hover\": {\n    background: theme.palette.grey[\"200\"],\n  },\n  \"&.search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"&.search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n    border: 1,\n  },\n}));\n\nconst SearchListItemText = styled(\"span\")({\n  maxWidth: \"90%\",\n});\n\nfunction GlobalSearchFreeListItem() {\n  const { inputValue } = useContext(SearchInputContext);\n\n  const { setOpen } = useContext(SearchContext);\n  const [openListItem] = useListOption();\n\n  const freeSearchTermObject = {\n    symbol: `Search for: ${inputValue}`,\n    name: inputValue,\n    entity: \"search\",\n    type: \"\",\n  };\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  if (!inputValue) return null;\n  return (\n    <FreeSearchListItem\n      className=\"search-list-item search-list-item-active\"\n      role=\"menuitem\"\n      tabIndex=\"0\"\n      data-item-details={JSON.stringify(freeSearchTermObject)}\n      onClick={() => handleItemClick(freeSearchTermObject)}\n    >\n      <SearchListItemText>\n        <Typography variant=\"subtitle1\">\n          <Box sx={{ fontStyle: \"oblique\" }}>{freeSearchTermObject.symbol}</Box>\n        </Typography>\n      </SearchListItemText>\n      <ArrowTurnDownLeft />\n    </FreeSearchListItem>\n  );\n}\nexport default GlobalSearchFreeListItem;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: setOpen",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: setOpen" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1309, 1316],
              "sourceCode": "import { Box, Typography, styled } from \"@mui/material\";\nimport { useCallback, useContext } from \"react\";\n\nimport useListOption from \"../../hooks/useListOption\";\nimport ArrowTurnDownLeft from \"../icons/ArrowTurnDownLeft\";\nimport { SearchContext, SearchInputContext } from \"./SearchContext\";\n\nconst FreeSearchListItem = styled(\"li\")(({ theme }) => ({\n  cursor: \"pointer\",\n  width: \"100%\",\n  listStyle: \"none\",\n  padding: `${theme.spacing(1.5)}`,\n  borderRadius: theme.spacing(0.5),\n  color: theme.palette.grey[\"900\"],\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n  wordBreak: \"break-word\",\n  \"&:hover\": {\n    background: theme.palette.grey[\"200\"],\n  },\n  \"&.search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"&.search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n    border: 1,\n  },\n}));\n\nconst SearchListItemText = styled(\"span\")({\n  maxWidth: \"90%\",\n});\n\nfunction GlobalSearchFreeListItem() {\n  const { inputValue } = useContext(SearchInputContext);\n\n  const { setOpen } = useContext(SearchContext);\n  const [openListItem] = useListOption();\n\n  const freeSearchTermObject = {\n    symbol: `Search for: ${inputValue}`,\n    name: inputValue,\n    entity: \"search\",\n    type: \"\",\n  };\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  if (!inputValue) return null;\n  return (\n    <FreeSearchListItem\n      className=\"search-list-item search-list-item-active\"\n      role=\"menuitem\"\n      tabIndex=\"0\"\n      data-item-details={JSON.stringify(freeSearchTermObject)}\n      onClick={() => handleItemClick(freeSearchTermObject)}\n    >\n      <SearchListItemText>\n        <Typography variant=\"subtitle1\">\n          <Box sx={{ fontStyle: \"oblique\" }}>{freeSearchTermObject.symbol}</Box>\n        </Typography>\n      </SearchListItemText>\n      <ArrowTurnDownLeft />\n    </FreeSearchListItem>\n  );\n}\nexport default GlobalSearchFreeListItem;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchFreeListItem.jsx"
        },
        "span": [1281, 1292],
        "sourceCode": "import { Box, Typography, styled } from \"@mui/material\";\nimport { useCallback, useContext } from \"react\";\n\nimport useListOption from \"../../hooks/useListOption\";\nimport ArrowTurnDownLeft from \"../icons/ArrowTurnDownLeft\";\nimport { SearchContext, SearchInputContext } from \"./SearchContext\";\n\nconst FreeSearchListItem = styled(\"li\")(({ theme }) => ({\n  cursor: \"pointer\",\n  width: \"100%\",\n  listStyle: \"none\",\n  padding: `${theme.spacing(1.5)}`,\n  borderRadius: theme.spacing(0.5),\n  color: theme.palette.grey[\"900\"],\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"space-between\",\n  wordBreak: \"break-word\",\n  \"&:hover\": {\n    background: theme.palette.grey[\"200\"],\n  },\n  \"&.search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"&.search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n    border: 1,\n  },\n}));\n\nconst SearchListItemText = styled(\"span\")({\n  maxWidth: \"90%\",\n});\n\nfunction GlobalSearchFreeListItem() {\n  const { inputValue } = useContext(SearchInputContext);\n\n  const { setOpen } = useContext(SearchContext);\n  const [openListItem] = useListOption();\n\n  const freeSearchTermObject = {\n    symbol: `Search for: ${inputValue}`,\n    name: inputValue,\n    entity: \"search\",\n    type: \"\",\n  };\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  if (!inputValue) return null;\n  return (\n    <FreeSearchListItem\n      className=\"search-list-item search-list-item-active\"\n      role=\"menuitem\"\n      tabIndex=\"0\"\n      data-item-details={JSON.stringify(freeSearchTermObject)}\n      onClick={() => handleItemClick(freeSearchTermObject)}\n    >\n      <SearchListItemText>\n        <Typography variant=\"subtitle1\">\n          <Box sx={{ fontStyle: \"oblique\" }}>{freeSearchTermObject.symbol}</Box>\n        </Typography>\n      </SearchListItemText>\n      <ArrowTurnDownLeft />\n    </FreeSearchListItem>\n  );\n}\nexport default GlobalSearchFreeListItem;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: monitorCmdK",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: monitorCmdK"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1459, 1470],
              "sourceCode": "import { faMagnifyingGlass } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Typography, styled } from \"@mui/material\";\nimport { useContext, useEffect } from \"react\";\n\nimport GlobalSearchDialog from \"./GlobalSearchDialog\";\nimport { SearchContext } from \"./SearchContext\";\n\nconst SearchButton = styled(\"button\")(({ theme, isHomePage = false }) => ({\n  cursor: \"pointer\",\n  width: \"100%\",\n  maxWidth: isHomePage ? \"90%\" : \"400px\",\n  background: isHomePage ? \"#F0F0F0\" : theme.palette.secondary.main,\n  color: isHomePage ? \"inherit\" : \"white\",\n  borderRadius: theme.spacing(0.6),\n  border: isHomePage ? \"1px solid #F0F0F0\" : `1px solid ${theme.palette.secondary.main}`,\n  padding: isHomePage ? theme.spacing(1) : theme.spacing(0.3),\n}));\n\nfunction GlobalSearch({ isHomePage }) {\n  const { setOpen } = useContext(SearchContext);\n  const shortcutText = navigator?.platform.indexOf(\"Mac\") > -1 ? \"⌘ K\" : \"Ctrl+K\";\n  const searchButtonContainer = {\n    width: 1,\n    display: \"flex\",\n    justifyContent: \"center\",\n    ...(isHomePage && {\n      margin: (theme) => `${theme.spacing(5)} 0 ${theme.spacing(5)}`,\n    }),\n  };\n\n  function monitorCmdK(event) {\n    // open on cmd + k\n    if (event.metaKey === true && event.code === \"KeyK\") {\n      event.stopPropagation();\n      event.preventDefault();\n      setOpen(true);\n    }\n  }\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", monitorCmdK);\n    return () => {\n      document.removeEventListener(\"keydown\", monitorCmdK);\n    };\n  }, []);\n\n  return (\n    <Box sx={searchButtonContainer}>\n      <SearchButton\n        isHomePage={isHomePage}\n        type=\"button\"\n        onClick={() => {\n          setOpen(true);\n        }}\n      >\n        <Box\n          sx={{\n            display: \"flex\",\n            justifyContent: \"space-between\",\n            typography: \"subtitle1\",\n            alignItems: \"center\",\n            lineHeight: \"normal\",\n          }}\n        >\n          <Box\n            sx={{ paddingLeft: (theme) => theme.spacing(1), display: \"flex\", alignItems: \"center\" }}\n          >\n            <FontAwesomeIcon icon={faMagnifyingGlass} size=\"xs\" />\n            <Typography sx={{ ml: 2 }}>Search...</Typography>\n          </Box>\n          <Box\n            sx={{\n              typography: \"caption\",\n              fontWeight: \"bold\",\n              color: (theme) => (isHomePage ? theme.palette.text : \"white\"),\n              backgroundColor: (_theme) => (isHomePage ? \"#CECECE\" : \"#235d89\"),\n              padding: (theme) => `${theme.spacing(0.2)} ${theme.spacing(1)}`,\n              borderRadius: (theme) => theme.spacing(0.4),\n            }}\n          >\n            {shortcutText}\n          </Box>\n        </Box>\n      </SearchButton>\n\n      <GlobalSearchDialog />\n    </Box>\n  );\n}\n\nexport default GlobalSearch;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1538, 1549],
              "sourceCode": "import { faMagnifyingGlass } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Typography, styled } from \"@mui/material\";\nimport { useContext, useEffect } from \"react\";\n\nimport GlobalSearchDialog from \"./GlobalSearchDialog\";\nimport { SearchContext } from \"./SearchContext\";\n\nconst SearchButton = styled(\"button\")(({ theme, isHomePage = false }) => ({\n  cursor: \"pointer\",\n  width: \"100%\",\n  maxWidth: isHomePage ? \"90%\" : \"400px\",\n  background: isHomePage ? \"#F0F0F0\" : theme.palette.secondary.main,\n  color: isHomePage ? \"inherit\" : \"white\",\n  borderRadius: theme.spacing(0.6),\n  border: isHomePage ? \"1px solid #F0F0F0\" : `1px solid ${theme.palette.secondary.main}`,\n  padding: isHomePage ? theme.spacing(1) : theme.spacing(0.3),\n}));\n\nfunction GlobalSearch({ isHomePage }) {\n  const { setOpen } = useContext(SearchContext);\n  const shortcutText = navigator?.platform.indexOf(\"Mac\") > -1 ? \"⌘ K\" : \"Ctrl+K\";\n  const searchButtonContainer = {\n    width: 1,\n    display: \"flex\",\n    justifyContent: \"center\",\n    ...(isHomePage && {\n      margin: (theme) => `${theme.spacing(5)} 0 ${theme.spacing(5)}`,\n    }),\n  };\n\n  function monitorCmdK(event) {\n    // open on cmd + k\n    if (event.metaKey === true && event.code === \"KeyK\") {\n      event.stopPropagation();\n      event.preventDefault();\n      setOpen(true);\n    }\n  }\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", monitorCmdK);\n    return () => {\n      document.removeEventListener(\"keydown\", monitorCmdK);\n    };\n  }, []);\n\n  return (\n    <Box sx={searchButtonContainer}>\n      <SearchButton\n        isHomePage={isHomePage}\n        type=\"button\"\n        onClick={() => {\n          setOpen(true);\n        }}\n      >\n        <Box\n          sx={{\n            display: \"flex\",\n            justifyContent: \"space-between\",\n            typography: \"subtitle1\",\n            alignItems: \"center\",\n            lineHeight: \"normal\",\n          }}\n        >\n          <Box\n            sx={{ paddingLeft: (theme) => theme.spacing(1), display: \"flex\", alignItems: \"center\" }}\n          >\n            <FontAwesomeIcon icon={faMagnifyingGlass} size=\"xs\" />\n            <Typography sx={{ ml: 2 }}>Search...</Typography>\n          </Box>\n          <Box\n            sx={{\n              typography: \"caption\",\n              fontWeight: \"bold\",\n              color: (theme) => (isHomePage ? theme.palette.text : \"white\"),\n              backgroundColor: (_theme) => (isHomePage ? \"#CECECE\" : \"#235d89\"),\n              padding: (theme) => `${theme.spacing(0.2)} ${theme.spacing(1)}`,\n              borderRadius: (theme) => theme.spacing(0.4),\n            }}\n          >\n            {shortcutText}\n          </Box>\n        </Box>\n      </SearchButton>\n\n      <GlobalSearchDialog />\n    </Box>\n  );\n}\n\nexport default GlobalSearch;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include them or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearch.jsx" },
        "span": [1400, 1409],
        "sourceCode": "import { faMagnifyingGlass } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Typography, styled } from \"@mui/material\";\nimport { useContext, useEffect } from \"react\";\n\nimport GlobalSearchDialog from \"./GlobalSearchDialog\";\nimport { SearchContext } from \"./SearchContext\";\n\nconst SearchButton = styled(\"button\")(({ theme, isHomePage = false }) => ({\n  cursor: \"pointer\",\n  width: \"100%\",\n  maxWidth: isHomePage ? \"90%\" : \"400px\",\n  background: isHomePage ? \"#F0F0F0\" : theme.palette.secondary.main,\n  color: isHomePage ? \"inherit\" : \"white\",\n  borderRadius: theme.spacing(0.6),\n  border: isHomePage ? \"1px solid #F0F0F0\" : `1px solid ${theme.palette.secondary.main}`,\n  padding: isHomePage ? theme.spacing(1) : theme.spacing(0.3),\n}));\n\nfunction GlobalSearch({ isHomePage }) {\n  const { setOpen } = useContext(SearchContext);\n  const shortcutText = navigator?.platform.indexOf(\"Mac\") > -1 ? \"⌘ K\" : \"Ctrl+K\";\n  const searchButtonContainer = {\n    width: 1,\n    display: \"flex\",\n    justifyContent: \"center\",\n    ...(isHomePage && {\n      margin: (theme) => `${theme.spacing(5)} 0 ${theme.spacing(5)}`,\n    }),\n  };\n\n  function monitorCmdK(event) {\n    // open on cmd + k\n    if (event.metaKey === true && event.code === \"KeyK\") {\n      event.stopPropagation();\n      event.preventDefault();\n      setOpen(true);\n    }\n  }\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", monitorCmdK);\n    return () => {\n      document.removeEventListener(\"keydown\", monitorCmdK);\n    };\n  }, []);\n\n  return (\n    <Box sx={searchButtonContainer}>\n      <SearchButton\n        isHomePage={isHomePage}\n        type=\"button\"\n        onClick={() => {\n          setOpen(true);\n        }}\n      >\n        <Box\n          sx={{\n            display: \"flex\",\n            justifyContent: \"space-between\",\n            typography: \"subtitle1\",\n            alignItems: \"center\",\n            lineHeight: \"normal\",\n          }}\n        >\n          <Box\n            sx={{ paddingLeft: (theme) => theme.spacing(1), display: \"flex\", alignItems: \"center\" }}\n          >\n            <FontAwesomeIcon icon={faMagnifyingGlass} size=\"xs\" />\n            <Typography sx={{ ml: 2 }}>Search...</Typography>\n          </Box>\n          <Box\n            sx={{\n              typography: \"caption\",\n              fontWeight: \"bold\",\n              color: (theme) => (isHomePage ? theme.palette.text : \"white\"),\n              backgroundColor: (_theme) => (isHomePage ? \"#CECECE\" : \"#235d89\"),\n              padding: (theme) => `${theme.spacing(0.2)} ${theme.spacing(1)}`,\n              borderRadius: (theme) => theme.spacing(0.4),\n            }}\n          >\n            {shortcutText}\n          </Box>\n        </Box>\n      </SearchButton>\n\n      <GlobalSearchDialog />\n    </Box>\n  );\n}\n\nexport default GlobalSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/useSemanticElements",
      "severity": "error",
      "description": "The elements with the following roles can be changed to the following elements:\n<input type=\"search\">\n",
      "message": [
        {
          "elements": [],
          "content": "The elements with the following roles can be changed to the following elements:\n<input type=\"search\">\n"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "For examples and more information, see " },
                {
                  "elements": [
                    {
                      "Hyperlink": {
                        "href": "https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles"
                      }
                    }
                  ],
                  "content": "WAI-ARIA Roles"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchDialog.jsx" },
        "span": [1212, 1235],
        "sourceCode": "import { faMagnifyingGlass } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Dialog, DialogContent, DialogTitle, styled } from \"@mui/material\";\nimport { useContext, useState } from \"react\";\n\nimport ErrorBoundary from \"../ErrorBoundary\";\nimport GlobalSearchFreeListItem from \"./GlobalSearchFreeListItem\";\nimport GlobalSearchInput from \"./GlobalSearchInput\";\nimport GlobalSearchList from \"./GlobalSearchList\";\nimport { SearchContext, SearchInputProvider } from \"./SearchContext\";\n\nconst EscButton = styled(\"button\")(({ theme }) => ({\n  display: \"block\",\n  alignSelf: \"center\",\n  cursor: \"pointer\",\n  padding: `${theme.spacing(0.5)} ${theme.spacing(1)}`,\n  margin: `0 ${theme.spacing(0.5)}`,\n  borderRadius: theme.spacing(1),\n  backgroundColor: theme.palette.grey[100],\n  border: `1px solid ${theme.palette.grey[400]}`,\n  \"&:hover\": {\n    border: `1px solid ${theme.palette.primary.main}`,\n    backgroundColor: `${theme.palette.primary.main.light}`,\n  },\n}));\n\nfunction GlobalSearchDialog() {\n  const { open, setOpen } = useContext(SearchContext);\n  const [inputValue, setInputValue] = useState(\"\");\n\n  return (\n    <Dialog\n      open={open}\n      role=\"searchbox\"\n      scroll=\"paper\"\n      tabIndex={0}\n      onClose={() => {\n        setOpen(false);\n      }}\n      sx={{\n        \"& .MuiDialog-container\": {\n          alignItems: \"start\",\n          \"& .MuiPaper-root\": {\n            width: \"80vw\",\n            maxWidth: \"800px\",\n            borderRadius: (theme) => theme.spacing(0.5),\n            margin: (theme) => theme.spacing(6),\n          },\n        },\n      }}\n    >\n      <ErrorBoundary>\n        <SearchInputProvider setValue={setInputValue}>\n          <DialogTitle>\n            <Box sx={{ display: \"flex\", alignItems: \"center\" }}>\n              <Box\n                sx={{\n                  display: \"flex\",\n                  alignItems: \"center\",\n                  fontSize: (theme) => `${theme.spacing(3.5)}`,\n                  color: (theme) => theme.palette.grey[500],\n                }}\n              >\n                <FontAwesomeIcon icon={faMagnifyingGlass} size=\"xs\" />\n              </Box>\n              <Box sx={{ display: \"flex\", flexGrow: \"1\" }}>\n                <GlobalSearchInput />\n              </Box>\n              <Box>\n                <EscButton\n                  type=\"button\"\n                  onClick={() => {\n                    setOpen(false);\n                  }}\n                >\n                  esc\n                </EscButton>\n              </Box>\n            </Box>\n          </DialogTitle>\n          <DialogContent dividers>\n            <GlobalSearchFreeListItem />\n            <GlobalSearchList inputValue={inputValue} />\n          </DialogContent>\n        </SearchInputProvider>\n      </ErrorBoundary>\n    </Dialog>\n  );\n}\n\nexport default GlobalSearchDialog;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [712, 717],
              "sourceCode": "import { Grid, Grow, Skeleton } from \"@mui/material\";\n\nfunction GlobalSearchLoadingState() {\n  const listItemsToShow = new Array<number>(4).fill(0);\n  return (\n    <Grow appear in>\n      <div>\n        <Grid container justifyContent=\"flex-start\" alignItems=\"center\" style={{ padding: 20 }}>\n          <Grid\n            container\n            justifyContent=\"flex-start\"\n            alignItems=\"center\"\n            style={{\n              marginBottom: \"1rem\",\n            }}\n          >\n            <Skeleton animation=\"wave\" variant=\"circular\" width=\"2rem\" height=\"2rem\" />\n            <Skeleton variant=\"text\" animation=\"wave\" width=\"10vw\" height=\"3vh\" />\n          </Grid>\n          {listItemsToShow.map((_item, index) => (\n            <Grid\n              key={index}\n              container\n              justifyContent=\"flex-start\"\n              alignItems=\"center\"\n              style={{\n                borderTop: \"0.1px solid #60606033\",\n                padding: \"1rem\",\n              }}\n            >\n              <Grid container justifyContent=\"space-between\" className=\"name-container\">\n                <Skeleton animation=\"wave\" width=\"20vw\" height=\"2vh\" />\n                <Skeleton animation=\"wave\" width=\"6vw\" height=\"1vh\" />\n              </Grid>\n              <Grid className=\"author-container\">\n                <Skeleton animation=\"wave\" width=\"15vw\" height=\"2vh\" />\n              </Grid>\n            </Grid>\n          ))}\n        </Grid>\n      </div>\n    </Grow>\n  );\n}\n\nexport default GlobalSearchLoadingState;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": {
          "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchLoadingState.tsx"
        },
        "span": [761, 766],
        "sourceCode": "import { Grid, Grow, Skeleton } from \"@mui/material\";\n\nfunction GlobalSearchLoadingState() {\n  const listItemsToShow = new Array<number>(4).fill(0);\n  return (\n    <Grow appear in>\n      <div>\n        <Grid container justifyContent=\"flex-start\" alignItems=\"center\" style={{ padding: 20 }}>\n          <Grid\n            container\n            justifyContent=\"flex-start\"\n            alignItems=\"center\"\n            style={{\n              marginBottom: \"1rem\",\n            }}\n          >\n            <Skeleton animation=\"wave\" variant=\"circular\" width=\"2rem\" height=\"2rem\" />\n            <Skeleton variant=\"text\" animation=\"wave\" width=\"10vw\" height=\"3vh\" />\n          </Grid>\n          {listItemsToShow.map((_item, index) => (\n            <Grid\n              key={index}\n              container\n              justifyContent=\"flex-start\"\n              alignItems=\"center\"\n              style={{\n                borderTop: \"0.1px solid #60606033\",\n                padding: \"1rem\",\n              }}\n            >\n              <Grid container justifyContent=\"space-between\" className=\"name-container\">\n                <Skeleton animation=\"wave\" width=\"20vw\" height=\"2vh\" />\n                <Skeleton animation=\"wave\" width=\"6vw\" height=\"1vh\" />\n              </Grid>\n              <Grid className=\"author-container\">\n                <Skeleton animation=\"wave\" width=\"15vw\" height=\"2vh\" />\n              </Grid>\n            </Grid>\n          ))}\n        </Grid>\n      </div>\n    </Grow>\n  );\n}\n\nexport default GlobalSearchLoadingState;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/style/noNonNullAssertion",
      "severity": "error",
      "description": "Forbidden non-null assertion.",
      "message": [{ "elements": [], "content": "Forbidden non-null assertion." }],
      "advices": { "advices": [] },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Footer.tsx" },
        "span": [2504, 2509],
        "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noRedundantAlt",
      "severity": "error",
      "description": "Avoid the words \"image\", \"picture\", or \"photo\" in img element alt text.",
      "message": [
        { "elements": [], "content": "Avoid the words \"image\", \"picture\", or \"photo\" in " },
        { "elements": ["Emphasis"], "content": "img" },
        { "elements": [], "content": " element alt text." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Screen readers announce img elements as \"images\", so it is not necessary to redeclare this in alternative text."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Footer.tsx" },
        "span": [4674, 4695],
        "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/noRedundantAlt",
      "severity": "error",
      "description": "Avoid the words \"image\", \"picture\", or \"photo\" in img element alt text.",
      "message": [
        { "elements": [], "content": "Avoid the words \"image\", \"picture\", or \"photo\" in " },
        { "elements": ["Emphasis"], "content": "img" },
        { "elements": [], "content": " element alt text." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Screen readers announce img elements as \"images\", so it is not necessary to redeclare this in alternative text."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Footer.tsx" },
        "span": [4964, 4985],
        "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [2336, 2337],
              "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Footer.tsx" },
        "span": [2370, 2371],
        "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [3196, 3197],
              "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Footer.tsx" },
        "span": [3298, 3299],
        "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [3196, 3197],
              "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Footer.tsx" },
        "span": [3477, 3478],
        "sourceCode": "import type { IconProp } from \"@fortawesome/fontawesome-svg-core\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Grid, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\n\nimport { EmailLink } from \"./EmailLink\";\nimport Link from \"./Link\";\n\nimport { useConfigContext } from \"../providers/ConfigurationProvider\";\nimport PrivateWrapper from \"./PrivateWrapper\";\n\nconst FOOTER_BACKGROUND_COLOR = \"#2e2d35\";\n\nconst useStyles = makeStyles(() => ({\n  footer: {\n    backgroundColor: FOOTER_BACKGROUND_COLOR,\n    color: \"#fff\",\n    margin: 0,\n    width: \"100%\",\n  },\n}));\n\nconst useLinkStyles = makeStyles(() => ({\n  iconClass: {\n    marginRight: \"10px\",\n  },\n  linkContainer: {\n    marginBottom: \"8px\",\n  },\n}));\n\nexport type FooterExternalLink = {\n  url: string;\n  label?: string;\n  showOnlyPartner?: boolean;\n  icon?: IconProp;\n};\n\nconst FooterLink = ({ label, url, icon }: FooterExternalLink) => {\n  const classes = useLinkStyles();\n  return (\n    <Grid item xs={12} sx={{ mb: 1 }}>\n      <Typography color=\"inherit\">\n        {url.startsWith(\"mailto\") ? (\n          <EmailLink href={url} label={label} icon={icon} />\n        ) : (\n          <Link ariaLabel={`Read more about ${label} on this link`} external footer to={url}>\n            {icon && <FontAwesomeIcon className={classes.iconClass} icon={icon} size=\"lg\" />}\n            {label}\n          </Link>\n        )}\n      </Typography>\n    </Grid>\n  );\n};\n\ntype FooterSectionHeadingProps = {\n  children: React.ReactNode;\n};\nconst FooterSectionHeading = ({ children }: FooterSectionHeadingProps) => (\n  <Grid item xs={12}>\n    <Typography variant=\"h6\" component=\"div\" color=\"inherit\">\n      {children}\n    </Typography>\n  </Grid>\n);\n\nconst useSocialLinkStyle = makeStyles(() => ({\n  iconsContainer: {\n    maxWidth: \"235px\",\n  },\n  socialIcon: {\n    fontSize: \"30px\",\n    color: \"white\",\n  },\n}));\n\ntype FooterSocialProps = {\n  social: FooterExternalLink[];\n};\nconst FooterSocial = ({ social }: FooterSocialProps) => {\n  const classes = useSocialLinkStyle();\n  const socialsWithIcons = social.filter((s) => s.icon);\n  return (\n    <>\n      <FooterSectionHeading>Follow us</FooterSectionHeading>\n      <Grid className={classes.iconsContainer} container justifyContent=\"space-between\">\n        {socialsWithIcons.map(({ icon, url, label }, i) => (\n          <Grid item key={i}>\n            <Link external footer to={url} ariaLabel={label}>\n              <FontAwesomeIcon className={classes.socialIcon} icon={icon!} />\n            </Link>\n          </Grid>\n        ))}\n      </Grid>\n    </>\n  );\n};\n\nconst useSectionStyles = makeStyles({\n  section: {\n    width: \"100%\",\n  },\n});\n\ntype FooterSectionProps = {\n  heading: React.ReactNode;\n  links: FooterExternalLink[];\n  social?: FooterExternalLink[];\n  children?: React.ReactNode;\n};\nconst FooterSection = ({ heading, links, social, children }: FooterSectionProps) => {\n  const classes = useSectionStyles();\n  return (\n    <Grid item xs={12} sm={6} md={3} container direction=\"column\" justifyContent=\"space-between\">\n      <Grid item className={classes.section}>\n        <FooterSectionHeading>{heading}</FooterSectionHeading>\n        {links.map((link, i) => {\n          if (link.showOnlyPartner) {\n            return (\n              <PrivateWrapper key={i}>\n                <FooterLink label={link.label} url={link.url} icon={link.icon} />\n              </PrivateWrapper>\n            );\n          }\n          return <FooterLink key={i} label={link.label} url={link.url} icon={link.icon} />;\n        })}\n      </Grid>\n\n      {social ? (\n        <Grid item>\n          <FooterSocial social={social} />\n        </Grid>\n      ) : null}\n      {children}\n    </Grid>\n  );\n};\n\n// Creative Commons License\nconst useLicenseStyles = makeStyles({\n  icon: {\n    marginLeft: \"3px\",\n    verticalAlign: \"middle\",\n  },\n  link: {\n    display: \"inline-block\",\n  },\n});\n\ntype LicenseCC0Props = {\n  link: FooterExternalLink;\n};\nconst LicenseCC0 = ({ link }: LicenseCC0Props) => {\n  const classes = useLicenseStyles();\n  return (\n    <div>\n      <Typography color=\"inherit\" variant=\"caption\">\n        <Link\n          ariaLabel={`Read more about ${link.label} on this link`}\n          to={link.url}\n          external\n          footer\n          className={classes.link}\n        >\n          {link.label}\n        </Link>{\" \"}\n        is marked with{\" \"}\n        <Link\n          to=\"http://creativecommons.org/publicdomain/zero/1.0?ref=chooser-v1\"\n          external\n          footer\n          className={classes.link}\n          ariaLabel={\"Read more about creative commons license on this link\"}\n        >\n          CC0 1.0\n          <img\n            alt=\"cc0 license image 1\"\n            aria-label=\"cc0 license image 1\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n          <img\n            alt=\"cc0 license image 2\"\n            aria-label=\"cc0 license image 2\"\n            className={classes.icon}\n            src=\"https://mirrors.creativecommons.org/presskit/icons/zero.svg?ref=chooser-v1\"\n            height=\"22px\"\n            width=\"22px\"\n          />\n        </Link>\n      </Typography>\n    </div>\n  );\n};\n\nconst UIVersion = () => {\n  const { config } = useConfigContext();\n  return (\n    <Typography color=\"inherit\" variant=\"caption\">\n      <b>{config?.gitVersion}</b>\n    </Typography>\n  );\n};\n\nexport type FooterExternalLinks = {\n  about: FooterExternalLink[];\n  help: FooterExternalLink[];\n  license: FooterExternalLink;\n  partners: FooterExternalLink[];\n  network: FooterExternalLink[];\n  social: FooterExternalLink[];\n};\ntype FooterProps = {\n  externalLinks: FooterExternalLinks;\n};\nconst Footer = ({ externalLinks }: FooterProps) => {\n  const classes = useStyles();\n  return (\n    <Grid sx={{ p: 3 }} className={classes.footer} container justifyContent=\"center\" spacing={3}>\n      <Grid item container xs={12} md={10} spacing={2}>\n        <FooterSection heading=\"About\" links={externalLinks.about}>\n          <LicenseCC0 link={externalLinks.license} />\n          <UIVersion />\n        </FooterSection>\n        <FooterSection heading=\"Help\" links={externalLinks.help} social={externalLinks.social} />\n        <FooterSection heading=\"Partners\" links={externalLinks.partners} />\n        <FooterSection heading=\"About Open Targets\" links={externalLinks.network} />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default Footer;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: setValue",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: setValue"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2136, 2144],
              "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { getSuggestedSearch } from \"@ot/utils\";\nimport { createContext, useContext, useEffect, useState } from \"react\";\nimport useDebounce from \"../../hooks/useDebounce\";\n\nconst searchSuggestions = getSuggestedSearch();\n\n/**********************************\n * GLOBAL SEARCH CONTEXT/PROVIDER *\n **********************************/\ntype GlobalSearchProviderProps = {\n  children: React.ReactNode;\n  searchQuery: DocumentNode;\n  searchPlaceholder: string;\n};\n\nexport const SearchContext = createContext<{\n  searchQuery: any;\n  searchPlaceholder: string;\n  open: boolean;\n  setOpen: (arg: boolean) => void;\n  searchSuggestions: Array<any>;\n}>({\n  searchQuery: \"\",\n  searchPlaceholder: \"Search...\",\n  open: false,\n  setOpen: () => undefined,\n  searchSuggestions: [],\n});\n\nexport function SearchProvider({\n  children,\n  searchQuery,\n  searchPlaceholder = \"Search...\",\n}: GlobalSearchProviderProps) {\n  const [open, setOpen] = useState(false);\n\n  return (\n    <SearchContext.Provider\n      value={{\n        searchQuery,\n        searchPlaceholder,\n        open,\n        setOpen,\n        searchSuggestions,\n      }}\n    >\n      {children}\n    </SearchContext.Provider>\n  );\n}\n\n/**\n * Hook to access and interact with the search state\n * @returns Search context values and methods\n */\nexport function useSearchState() {\n  const context = useContext(SearchContext);\n\n  if (context === undefined) {\n    throw new Error(\"useSearch must be used within a SearchProvider\");\n  }\n\n  return context;\n}\n\n/*********************************\n * SEARCH INPUT CONTEXT/PROVIDER *\n *********************************/\ntype SearchInputProviderProps = {\n  children: React.ReactNode;\n  setValue: (arg: string) => void;\n};\n\nexport const SearchInputContext = createContext<{\n  inputValue: string;\n  setInputValue: (arg: string) => void;\n}>({\n  inputValue: \"\",\n  setInputValue: () => {},\n});\n\nexport function SearchInputProvider({ children, setValue }: SearchInputProviderProps) {\n  const [inputValue, setInputValue] = useState(\"\");\n\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  useEffect(() => {\n    setValue(debouncedInputValue);\n  }, [debouncedInputValue]);\n\n  return (\n    <SearchInputContext.Provider\n      value={{\n        inputValue,\n        setInputValue,\n      }}\n    >\n      {children}\n    </SearchInputContext.Provider>\n  );\n}\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/SearchContext.tsx" },
        "span": [2114, 2123],
        "sourceCode": "import type { DocumentNode } from \"@apollo/client\";\nimport { getSuggestedSearch } from \"@ot/utils\";\nimport { createContext, useContext, useEffect, useState } from \"react\";\nimport useDebounce from \"../../hooks/useDebounce\";\n\nconst searchSuggestions = getSuggestedSearch();\n\n/**********************************\n * GLOBAL SEARCH CONTEXT/PROVIDER *\n **********************************/\ntype GlobalSearchProviderProps = {\n  children: React.ReactNode;\n  searchQuery: DocumentNode;\n  searchPlaceholder: string;\n};\n\nexport const SearchContext = createContext<{\n  searchQuery: any;\n  searchPlaceholder: string;\n  open: boolean;\n  setOpen: (arg: boolean) => void;\n  searchSuggestions: Array<any>;\n}>({\n  searchQuery: \"\",\n  searchPlaceholder: \"Search...\",\n  open: false,\n  setOpen: () => undefined,\n  searchSuggestions: [],\n});\n\nexport function SearchProvider({\n  children,\n  searchQuery,\n  searchPlaceholder = \"Search...\",\n}: GlobalSearchProviderProps) {\n  const [open, setOpen] = useState(false);\n\n  return (\n    <SearchContext.Provider\n      value={{\n        searchQuery,\n        searchPlaceholder,\n        open,\n        setOpen,\n        searchSuggestions,\n      }}\n    >\n      {children}\n    </SearchContext.Provider>\n  );\n}\n\n/**\n * Hook to access and interact with the search state\n * @returns Search context values and methods\n */\nexport function useSearchState() {\n  const context = useContext(SearchContext);\n\n  if (context === undefined) {\n    throw new Error(\"useSearch must be used within a SearchProvider\");\n  }\n\n  return context;\n}\n\n/*********************************\n * SEARCH INPUT CONTEXT/PROVIDER *\n *********************************/\ntype SearchInputProviderProps = {\n  children: React.ReactNode;\n  setValue: (arg: string) => void;\n};\n\nexport const SearchInputContext = createContext<{\n  inputValue: string;\n  setInputValue: (arg: string) => void;\n}>({\n  inputValue: \"\",\n  setInputValue: () => {},\n});\n\nexport function SearchInputProvider({ children, setValue }: SearchInputProviderProps) {\n  const [inputValue, setInputValue] = useState(\"\");\n\n  const debouncedInputValue = useDebounce(inputValue, 300);\n\n  useEffect(() => {\n    setValue(debouncedInputValue);\n  }, [debouncedInputValue]);\n\n  return (\n    <SearchInputContext.Provider\n      value={{\n        inputValue,\n        setInputValue,\n      }}\n    >\n      {children}\n    </SearchInputContext.Provider>\n  );\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [2515, 2603],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: selected",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: selected"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2401, 2409],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [2368, 2379],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: setOpen",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: setOpen" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2882, 2889],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [2825, 2836],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: openListItem",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: openListItem"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3599, 3611],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [3551, 3562],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: setOpen",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: setOpen" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3579, 3586],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [3551, 3562],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: fetchSearchResults",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: fetchSearchResults"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5468, 5486],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [5411, 5420],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: focusOnItem",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: focusOnItem"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5433, 5444],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [5411, 5420],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: handleChangeInRecentItems",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: handleChangeInRecentItems"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5660, 5685],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5813, 5838],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include them or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [5543, 5552],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: onKeyDownHandler",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: onKeyDownHandler"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5602, 5618],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [5753, 5769],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include them or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/GlobalSearchList.jsx" },
        "span": [5543, 5552],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { Box, styled } from \"@mui/material\";\nimport { memo, useCallback, useContext, useEffect, useState } from \"react\";\nimport useListOption from \"../../hooks/useListOption\";\nimport GlobalSearchListHeader from \"./GlobalSearchListHeader\";\nimport GlobalSearchListItem from \"./GlobalSearchListItem\";\nimport GlobalSearchLoadingState from \"./GlobalSearchLoadingState\";\nimport { SearchContext } from \"./SearchContext\";\nimport VariantMessage from \"./VariantMessage\";\nimport { formatSearchData } from \"./utils/searchUtils\";\n\nconst VARIANT_COMPONENTS = {\n  CHROMOSOME: \"(?:chr)?(?:[1-9]|1[0-9]|2[0-2]|X|Y|MT)\",\n  FIRST_SEPARATOR: \"[_:]\",\n  POSITION: \"\\\\d+\",\n  SECOND_SEPARATOR: \"[_:]\",\n  REF_ALLELE: \"[A-Za-z]+\",\n  THIRD_SEPARATOR: \"[_-]\",\n  ALT_ALLELE: \"[A-Za-z]+\",\n};\n\nconst VARIANT_PATTERNS = {\n  LOCATION_ID: new RegExp(\n    `^${VARIANT_COMPONENTS.CHROMOSOME}` +\n      `${VARIANT_COMPONENTS.FIRST_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.POSITION}` +\n      `${VARIANT_COMPONENTS.SECOND_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.REF_ALLELE}` +\n      `${VARIANT_COMPONENTS.THIRD_SEPARATOR}` +\n      `${VARIANT_COMPONENTS.ALT_ALLELE}$`\n  ),\n  RS_ID: /^rs\\d+$/i,\n};\n\nfunction isValidVariantFormat(input) {\n  return VARIANT_PATTERNS.LOCATION_ID.test(input) || VARIANT_PATTERNS.RS_ID.test(input);\n}\n\nfunction validateVariantIdInput(input, searchResult, isResultEmpty) {\n  if (!input) return false;\n  if (isResultEmpty) return isValidVariantFormat(input);\n  const isVariantTopHit = searchResult?.topHit?.[0]?.entity === \"variant\";\n  if (isVariantTopHit) return false;\n  return isValidVariantFormat(input);\n}\n\nconst List = styled(\"ul\")(({ theme }) => ({\n  margin: \"0\",\n  padding: \"0\",\n  \"& .search-list-item\": {\n    transition: \"background ease-in 50ms\",\n  },\n  \"& .search-list-item-active\": {\n    background: theme.palette.grey[\"300\"],\n  },\n}));\n\nfunction GlobalSearchList({ inputValue }) {\n  let selected = 0;\n  const [searchResult, setSearchResult] = useState({});\n  const [loading, setLoading] = useState(false);\n  const { searchQuery, setOpen, searchSuggestions } = useContext(SearchContext);\n  const [getSearchData] = useLazyQuery(searchQuery);\n  const [openListItem] = useListOption();\n  const [recentItems, setRecentItems] = useState(\n    JSON.parse(localStorage.getItem(\"search-history\")) || []\n  );\n\n  const focusOnItem = useCallback((index = 0) => {\n    selected = index;\n    const items = document.querySelectorAll(\".search-list-item\");\n    if (items.length) {\n      items.forEach((el) => {\n        el.classList.remove(\"search-list-item-active\");\n      });\n      items[index].classList.add(\"search-list-item-active\");\n      items[index].scrollIntoView({\n        behavior: \"smooth\",\n        block: index ? \"center\" : \"end\",\n      });\n    }\n  }, []);\n\n  const onKeyDownHandler = useCallback((e) => {\n    if (e.key === \"Escape\") {\n      setOpen(false);\n      e.preventDefault();\n      e.stopPropagation();\n      // onInputValueChange(\"\");\n    } else if (e.code === \"ArrowDown\") {\n      handleChangeSelected(\"down\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.code === \"ArrowUp\") {\n      handleChangeSelected(\"up\");\n      e.preventDefault();\n      e.stopPropagation();\n    } else if (e.key === \"Enter\") {\n      const selectedElement = document.querySelector(\".search-list-item-active\");\n      const item = JSON.parse(selectedElement.dataset.itemDetails);\n      handleItemClick(item);\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }, []);\n\n  const handleItemClick = useCallback((item) => {\n    setOpen(false);\n    openListItem(item);\n  }, []);\n\n  function fetchSearchResults() {\n    setLoading(true);\n    getSearchData({ variables: { queryString: inputValue } })\n      .then((res) => {\n        const formattedData = formatSearchData(res.data.search || res.data);\n        setSearchResult({ ...formattedData });\n        setLoading(false);\n      })\n      .catch((_err) => {\n        setLoading(false);\n      });\n  }\n\n  function isResultEmpty() {\n    return Object.keys(searchResult).length === 0;\n  }\n\n  function handleChangeSelected(direction) {\n    const items = document.querySelectorAll(\".search-list-item\");\n\n    let index = 0;\n    let newIndex = 0;\n\n    if (direction === \"down\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = index === items.length - 1 ? 0 : index + 1;\n    } else if (direction === \"up\") {\n      items.forEach((_, i) => {\n        if (i === selected) {\n          index = i;\n        }\n      });\n\n      newIndex = !index ? items.length - 1 : index - 1;\n    } else {\n      selected = 0;\n    }\n\n    const newItem = items[newIndex];\n\n    if (newItem && typeof newIndex === \"number\") {\n      selected = newIndex;\n      focusOnItem(newIndex);\n    }\n  }\n\n  function handleChangeInRecentItems() {\n    setRecentItems(JSON.parse(localStorage.getItem(\"search-history\")) || []);\n  }\n\n  const SearchSuggestionEl = (\n    <Box\n      sx={{\n        pt: 1,\n      }}\n    >\n      <GlobalSearchListHeader listHeader=\"Search Suggestions\" />\n      <List tabIndex={-1}>\n        {searchSuggestions.map((item) => (\n          <GlobalSearchListItem\n            key={item.id || item.symbol}\n            item={item}\n            onItemClick={handleItemClick}\n            isTopHit={item.type === \"topHit\"}\n          />\n        ))}\n      </List>\n    </Box>\n  );\n\n  useEffect(() => {\n    focusOnItem();\n    if (inputValue) fetchSearchResults();\n    else setSearchResult({});\n  }, [inputValue]);\n\n  useEffect(() => {\n    document.addEventListener(\"keydown\", onKeyDownHandler);\n    window.addEventListener(\"storage\", handleChangeInRecentItems);\n    return () => {\n      document.removeEventListener(\"keydown\", onKeyDownHandler);\n      window.addEventListener(\"storage\", handleChangeInRecentItems);\n    };\n  }, []);\n\n  const inputMatchVariant = validateVariantIdInput(inputValue, searchResult, isResultEmpty());\n\n  return (\n    <>\n      {inputValue && loading && <GlobalSearchLoadingState />}\n\n      {inputMatchVariant && !loading && <VariantMessage inputValue={inputValue} />}\n\n      {/* input value is present and there are results available */}\n      {inputValue &&\n        !loading &&\n        !isResultEmpty() &&\n        Object.entries(searchResult).map(([key, value]) => (\n          <Box\n            key={key}\n            sx={{\n              pt: 1,\n              borderBottomWidth: \"1px\",\n              borderStyle: \"solid\",\n              borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n            }}\n          >\n            <GlobalSearchListHeader listHeader={key} />\n            <List tabIndex={-1}>\n              {value.map((item) => (\n                <GlobalSearchListItem\n                  key={item.id || item.symbol}\n                  item={item}\n                  onItemClick={handleItemClick}\n                  isTopHit={item.type === \"topHit\"}\n                />\n              ))}\n            </List>\n          </Box>\n        ))}\n\n      {/* no search result state  */}\n      {inputValue && !loading && isResultEmpty() && (\n        <>\n          <Box sx={{ display: \"flex\", justifyContent: \"center\", my: 2 }}>\n            No search result found\n          </Box>\n          {SearchSuggestionEl}\n        </>\n      )}\n\n      {/* input value is not present */}\n      {!inputValue && recentItems.length > 0 && (\n        <Box\n          sx={{\n            pt: 1,\n            borderBottomWidth: \"1px\",\n            borderStyle: \"solid\",\n            borderImage: \"linear-gradient(to right, white, #00000037, white)0 0 90\",\n          }}\n        >\n          <GlobalSearchListHeader listHeader=\"recent\" />\n          <List tabIndex={-1}>\n            {recentItems.map((item) => (\n              <GlobalSearchListItem\n                key={item.id || item.symbol}\n                item={item}\n                onItemClick={handleItemClick}\n              />\n            ))}\n          </List>\n        </Box>\n      )}\n\n      {/* no input value search suggestions */}\n      {!inputValue && SearchSuggestionEl}\n    </>\n  );\n}\n\nexport default memo(GlobalSearchList);\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/utils/searchUtils.js" },
        "span": [497, 934],
        "sourceCode": "import { format } from \"d3-format\";\n\nconst mapStandardKeys = (originalKey) => {\n  switch (originalKey) {\n    case \"studyId\":\n      return \"id\";\n    case \"traitReported\":\n      return \"name\";\n    case \"traitFromSource\":\n      return \"name\";\n    case \"approvedName\":\n      return \"name\";\n    case \"approvedSymbol\":\n      return \"symbol\";\n    case \"functionDescriptions\":\n      return \"description\";\n    default:\n      return originalKey;\n  }\n};\n\nconst flattenObj = (ob) => {\n  const result = {};\n\n  Object.entries(ob).forEach(([key, value]) => {\n    if (value && typeof value === \"object\" && !Array.isArray(value)) {\n      const temp = flattenObj(value);\n      Object.entries(temp).forEach(([nestedKey, nestedValue]) => {\n        result[nestedKey] = nestedValue;\n      });\n    } else if (key === \"functionDescriptions\") {\n      result[mapStandardKeys(key)] = value[0];\n    } else {\n      result[mapStandardKeys(key)] = value;\n    }\n  });\n  return result;\n};\n\nconst exceedsArrayLengthLimit = (array) => {\n  const limitLength = 4;\n  let exceedsLimit = false;\n\n  if (array.length > limitLength) {\n    exceedsLimit = true;\n  }\n  return exceedsLimit;\n};\n\nexport const formatSearchData = (unformattedData) => {\n  const formattedData = {};\n\n  Object.entries(unformattedData).forEach(([key, value]) => {\n    const typesArray = [];\n\n    value.hits.map((i) =>\n      typesArray.push({\n        type: key === \"topHit\" ? \"topHit\" : i.entity,\n        entity: i.entity,\n        ...flattenObj(i.object),\n      })\n    );\n\n    if (typesArray.length > 0) formattedData[key] = typesArray;\n  });\n\n  return formattedData;\n};\n\nexport const containsObject = (obj, list) => {\n  for (let i = 0; i < list.length; i++) {\n    if (JSON.stringify(list[i]) === JSON.stringify(obj)) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nexport const addSearchToLocalStorage = (item) => {\n  const recentItems = JSON.parse(localStorage.getItem(\"search-history\")) || [];\n  const newItem = { ...item };\n  newItem.description = undefined;\n  const existingIndex = containsObject(newItem, recentItems);\n\n  if (existingIndex >= 0) {\n    recentItems.splice(existingIndex, 1);\n  }\n  const recentItemsDeepCopy = [...recentItems];\n  if (exceedsArrayLengthLimit(recentItemsDeepCopy)) recentItemsDeepCopy.pop();\n  if (newItem) {\n    recentItemsDeepCopy.unshift(newItem);\n    localStorage.setItem(\"search-history\", JSON.stringify(recentItemsDeepCopy));\n  }\n};\n\nexport const clearAllRecent = () => {\n  localStorage.removeItem(\"search-history\");\n  window.dispatchEvent(new Event(\"storage\"));\n};\n\nexport const clearRecentItem = (item) => {\n  const recentItems = JSON.parse(localStorage.getItem(\"search-history\"));\n  const removedItems = [...recentItems];\n  const existingIndex = containsObject(item, removedItems);\n  removedItems.splice(existingIndex, 1);\n  localStorage.setItem(\"search-history\", JSON.stringify(removedItems));\n  window.dispatchEvent(new Event(\"storage\"));\n  return removedItems;\n};\n\nexport const commaSeparate = format(\",\");\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/utils/searchUtils.js" },
        "span": [659, 769],
        "sourceCode": "import { format } from \"d3-format\";\n\nconst mapStandardKeys = (originalKey) => {\n  switch (originalKey) {\n    case \"studyId\":\n      return \"id\";\n    case \"traitReported\":\n      return \"name\";\n    case \"traitFromSource\":\n      return \"name\";\n    case \"approvedName\":\n      return \"name\";\n    case \"approvedSymbol\":\n      return \"symbol\";\n    case \"functionDescriptions\":\n      return \"description\";\n    default:\n      return originalKey;\n  }\n};\n\nconst flattenObj = (ob) => {\n  const result = {};\n\n  Object.entries(ob).forEach(([key, value]) => {\n    if (value && typeof value === \"object\" && !Array.isArray(value)) {\n      const temp = flattenObj(value);\n      Object.entries(temp).forEach(([nestedKey, nestedValue]) => {\n        result[nestedKey] = nestedValue;\n      });\n    } else if (key === \"functionDescriptions\") {\n      result[mapStandardKeys(key)] = value[0];\n    } else {\n      result[mapStandardKeys(key)] = value;\n    }\n  });\n  return result;\n};\n\nconst exceedsArrayLengthLimit = (array) => {\n  const limitLength = 4;\n  let exceedsLimit = false;\n\n  if (array.length > limitLength) {\n    exceedsLimit = true;\n  }\n  return exceedsLimit;\n};\n\nexport const formatSearchData = (unformattedData) => {\n  const formattedData = {};\n\n  Object.entries(unformattedData).forEach(([key, value]) => {\n    const typesArray = [];\n\n    value.hits.map((i) =>\n      typesArray.push({\n        type: key === \"topHit\" ? \"topHit\" : i.entity,\n        entity: i.entity,\n        ...flattenObj(i.object),\n      })\n    );\n\n    if (typesArray.length > 0) formattedData[key] = typesArray;\n  });\n\n  return formattedData;\n};\n\nexport const containsObject = (obj, list) => {\n  for (let i = 0; i < list.length; i++) {\n    if (JSON.stringify(list[i]) === JSON.stringify(obj)) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nexport const addSearchToLocalStorage = (item) => {\n  const recentItems = JSON.parse(localStorage.getItem(\"search-history\")) || [];\n  const newItem = { ...item };\n  newItem.description = undefined;\n  const existingIndex = containsObject(newItem, recentItems);\n\n  if (existingIndex >= 0) {\n    recentItems.splice(existingIndex, 1);\n  }\n  const recentItemsDeepCopy = [...recentItems];\n  if (exceedsArrayLengthLimit(recentItemsDeepCopy)) recentItemsDeepCopy.pop();\n  if (newItem) {\n    recentItemsDeepCopy.unshift(newItem);\n    localStorage.setItem(\"search-history\", JSON.stringify(recentItemsDeepCopy));\n  }\n};\n\nexport const clearAllRecent = () => {\n  localStorage.removeItem(\"search-history\");\n  window.dispatchEvent(new Event(\"storage\"));\n};\n\nexport const clearRecentItem = (item) => {\n  const recentItems = JSON.parse(localStorage.getItem(\"search-history\"));\n  const removedItems = [...recentItems];\n  const existingIndex = containsObject(item, removedItems);\n  removedItems.splice(existingIndex, 1);\n  localStorage.setItem(\"search-history\", JSON.stringify(removedItems));\n  window.dispatchEvent(new Event(\"storage\"));\n  return removedItems;\n};\n\nexport const commaSeparate = format(\",\");\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/GlobalSearch/utils/searchUtils.js" },
        "span": [1234, 1570],
        "sourceCode": "import { format } from \"d3-format\";\n\nconst mapStandardKeys = (originalKey) => {\n  switch (originalKey) {\n    case \"studyId\":\n      return \"id\";\n    case \"traitReported\":\n      return \"name\";\n    case \"traitFromSource\":\n      return \"name\";\n    case \"approvedName\":\n      return \"name\";\n    case \"approvedSymbol\":\n      return \"symbol\";\n    case \"functionDescriptions\":\n      return \"description\";\n    default:\n      return originalKey;\n  }\n};\n\nconst flattenObj = (ob) => {\n  const result = {};\n\n  Object.entries(ob).forEach(([key, value]) => {\n    if (value && typeof value === \"object\" && !Array.isArray(value)) {\n      const temp = flattenObj(value);\n      Object.entries(temp).forEach(([nestedKey, nestedValue]) => {\n        result[nestedKey] = nestedValue;\n      });\n    } else if (key === \"functionDescriptions\") {\n      result[mapStandardKeys(key)] = value[0];\n    } else {\n      result[mapStandardKeys(key)] = value;\n    }\n  });\n  return result;\n};\n\nconst exceedsArrayLengthLimit = (array) => {\n  const limitLength = 4;\n  let exceedsLimit = false;\n\n  if (array.length > limitLength) {\n    exceedsLimit = true;\n  }\n  return exceedsLimit;\n};\n\nexport const formatSearchData = (unformattedData) => {\n  const formattedData = {};\n\n  Object.entries(unformattedData).forEach(([key, value]) => {\n    const typesArray = [];\n\n    value.hits.map((i) =>\n      typesArray.push({\n        type: key === \"topHit\" ? \"topHit\" : i.entity,\n        entity: i.entity,\n        ...flattenObj(i.object),\n      })\n    );\n\n    if (typesArray.length > 0) formattedData[key] = typesArray;\n  });\n\n  return formattedData;\n};\n\nexport const containsObject = (obj, list) => {\n  for (let i = 0; i < list.length; i++) {\n    if (JSON.stringify(list[i]) === JSON.stringify(obj)) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nexport const addSearchToLocalStorage = (item) => {\n  const recentItems = JSON.parse(localStorage.getItem(\"search-history\")) || [];\n  const newItem = { ...item };\n  newItem.description = undefined;\n  const existingIndex = containsObject(newItem, recentItems);\n\n  if (existingIndex >= 0) {\n    recentItems.splice(existingIndex, 1);\n  }\n  const recentItemsDeepCopy = [...recentItems];\n  if (exceedsArrayLengthLimit(recentItemsDeepCopy)) recentItemsDeepCopy.pop();\n  if (newItem) {\n    recentItemsDeepCopy.unshift(newItem);\n    localStorage.setItem(\"search-history\", JSON.stringify(recentItemsDeepCopy));\n  }\n};\n\nexport const clearAllRecent = () => {\n  localStorage.removeItem(\"search-history\");\n  window.dispatchEvent(new Event(\"storage\"));\n};\n\nexport const clearRecentItem = (item) => {\n  const recentItems = JSON.parse(localStorage.getItem(\"search-history\"));\n  const removedItems = [...recentItems];\n  const existingIndex = containsObject(item, removedItems);\n  removedItems.splice(existingIndex, 1);\n  localStorage.setItem(\"search-history\", JSON.stringify(removedItems));\n  window.dispatchEvent(new Event(\"storage\"));\n  return removedItems;\n};\n\nexport const commaSeparate = format(\",\");\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: legendOptions",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: legendOptions"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [312, 325],
              "sourceCode": "import { Box, Typography } from \"@mui/material\";\nimport * as PlotLib from \"@observablehq/plot\";\nimport { useEffect, useRef } from \"react\";\nimport { Link, Tooltip } from \"ui\";\n\nfunction HeatmapLegend({ legendOptions }) {\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const legend = PlotLib.legend(legendOptions);\n    containerRef.current?.appendChild(legend);\n    return () => {\n      containerRef.current?.removeChild(legend);\n    };\n  }, []);\n\n  return (\n    <Box position=\"relative\">\n      <Tooltip\n        showHelpIcon\n        title={\n          <>\n            See{\" \"}\n            <Link\n              external\n              to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g#explaining-l2g-predictions\"\n            >\n              here\n            </Link>{\" \"}\n            for more details.\n          </>\n        }\n      >\n        <Typography variant=\"subtitle2\" component=\"span\">\n          Feature contributions (Shapley)\n        </Typography>\n      </Tooltip>\n      <Box position=\"relative\" top=\"-12px\" ref={containerRef} />\n    </Box>\n  );\n}\n\nexport default HeatmapLegend;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/HeatmapTable/HeatmapLegend.tsx" },
        "span": [260, 269],
        "sourceCode": "import { Box, Typography } from \"@mui/material\";\nimport * as PlotLib from \"@observablehq/plot\";\nimport { useEffect, useRef } from \"react\";\nimport { Link, Tooltip } from \"ui\";\n\nfunction HeatmapLegend({ legendOptions }) {\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const legend = PlotLib.legend(legendOptions);\n    containerRef.current?.appendChild(legend);\n    return () => {\n      containerRef.current?.removeChild(legend);\n    };\n  }, []);\n\n  return (\n    <Box position=\"relative\">\n      <Tooltip\n        showHelpIcon\n        title={\n          <>\n            See{\" \"}\n            <Link\n              external\n              to=\"https://platform-docs.opentargets.org/gentropy/locus-to-gene-l2g#explaining-l2g-predictions\"\n            >\n              here\n            </Link>{\" \"}\n            for more details.\n          </>\n        }\n      >\n        <Typography variant=\"subtitle2\" component=\"span\">\n          Feature contributions (Shapley)\n        </Typography>\n      </Tooltip>\n      <Box position=\"relative\" top=\"-12px\" ref={containerRef} />\n    </Box>\n  );\n}\n\nexport default HeatmapLegend;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/noUnreachable",
      "severity": "error",
      "description": "This code is unreachable",
      "message": [{ "elements": [], "content": "This code will never be reached ..." }],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "... because this statement will throw an exception beforehand"
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1379, 1420],
              "sourceCode": "import { type Action, ActionType, type OtTableSSPState } from \"../types/tableTypes\";\nimport { getLoadingRows } from \"../utils/tableUtils\";\n\nexport const initialState: OtTableSSPState = {\n  count: 0,\n  loading: true,\n  rows: getLoadingRows(10),\n  cursor: null,\n  freeTextQuery: \"\",\n  initialLoading: true,\n};\n\nexport function createInitialState(_str: string): OtTableSSPState {\n  return initialState;\n}\n\nexport function otTableReducer(state: OtTableSSPState, action: Action): OtTableSSPState {\n  if (typeof state === \"undefined\") {\n    throw Error(\"State provided to table reducer is undefined\");\n  }\n  switch (action.type) {\n    case ActionType.SET_LOADING: {\n      return {\n        ...state,\n        loading: action.loading,\n      };\n    }\n    case ActionType.TEXT_SEARCH: {\n      return {\n        ...state,\n        loading: true,\n        freeTextQuery: action.freeQueryText,\n        cursor: null,\n      };\n    }\n    case ActionType.SET_DATA: {\n      return {\n        ...state,\n        initialLoading: false,\n        loading: false,\n        count: action.payload.count,\n        cursor: action.payload.cursor,\n        rows: action.payload.rows,\n      };\n    }\n    case ActionType.ADD_DATA: {\n      return {\n        ...state,\n        loading: false,\n        cursor: action.payload.cursor,\n        rows: [...state.rows, ...action.payload.rows],\n      };\n    }\n    default: {\n      throw Error(`Unknown action: ${action}`);\n      return state;\n    }\n  }\n}\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/context/otTableReducer.ts" },
        "span": [1427, 1440],
        "sourceCode": "import { type Action, ActionType, type OtTableSSPState } from \"../types/tableTypes\";\nimport { getLoadingRows } from \"../utils/tableUtils\";\n\nexport const initialState: OtTableSSPState = {\n  count: 0,\n  loading: true,\n  rows: getLoadingRows(10),\n  cursor: null,\n  freeTextQuery: \"\",\n  initialLoading: true,\n};\n\nexport function createInitialState(_str: string): OtTableSSPState {\n  return initialState;\n}\n\nexport function otTableReducer(state: OtTableSSPState, action: Action): OtTableSSPState {\n  if (typeof state === \"undefined\") {\n    throw Error(\"State provided to table reducer is undefined\");\n  }\n  switch (action.type) {\n    case ActionType.SET_LOADING: {\n      return {\n        ...state,\n        loading: action.loading,\n      };\n    }\n    case ActionType.TEXT_SEARCH: {\n      return {\n        ...state,\n        loading: true,\n        freeTextQuery: action.freeQueryText,\n        cursor: null,\n      };\n    }\n    case ActionType.SET_DATA: {\n      return {\n        ...state,\n        initialLoading: false,\n        loading: false,\n        count: action.payload.count,\n        cursor: action.payload.cursor,\n        rows: action.payload.rows,\n      };\n    }\n    case ActionType.ADD_DATA: {\n      return {\n        ...state,\n        loading: false,\n        cursor: action.payload.cursor,\n        rows: [...state.rows, ...action.payload.rows],\n      };\n    }\n    default: {\n      throw Error(`Unknown action: ${action}`);\n      return state;\n    }\n  }\n}\n"
      },
      "tags": ["unnecessaryCode"],
      "source": null
    },
    {
      "category": "lint/a11y/useKeyWithClickEvents",
      "severity": "error",
      "description": "Enforce to have the onClick mouse event with the onKeyUp, the onKeyDown, or the onKeyPress keyboard event.",
      "message": [
        { "elements": [], "content": "Enforce to have the " },
        { "elements": ["Emphasis"], "content": "onClick" },
        { "elements": [], "content": " mouse event with the " },
        { "elements": ["Emphasis"], "content": "onKeyUp" },
        { "elements": [], "content": ", the " },
        { "elements": ["Emphasis"], "content": "onKeyDown" },
        { "elements": [], "content": ", or the " },
        { "elements": ["Emphasis"], "content": "onKeyPress" },
        { "elements": [], "content": " keyboard event." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Highlights.tsx" },
        "span": [1191, 1265],
        "sourceCode": "import { type Theme, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { type ReactNode, useState } from \"react\";\n\nconst useStyles = makeStyles((theme: Theme) => ({\n  showMore: {\n    cursor: \"pointer\",\n    color: theme.palette.primary.main,\n  },\n  matches: {\n    marginTop: \"4px\",\n  },\n}));\n\ntype HighlightItem = string | TrustedHTML;\n\ntype HighlightsProps = {\n  highlights: HighlightItem[];\n};\n\nfunction Highlights({ highlights }: HighlightsProps): ReactNode {\n  const classes = useStyles();\n  const [showMore, setShowMore] = useState(false);\n\n  if (highlights.length === 0) return null;\n\n  return (\n    <div className={classes.matches}>\n      <Typography component=\"span\" display=\"inline\" variant=\"subtitle2\">\n        Matches:\n      </Typography>{\" \"}\n      <Typography\n        display=\"inline\"\n        variant=\"caption\"\n        className=\"highlights\"\n        dangerouslySetInnerHTML={{\n          __html: showMore ? highlights.join('<span class=\"separator\"> | </span>') : highlights[0],\n        }}\n      />\n      {highlights.length > 1 && (\n        <>\n          {\" \"}\n          <Typography variant=\"body2\" display=\"inline\">\n            [{\" \"}\n            <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n              {showMore ? \"hide\" : \"more\"}\n            </span>{\" \"}\n            ]\n          </Typography>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default Highlights;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/security/noDangerouslySetInnerHtml",
      "severity": "error",
      "description": "Avoid passing content using the dangerouslySetInnerHTML prop.",
      "message": [
        { "elements": [], "content": "Avoid passing content using the " },
        { "elements": ["Emphasis"], "content": "dangerouslySetInnerHTML" },
        { "elements": [], "content": " prop." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "warn",
              [
                {
                  "elements": [],
                  "content": "Setting content using code can expose users to cross-site scripting (XSS) attacks"
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/Highlights.tsx" },
        "span": [896, 919],
        "sourceCode": "import { type Theme, Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { type ReactNode, useState } from \"react\";\n\nconst useStyles = makeStyles((theme: Theme) => ({\n  showMore: {\n    cursor: \"pointer\",\n    color: theme.palette.primary.main,\n  },\n  matches: {\n    marginTop: \"4px\",\n  },\n}));\n\ntype HighlightItem = string | TrustedHTML;\n\ntype HighlightsProps = {\n  highlights: HighlightItem[];\n};\n\nfunction Highlights({ highlights }: HighlightsProps): ReactNode {\n  const classes = useStyles();\n  const [showMore, setShowMore] = useState(false);\n\n  if (highlights.length === 0) return null;\n\n  return (\n    <div className={classes.matches}>\n      <Typography component=\"span\" display=\"inline\" variant=\"subtitle2\">\n        Matches:\n      </Typography>{\" \"}\n      <Typography\n        display=\"inline\"\n        variant=\"caption\"\n        className=\"highlights\"\n        dangerouslySetInnerHTML={{\n          __html: showMore ? highlights.join('<span class=\"separator\"> | </span>') : highlights[0],\n        }}\n      />\n      {highlights.length > 1 && (\n        <>\n          {\" \"}\n          <Typography variant=\"body2\" display=\"inline\">\n            [{\" \"}\n            <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n              {showMore ? \"hide\" : \"more\"}\n            </span>{\" \"}\n            ]\n          </Typography>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default Highlights;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/HeatmapTable/helpers.ts" },
        "span": [2081, 2091],
        "sourceCode": "import { extent, interpolateRgbBasis, mean, scaleDiverging, scaleLinear } from \"d3\";\nimport { DIVERGING_COLORS, featureToGroup, groupNames } from \"./constants\";\n\nexport function getGroupResults(data) {\n  const rows = data.map((d) => {\n    const row = {\n      targetId: d.target.id,\n      targetSymbol: d.target.approvedSymbol,\n      shapBaseValue: d.shapBaseValue,\n      score: d.score,\n    };\n    for (const groupName of groupNames) {\n      row[groupName] = 0;\n    }\n    for (const feature of d.features) {\n      const groupName = featureToGroup[feature.name];\n      if (groupName) {\n        row[groupName] += feature.shapValue;\n      } else {\n        console.warn(`feature ${feature.name} does not belong to any group`);\n      }\n    }\n    return row;\n  });\n  rows.sort((a, b) => b.score - a.score);\n  return rows;\n}\n\nexport function computeWaterfall(originalRow, fullXDomain, zeroBase) {\n  const row = structuredClone(originalRow);\n  const { features } = row;\n  features.sort((a, b) => Math.abs(a.shapValue) - Math.abs(b.shapValue));\n  for (const [index, feature] of features.entries()) {\n    feature._start = features[index - 1]?._end ?? (zeroBase ? 0 : row.shapBaseValue);\n    feature._end = feature._start + feature.shapValue;\n  }\n  const xExtent = extent(features.flatMap((d) => [d._start, d._end]));\n  if (fullXDomain) {\n    const relativeSize = (xExtent[1] - xExtent[0]) / (fullXDomain[1] - fullXDomain[0]);\n    if (relativeSize < 0.25) {\n      const middle = mean(xExtent);\n      const stretch = 0.25 / relativeSize;\n      xExtent[0] = middle + (xExtent[0] - middle) * stretch;\n      xExtent[1] = middle + (xExtent[1] - middle) * stretch;\n    }\n  }\n  const xDomain = scaleLinear().domain(xExtent).nice().domain();\n  return { row, xDomain };\n}\n\nexport function getColorInterpolator(groupResults) {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  for (const row of groupResults) {\n    for (const groupName of groupNames) {\n      min = Math.min(min, row[groupName]);\n      max = Math.max(max, row[groupName]);\n    }\n  }\n  Math.abs(min) > max ? (max = -min) : (min = -max);\n  return scaleDiverging().domain([min, 0, max]).interpolator(interpolateRgbBasis(DIVERGING_COLORS));\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noAssignInExpressions",
      "severity": "error",
      "description": "The assignment should not be in an expression.",
      "message": [
        { "elements": [], "content": "The " },
        { "elements": ["Emphasis"], "content": "assignment" },
        { "elements": [], "content": " should not be in an " },
        { "elements": ["Emphasis"], "content": "expression" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The use of assignments in expressions is confusing.\nExpressions are often considered as side-effect free."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/HeatmapTable/helpers.ts" },
        "span": [2096, 2106],
        "sourceCode": "import { extent, interpolateRgbBasis, mean, scaleDiverging, scaleLinear } from \"d3\";\nimport { DIVERGING_COLORS, featureToGroup, groupNames } from \"./constants\";\n\nexport function getGroupResults(data) {\n  const rows = data.map((d) => {\n    const row = {\n      targetId: d.target.id,\n      targetSymbol: d.target.approvedSymbol,\n      shapBaseValue: d.shapBaseValue,\n      score: d.score,\n    };\n    for (const groupName of groupNames) {\n      row[groupName] = 0;\n    }\n    for (const feature of d.features) {\n      const groupName = featureToGroup[feature.name];\n      if (groupName) {\n        row[groupName] += feature.shapValue;\n      } else {\n        console.warn(`feature ${feature.name} does not belong to any group`);\n      }\n    }\n    return row;\n  });\n  rows.sort((a, b) => b.score - a.score);\n  return rows;\n}\n\nexport function computeWaterfall(originalRow, fullXDomain, zeroBase) {\n  const row = structuredClone(originalRow);\n  const { features } = row;\n  features.sort((a, b) => Math.abs(a.shapValue) - Math.abs(b.shapValue));\n  for (const [index, feature] of features.entries()) {\n    feature._start = features[index - 1]?._end ?? (zeroBase ? 0 : row.shapBaseValue);\n    feature._end = feature._start + feature.shapValue;\n  }\n  const xExtent = extent(features.flatMap((d) => [d._start, d._end]));\n  if (fullXDomain) {\n    const relativeSize = (xExtent[1] - xExtent[0]) / (fullXDomain[1] - fullXDomain[0]);\n    if (relativeSize < 0.25) {\n      const middle = mean(xExtent);\n      const stretch = 0.25 / relativeSize;\n      xExtent[0] = middle + (xExtent[0] - middle) * stretch;\n      xExtent[1] = middle + (xExtent[1] - middle) * stretch;\n    }\n  }\n  const xDomain = scaleLinear().domain(xExtent).nice().domain();\n  return { row, xDomain };\n}\n\nexport function getColorInterpolator(groupResults) {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  for (const row of groupResults) {\n    for (const groupName of groupNames) {\n      min = Math.min(min, row[groupName]);\n      max = Math.max(max, row[groupName]);\n    }\n  }\n  Math.abs(min) > max ? (max = -min) : (min = -max);\n  return scaleDiverging().domain([min, 0, max]).interpolator(interpolateRgbBasis(DIVERGING_COLORS));\n}\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: setGlobalSearchTerm",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: setGlobalSearchTerm"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [811, 830],
              "sourceCode": "import { faMagnifyingGlass } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Input, InputAdornment } from \"@mui/material\";\nimport { type ReactElement, useEffect, useState } from \"react\";\nimport useDebounce from \"../../hooks/useDebounce\";\nimport type { OtTableSearchProps } from \"./table.types\";\n\n/****************************************\n *      OT TABLE SEARCH COMPONENT       *\n * REDUCE RERENDER, ACCEPTS SETSTATE FN *\n *         SET DEBOUNCED VALUE          *\n ****************************************/\n\nfunction OtTableSearch({ setGlobalSearchTerm }: OtTableSearchProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n\n  const debouncedTableSearchValue = useDebounce(globalFilter, 300);\n\n  useEffect(() => {\n    setGlobalSearchTerm(debouncedTableSearchValue);\n  }, [debouncedTableSearchValue]);\n\n  return (\n    <Input\n      sx={{ width: 1 }}\n      value={globalFilter ?? \"\"}\n      onChange={(e) => setGlobalFilter(e.target.value)}\n      placeholder=\"Search all columns...\"\n      startAdornment={\n        <InputAdornment position=\"start\">\n          <FontAwesomeIcon icon={faMagnifyingGlass} />\n        </InputAdornment>\n      }\n    />\n  );\n}\nexport default OtTableSearch;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSearch.tsx" },
        "span": [789, 798],
        "sourceCode": "import { faMagnifyingGlass } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Input, InputAdornment } from \"@mui/material\";\nimport { type ReactElement, useEffect, useState } from \"react\";\nimport useDebounce from \"../../hooks/useDebounce\";\nimport type { OtTableSearchProps } from \"./table.types\";\n\n/****************************************\n *      OT TABLE SEARCH COMPONENT       *\n * REDUCE RERENDER, ACCEPTS SETSTATE FN *\n *         SET DEBOUNCED VALUE          *\n ****************************************/\n\nfunction OtTableSearch({ setGlobalSearchTerm }: OtTableSearchProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n\n  const debouncedTableSearchValue = useDebounce(globalFilter, 300);\n\n  useEffect(() => {\n    setGlobalSearchTerm(debouncedTableSearchValue);\n  }, [debouncedTableSearchValue]);\n\n  return (\n    <Input\n      sx={{ width: 1 }}\n      value={globalFilter ?? \"\"}\n      onChange={(e) => setGlobalFilter(e.target.value)}\n      placeholder=\"Search all columns...\"\n      startAdornment={\n        <InputAdornment position=\"start\">\n          <FontAwesomeIcon icon={faMagnifyingGlass} />\n        </InputAdornment>\n      }\n    />\n  );\n}\nexport default OtTableSearch;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/HeatmapTable/HeatmapTable.tsx" },
        "span": [5243, 5249],
        "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: filterProvied",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: filterProvied"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [10376, 10389],
              "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [10339, 10352],
              "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/HeatmapTable/HeatmapTable.tsx" },
        "span": [10296, 10307],
        "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: fixedGene",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: fixedGene"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [10464, 10473],
              "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/HeatmapTable/HeatmapTable.tsx" },
        "span": [10296, 10307],
        "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noArrayIndexKey",
      "severity": "error",
      "description": "Avoid using the index of an array as key property in an element.",
      "message": [
        {
          "elements": [],
          "content": "Avoid using the index of an array as key property in an element."
        }
      ],
      "advices": {
        "advices": [
          {
            "log": ["info", [{ "elements": [], "content": "This is the source of the key value." }]]
          },
          {
            "frame": {
              "path": null,
              "span": [12806, 12811],
              "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "The order of the items may change, and this also affects performances and component state."
                }
              ]
            ]
          },
          {
            "log": [
              "info",
              [
                { "elements": [], "content": "Check the " },
                {
                  "elements": [
                    { "Hyperlink": { "href": "https://reactjs.org/docs/lists-and-keys.html#keys" } }
                  ],
                  "content": "React documentation"
                },
                { "elements": [], "content": ". " }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/HeatmapTable/HeatmapTable.tsx" },
        "span": [12865, 12870],
        "sourceCode": "import { faArrowDownWideShort, faChevronRight, faXmark } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Box, Checkbox, Dialog, FormControlLabel, Popover, Typography } from \"@mui/material\";\nimport { grey } from \"@mui/material/colors\";\nimport { hsl, scaleLinear } from \"d3\";\nimport { useCallback, useState } from \"react\";\nimport { DataDownloader, Link, ObsPlot } from \"../../index\";\nimport HeatmapLegend from \"./HeatmapLegend\";\nimport {\n  featureToGroup,\n  groupNames,\n  waterfallMargins,\n  waterfallMaxCanvasWidth,\n  waterfallMaxWidth,\n} from \"./constants\";\nimport { computeWaterfall, getColorInterpolator, getGroupResults } from \"./helpers\";\nimport { renderWaterfallPlot } from \"./renderWaterfallPlot\";\n\nfunction THead({ children }) {\n  return (\n    <thead>\n      <Box component=\"tr\">\n        <th />\n        <th />\n        <th />\n        <th />\n        <Box\n          component=\"th\"\n          colSpan=\"3\"\n          sx={{ borderBottom: `1px solid ${grey[600]}`, paddingBottom: 1 }}\n        >\n          <Typography variant=\"subtitle2\">Colocalisation</Typography>\n        </Box>\n        <th />\n        <th />\n        <th />\n      </Box>\n      <tr>{children}</tr>\n    </thead>\n  );\n}\n\nfunction TBody({ children }) {\n  return <tbody>{children}</tbody>;\n}\n\nfunction BodyRow({ row, colorInterpolator, data }) {\n  const [over, setOver] = useState(false);\n\n  const { row: waterfallRow, xDomain: waterfallXDomain } = computeWaterfall(\n    data.rows.find((d) => d.target.id === row.targetId)\n  );\n\n  function handleMouseEnter(_event) {\n    setOver(true);\n  }\n\n  function handleMouseLeave(_event) {\n    setOver(false);\n  }\n\n  const cellWrapperProps = {\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n  };\n\n  return (\n    <Box\n      component=\"tr\"\n      sx={{\n        \"& td\": {\n          bgcolor: over ? grey[100] : \"transparent\",\n        },\n      }}\n    >\n      <CellWrapper {...cellWrapperProps}>\n        <GeneCell value={row.targetSymbol} targetId={row.targetId} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <ScoreCell value={row.score.toFixed(3)} />\n      </CellWrapper>\n      {groupNames.map((groupName) => (\n        <CellWrapper key={groupName} {...cellWrapperProps}>\n          <HeatCell\n            value={row[groupName]?.toFixed(3)}\n            groupName={groupName}\n            bgrd={colorInterpolator(row[groupName])}\n            mouseLeaveRow={handleMouseLeave}\n            waterfallRow={waterfallRow}\n            waterfallXDomain={waterfallXDomain}\n          />\n        </CellWrapper>\n      ))}\n      <CellWrapper {...cellWrapperProps}>\n        <BaseCell value={row.shapBaseValue.toFixed(3)} />\n      </CellWrapper>\n      <CellWrapper {...cellWrapperProps}>\n        <DetailCell\n          geneSymbol={row.targetSymbol}\n          score={row.score.toFixed(3)}\n          mouseLeaveRow={handleMouseLeave}\n          waterfallRow={waterfallRow}\n          waterfallXDomain={waterfallXDomain}\n          over={over}\n        />\n      </CellWrapper>\n    </Box>\n  );\n}\n\nfunction CellWrapper({ handleMouseEnter, handleMouseLeave, children }) {\n  return (\n    <Box component=\"td\" onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave} p={0.5}>\n      {children}\n    </Box>\n  );\n}\n\nfunction HeaderCell({ value, textAlign }) {\n  return (\n    <Box component=\"th\" pt={1}>\n      <Typography variant=\"subtitle2\" textAlign={textAlign}>\n        {value}{\" \"}\n        {value === \"Score\" && (\n          <span style={{ color: grey[500] }}>\n            <FontAwesomeIcon size=\"sm\" icon={faArrowDownWideShort} />\n          </span>\n        )}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction GeneCell({ value, targetId }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"end\">\n      <Link asyncTooltip to={`/target/${targetId}`}>\n        <Typography variant=\"body2\">{value}</Typography>\n      </Link>\n    </Box>\n  );\n}\n\nfunction ScoreCell({ value }) {\n  return (\n    <Box display=\"flex\" justifyContent=\"center\" borderRadius={1.5}>\n      <Typography variant=\"body2\" sx={{ pointerEvents: \"none\" }}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction HeatCell({ value, bgrd, groupName, mouseLeaveRow, waterfallRow, waterfallXDomain }) {\n  const [anchorEl, setAnchorEl] = useState(null);\n  const [plotProps, setPlotProps] = useState(null);\n\n  const open = Boolean(anchorEl);\n  const id = open ? \"plot-popover\" : undefined;\n\n  function handleClick(event) {\n    const filteredWaterfallRow = structuredClone(waterfallRow);\n    filteredWaterfallRow.features = filteredWaterfallRow.features.filter((d) => {\n      return featureToGroup[d.name] === groupName;\n    });\n    let { row, xDomain } = computeWaterfall(filteredWaterfallRow, waterfallXDomain, true);\n    if (xDomain.some(Number.isNaN)) {\n      // all Shapley values are zero\n      const fullExtent = waterfallXDomain[1] - waterfallXDomain[0];\n      xDomain = scaleLinear()\n        .domain([-fullExtent / 8, fullExtent / 8])\n        .nice()\n        .domain();\n    }\n    const plotWidth =\n      waterfallMargins.left +\n      waterfallMargins.right +\n      (waterfallMaxCanvasWidth * (xDomain[1] - xDomain[0])) /\n        (waterfallXDomain[1] - waterfallXDomain[0]);\n    let xTicks;\n    const xRange = xDomain[1] - xDomain[0];\n    if (xDomain.includes(0)) xTicks = xDomain;\n    else if (Math.abs(xDomain[0]) < xRange / 4) xTicks = [0, xDomain[1]];\n    else if (Math.abs(xDomain[1]) < xRange / 4) xTicks = [xDomain[0], 0];\n    else xTicks = [...xDomain, 0];\n    setPlotProps({\n      data: row,\n      otherData: { margins: waterfallMargins, xDomain, xTicks },\n      minWidth: plotWidth,\n      maxWidth: plotWidth,\n      renderChart: renderWaterfallPlot,\n    });\n    setAnchorEl(event.currentTarget);\n  }\n\n  function handleClose(_event) {\n    setAnchorEl(null);\n    setPlotProps(null);\n    mouseLeaveRow();\n  }\n\n  return (\n    <>\n      <Box\n        aria-describedby={id}\n        bgcolor={bgrd}\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        py={1.4}\n        onClick={handleClick}\n        sx={{\n          outline: anchorEl ? \"2px solid #000\" : \"none\",\n          \"&:hover\": {\n            outline: `2px solid ${grey[600]}`,\n            cursor: \"pointer\",\n          },\n        }}\n      >\n        <Typography\n          fontSize={13.5}\n          sx={{\n            color: hsl(bgrd).l < 0.6 ? \"#fff\" : \"#000\",\n            pointerEvents: \"none\",\n          }}\n        >\n          {value}\n        </Typography>\n      </Box>\n      <Popover\n        id={id}\n        open={open}\n        anchorEl={anchorEl}\n        onClose={handleClose}\n        elevation={1}\n        disableScrollLock\n        transitionDuration={0}\n        anchorOrigin={{\n          vertical: \"bottom\",\n          horizontal: \"left\",\n        }}\n        transformOrigin={{\n          vertical: \"top\",\n          horizontal: \"left\",\n        }}\n        sx={{\n          mt: 0.5,\n        }}\n      >\n        <ClosePlot handleClose={handleClose} />\n        <Box sx={{ px: 3, pt: 3.5, pb: 2 }}>\n          <ObsPlot {...plotProps} />\n        </Box>\n      </Popover>\n    </>\n  );\n}\n\nfunction BaseCell({ value }) {\n  return (\n    <Box\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      borderRadius={1.5}\n      py={1.4}\n      outline={`1px solid ${grey[400]}`}\n    >\n      <Typography fontSize={13.5} color={grey[500]}>\n        {value}\n      </Typography>\n    </Box>\n  );\n}\n\nfunction DetailCell({ geneSymbol, score, mouseLeaveRow, waterfallRow, waterfallXDomain, over }) {\n  const [open, setOpen] = useState(false);\n\n  const handleClickOpen = () => {\n    setOpen(true);\n  };\n\n  const handleClose = () => {\n    setOpen(false);\n    mouseLeaveRow();\n  };\n\n  return (\n    <>\n      <Box\n        display=\"flex\"\n        justifyContent=\"center\"\n        alignItems=\"center\"\n        borderRadius={1.5}\n        sx={{ opacity: over ? 1 : 0, transition: \"all ease 100ms\" }}\n      >\n        <Box\n          sx={{\n            cursor: \"pointer\",\n            display: \"flex\",\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            gap: 1,\n            padding: 1,\n            borderRadius: \"0.4em\",\n            \"&:hover\": {\n              backgroundColor: \"#fff\",\n            },\n          }}\n          onClick={handleClickOpen}\n        >\n          <Typography variant=\"caption\">Details</Typography>\n          <FontAwesomeIcon size=\"sm\" icon={faChevronRight} />\n        </Box>\n      </Box>\n      <Dialog maxWidth=\"md\" open={open} onClose={handleClose}>\n        <ClosePlot handleClose={handleClose} />\n        <Box p={3}>\n          <Typography variant=\"h6\">\n            {geneSymbol},{\" \"}\n            <Box component=\"span\" fontSize=\"0.9em\">\n              score: {score}\n            </Box>\n          </Typography>\n          <ObsPlot\n            data={waterfallRow}\n            otherData={{ margins: waterfallMargins, xDomain: waterfallXDomain, labelBase: true }}\n            minWidth={waterfallMaxWidth}\n            maxWidth={waterfallMaxWidth}\n            renderChart={renderWaterfallPlot}\n          />\n        </Box>\n      </Dialog>\n    </>\n  );\n}\n\nfunction ClosePlot({ handleClose }) {\n  return (\n    <Box\n      onClick={handleClose}\n      width=\"36px\"\n      height=\"36px\"\n      position=\"absolute\"\n      top={0}\n      right={0}\n      display=\"flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      sx={{\n        \"&:hover\": {\n          bgcolor: grey[100],\n        },\n      }}\n    >\n      <FontAwesomeIcon icon={faXmark} />\n    </Box>\n  );\n}\n\nfunction ChartControls({ rows, query, variables, columns }) {\n  return (\n    <Box\n      sx={{\n        borderColor: grey[300],\n        borderRadius: 1,\n        display: \"flex\",\n        justifyContent: \"flex-end\",\n        gap: 1,\n        mb: 2,\n      }}\n    >\n      <DataDownloader\n        btnLabel=\"Export\"\n        rows={rows}\n        query={query}\n        variables={variables}\n        columns={columns}\n      />\n    </Box>\n  );\n}\n\nfunction HeatmapTable({\n  query,\n  data,\n  variables,\n  loading,\n  fixedGene,\n  disabledExport = false,\n  disabledLegend = false,\n}) {\n  const filterProvied = !!fixedGene;\n  const [showAll, setShowAll] = useState(!filterProvied);\n  const [defaultChecked] = useState(true);\n\n  const getVisData = useCallback(\n    ({ all }) => {\n      if (!filterProvied) return all;\n      if (filterProvied && showAll) return all;\n      return all.filter((row) => row.targetId === fixedGene);\n    },\n    [showAll]\n  );\n\n  if (loading) return <></>;\n\n  const groupResults = getGroupResults(data.rows);\n  const colorInterpolator = getColorInterpolator(groupResults);\n  const twoElementDomain = [colorInterpolator.domain()[0], colorInterpolator.domain()[2]];\n\n  const rows = getVisData({ all: groupResults });\n\n  const columns = [\n    { id: \"targetSymbol\", label: \"gene\" },\n    { id: \"score\" },\n    { id: \"Distance\" },\n    { id: \"VEP\" },\n    { id: \"eQTL\" },\n    { id: \"pQTL\" },\n    { id: \"sQTL\" },\n    { id: \"Other\" },\n    { id: \"shapBaseValue\", label: \"base\" },\n  ];\n\n  return (\n    <>\n      {filterProvied && (\n        <Box sx={{ display: \"flex\", justifyContent: \"flex-end\", mt: 1, mr: 1 }}>\n          <FormControlLabel\n            control={\n              <Checkbox\n                title=\"All\"\n                checked={groupResults.length === 1 ? defaultChecked : showAll}\n                disabled={groupResults.length === 1 ? defaultChecked : false}\n                onChange={() => {\n                  setShowAll(!showAll);\n                }}\n              />\n            }\n            label={\n              <Typography variant=\"body2\">\n                {groupResults.length === 1 ? \"Showing\" : \"Show\"} all prioritised targets in credible\n                set\n              </Typography>\n            }\n          />\n        </Box>\n      )}\n      {!disabledExport && (\n        <ChartControls query={query} rows={rows} variables={variables} columns={columns} />\n      )}\n      <Box display=\"flex\" justifyContent=\"center\">\n        <Box\n          component=\"table\"\n          sx={{\n            tableLayout: \"fixed\",\n            width: \"90%\",\n            maxWidth: \"1000px\",\n            borderCollapse: \"collapse\",\n            my: 4,\n          }}\n        >\n          {!disabledLegend && (\n            <Box component=\"caption\" sx={{ mt: 3, captionSide: \"bottom\", textAlign: \"left\" }}>\n              <HeatmapLegend\n                legendOptions={{\n                  color: {\n                    type: \"diverging\",\n                    interpolate: colorInterpolator,\n                    domain: twoElementDomain,\n                    range: twoElementDomain,\n                  },\n                }}\n              />\n            </Box>\n          )}\n          <THead>\n            {[\"Gene\", \"Score\", ...groupNames, \"Base\", \"\"].map((value, index) => (\n              <HeaderCell\n                key={index}\n                value={value}\n                textAlign={value === \"Gene\" ? \"right\" : \"center\"}\n              />\n            ))}\n          </THead>\n          <TBody>\n            {rows.map((row) => (\n              <BodyRow\n                data={data}\n                key={row.targetId}\n                row={row}\n                colorInterpolator={colorInterpolator}\n              />\n            ))}\n          </TBody>\n        </Box>\n      </Box>\n    </>\n  );\n}\n\nexport default HeatmapTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/a11y/useKeyWithClickEvents",
      "severity": "error",
      "description": "Enforce to have the onClick mouse event with the onKeyUp, the onKeyDown, or the onKeyPress keyboard event.",
      "message": [
        { "elements": [], "content": "Enforce to have the " },
        { "elements": ["Emphasis"], "content": "onClick" },
        { "elements": [], "content": " mouse event with the " },
        { "elements": ["Emphasis"], "content": "onKeyUp" },
        { "elements": [], "content": ", the " },
        { "elements": ["Emphasis"], "content": "onKeyDown" },
        { "elements": [], "content": ", or the " },
        { "elements": ["Emphasis"], "content": "onKeyPress" },
        { "elements": [], "content": " keyboard event." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Actions triggered using mouse events should have corresponding keyboard events to account for keyboard-only navigation."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/LongText.tsx" },
        "span": [1737, 1811],
        "sourceCode": "import { Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { type PropsWithChildren, useLayoutEffect, useRef, useState } from \"react\";\n\nconst useStyles = makeStyles((theme) => ({\n  textContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    overflow: \"hidden\",\n  },\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n}));\n\ntype LongTextProps = {\n  lineLimit: number;\n  variant: string;\n};\n\nconst LongText = ({ lineLimit, variant = \"body2\", children }: PropsWithChildren<LongTextProps>) => {\n  const classes = useStyles();\n  const containerRef = useRef<HTMLInputElement>(null);\n  const textRef = useRef<HTMLInputElement>(null);\n  const [showMore, setShowMore] = useState(false);\n  const [numberOfLines, setNumberOfLines] = useState<number | null>();\n\n  useLayoutEffect(() => {\n    const container = containerRef.current;\n    const el = textRef.current;\n    if (!el || !container) return;\n    const height = el.offsetHeight;\n    const DOMLineHeight = document.defaultView\n      ? document.defaultView.getComputedStyle(el, null).getPropertyValue(\"line-height\")\n      : \"\";\n    const lineHeight = Number.parseInt(DOMLineHeight);\n    const numberOfLines = Math.round(height / lineHeight);\n    container.style.height =\n      numberOfLines <= lineLimit ? \"auto\" : showMore ? \"auto\" : `${lineLimit * lineHeight}px`;\n\n    setNumberOfLines(numberOfLines);\n  }, [lineLimit, showMore, children]);\n\n  return (\n    <Typography variant={variant}>\n      <span ref={containerRef} className={classes.textContainer}>\n        <span ref={textRef}>{children}</span>\n      </span>\n      {numberOfLines > lineLimit && (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      )}\n    </Typography>\n  );\n};\n\nexport default LongText;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: children",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: children"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Outer scope values aren't valid dependencies because mutating them doesn't re-render the component."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1448, 1456],
              "sourceCode": "import { Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { type PropsWithChildren, useLayoutEffect, useRef, useState } from \"react\";\n\nconst useStyles = makeStyles((theme) => ({\n  textContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    overflow: \"hidden\",\n  },\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n}));\n\ntype LongTextProps = {\n  lineLimit: number;\n  variant: string;\n};\n\nconst LongText = ({ lineLimit, variant = \"body2\", children }: PropsWithChildren<LongTextProps>) => {\n  const classes = useStyles();\n  const containerRef = useRef<HTMLInputElement>(null);\n  const textRef = useRef<HTMLInputElement>(null);\n  const [showMore, setShowMore] = useState(false);\n  const [numberOfLines, setNumberOfLines] = useState<number | null>();\n\n  useLayoutEffect(() => {\n    const container = containerRef.current;\n    const el = textRef.current;\n    if (!el || !container) return;\n    const height = el.offsetHeight;\n    const DOMLineHeight = document.defaultView\n      ? document.defaultView.getComputedStyle(el, null).getPropertyValue(\"line-height\")\n      : \"\";\n    const lineHeight = Number.parseInt(DOMLineHeight);\n    const numberOfLines = Math.round(height / lineHeight);\n    container.style.height =\n      numberOfLines <= lineLimit ? \"auto\" : showMore ? \"auto\" : `${lineLimit * lineHeight}px`;\n\n    setNumberOfLines(numberOfLines);\n  }, [lineLimit, showMore, children]);\n\n  return (\n    <Typography variant={variant}>\n      <span ref={containerRef} className={classes.textContainer}>\n        <span ref={textRef}>{children}</span>\n      </span>\n      {numberOfLines > lineLimit && (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      )}\n    </Typography>\n  );\n};\n\nexport default LongText;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/LongText.tsx" },
        "span": [827, 842],
        "sourceCode": "import { Typography } from \"@mui/material\";\nimport { makeStyles } from \"@mui/styles\";\nimport { type PropsWithChildren, useLayoutEffect, useRef, useState } from \"react\";\n\nconst useStyles = makeStyles((theme) => ({\n  textContainer: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    overflow: \"hidden\",\n  },\n  showMore: {\n    color: theme.palette.primary.main,\n    cursor: \"pointer\",\n  },\n}));\n\ntype LongTextProps = {\n  lineLimit: number;\n  variant: string;\n};\n\nconst LongText = ({ lineLimit, variant = \"body2\", children }: PropsWithChildren<LongTextProps>) => {\n  const classes = useStyles();\n  const containerRef = useRef<HTMLInputElement>(null);\n  const textRef = useRef<HTMLInputElement>(null);\n  const [showMore, setShowMore] = useState(false);\n  const [numberOfLines, setNumberOfLines] = useState<number | null>();\n\n  useLayoutEffect(() => {\n    const container = containerRef.current;\n    const el = textRef.current;\n    if (!el || !container) return;\n    const height = el.offsetHeight;\n    const DOMLineHeight = document.defaultView\n      ? document.defaultView.getComputedStyle(el, null).getPropertyValue(\"line-height\")\n      : \"\";\n    const lineHeight = Number.parseInt(DOMLineHeight);\n    const numberOfLines = Math.round(height / lineHeight);\n    container.style.height =\n      numberOfLines <= lineLimit ? \"auto\" : showMore ? \"auto\" : `${lineLimit * lineHeight}px`;\n\n    setNumberOfLines(numberOfLines);\n  }, [lineLimit, showMore, children]);\n\n  return (\n    <Typography variant={variant}>\n      <span ref={containerRef} className={classes.textContainer}>\n        <span ref={textRef}>{children}</span>\n      </span>\n      {numberOfLines > lineLimit && (\n        <span>\n          {showMore ? \"\" : \"... \"}[{\" \"}\n          <span className={classes.showMore} onClick={() => setShowMore(!showMore)}>\n            {showMore ? \" hide\" : \" show more\"}\n          </span>{\" \"}\n          ]\n        </span>\n      )}\n    </Typography>\n  );\n};\n\nexport default LongText;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsChart.tsx" },
        "span": [1325, 1338],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { type Dispatch, type SetStateAction, useEffect, useRef } from \"react\";\n\ntype ObsChartProps = {\n  data: any;\n  otherData?: any;\n  width: number;\n  height: number;\n  renderChart: (params: {\n    data: any;\n    otherData?: any;\n    width: number;\n    height: number;\n  }) => SVGSVGElement;\n  hasTooltip: boolean;\n  fadeElement?: (elmt: SVGElement) => void;\n  highlightElement?: (elmt: SVGElement) => void;\n  resetElement?: (elmt: SVGElement) => void;\n  setChart: Dispatch<SetStateAction<SVGSVGElement>>;\n  setDatum: Dispatch<SetStateAction<any>>;\n  renderSVGOverlay: (chart: SVGSVGElement) => SVGElement | null;\n};\n\nfunction ObsChart({\n  data,\n  otherData,\n  width,\n  height,\n  renderChart,\n  hasTooltip,\n  fadeElement,\n  highlightElement,\n  resetElement,\n  setChart,\n  setDatum,\n  renderSVGOverlay,\n}: ObsChartProps) {\n  const headerRef = useRef();\n\n  useEffect(() => {\n    if (data === undefined || width === null) return;\n    const chart = renderChart({ data, otherData, width, height });\n    setChart(chart);\n\n    if (renderSVGOverlay) {\n      const overlay = renderSVGOverlay(chart);\n      if (overlay == null) return;\n      if (Array.isArray(overlay)) chart.append(...overlay);\n      else chart.append(overlay);\n    }\n\n    if (hasTooltip) {\n      let clicked = false;\n      let selectedDatum;\n      const tooltipMarks = chart.querySelectorAll(\".obs-tooltip *\");\n      for (const elmt of tooltipMarks) {\n        const dataIndex = elmt.__data__;\n        const elmtDatum = data[dataIndex];\n        const highlightSelected = () => {\n          if (fadeElement) tooltipMarks.forEach(fadeElement);\n          // possibly multiple mark elements for same datum\n          if (highlightElement) {\n            chart.querySelectorAll(`[data-index=\"${dataIndex}\"]`).forEach(highlightElement);\n          }\n        };\n        elmt.setAttribute(\"data-index\", dataIndex);\n        elmt.addEventListener(\"click\", (event) => {\n          if (clicked && selectedDatum === elmtDatum) {\n            clicked = false;\n            selectedDatum = null;\n          } else {\n            clicked = true;\n            selectedDatum = elmtDatum;\n            highlightSelected();\n          }\n          setDatum(selectedDatum);\n          event.stopPropagation();\n        });\n        elmt.addEventListener(\"mouseenter\", () => {\n          if (!clicked) {\n            selectedDatum = elmtDatum;\n            setDatum(selectedDatum);\n            highlightSelected();\n          }\n        });\n        elmt.addEventListener(\"mouseleave\", () => {\n          if (!clicked) {\n            selectedDatum = null;\n            setDatum(selectedDatum);\n            if (resetElement) tooltipMarks.forEach(resetElement);\n          }\n        });\n      }\n\n      chart.addEventListener(\"click\", () => {\n        if (clicked) {\n          clicked = false;\n          selectedDatum = null;\n          setDatum(selectedDatum);\n          if (resetElement) tooltipMarks.forEach(resetElement);\n        }\n      });\n    }\n    headerRef.current.append(chart);\n    return () => {\n      setDatum(null);\n      chart.remove();\n    };\n  }, [\n    data,\n    otherData,\n    width,\n    height,\n    renderChart,\n    hasTooltip,\n    fadeElement,\n    highlightElement,\n    resetElement,\n    setChart,\n    setDatum,\n  ]);\n\n  return <Box ref={headerRef} />;\n}\n\nexport default ObsChart;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: renderSVGOverlay",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: renderSVGOverlay"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1063, 1079],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { type Dispatch, type SetStateAction, useEffect, useRef } from \"react\";\n\ntype ObsChartProps = {\n  data: any;\n  otherData?: any;\n  width: number;\n  height: number;\n  renderChart: (params: {\n    data: any;\n    otherData?: any;\n    width: number;\n    height: number;\n  }) => SVGSVGElement;\n  hasTooltip: boolean;\n  fadeElement?: (elmt: SVGElement) => void;\n  highlightElement?: (elmt: SVGElement) => void;\n  resetElement?: (elmt: SVGElement) => void;\n  setChart: Dispatch<SetStateAction<SVGSVGElement>>;\n  setDatum: Dispatch<SetStateAction<any>>;\n  renderSVGOverlay: (chart: SVGSVGElement) => SVGElement | null;\n};\n\nfunction ObsChart({\n  data,\n  otherData,\n  width,\n  height,\n  renderChart,\n  hasTooltip,\n  fadeElement,\n  highlightElement,\n  resetElement,\n  setChart,\n  setDatum,\n  renderSVGOverlay,\n}: ObsChartProps) {\n  const headerRef = useRef();\n\n  useEffect(() => {\n    if (data === undefined || width === null) return;\n    const chart = renderChart({ data, otherData, width, height });\n    setChart(chart);\n\n    if (renderSVGOverlay) {\n      const overlay = renderSVGOverlay(chart);\n      if (overlay == null) return;\n      if (Array.isArray(overlay)) chart.append(...overlay);\n      else chart.append(overlay);\n    }\n\n    if (hasTooltip) {\n      let clicked = false;\n      let selectedDatum;\n      const tooltipMarks = chart.querySelectorAll(\".obs-tooltip *\");\n      for (const elmt of tooltipMarks) {\n        const dataIndex = elmt.__data__;\n        const elmtDatum = data[dataIndex];\n        const highlightSelected = () => {\n          if (fadeElement) tooltipMarks.forEach(fadeElement);\n          // possibly multiple mark elements for same datum\n          if (highlightElement) {\n            chart.querySelectorAll(`[data-index=\"${dataIndex}\"]`).forEach(highlightElement);\n          }\n        };\n        elmt.setAttribute(\"data-index\", dataIndex);\n        elmt.addEventListener(\"click\", (event) => {\n          if (clicked && selectedDatum === elmtDatum) {\n            clicked = false;\n            selectedDatum = null;\n          } else {\n            clicked = true;\n            selectedDatum = elmtDatum;\n            highlightSelected();\n          }\n          setDatum(selectedDatum);\n          event.stopPropagation();\n        });\n        elmt.addEventListener(\"mouseenter\", () => {\n          if (!clicked) {\n            selectedDatum = elmtDatum;\n            setDatum(selectedDatum);\n            highlightSelected();\n          }\n        });\n        elmt.addEventListener(\"mouseleave\", () => {\n          if (!clicked) {\n            selectedDatum = null;\n            setDatum(selectedDatum);\n            if (resetElement) tooltipMarks.forEach(resetElement);\n          }\n        });\n      }\n\n      chart.addEventListener(\"click\", () => {\n        if (clicked) {\n          clicked = false;\n          selectedDatum = null;\n          setDatum(selectedDatum);\n          if (resetElement) tooltipMarks.forEach(resetElement);\n        }\n      });\n    }\n    headerRef.current.append(chart);\n    return () => {\n      setDatum(null);\n      chart.remove();\n    };\n  }, [\n    data,\n    otherData,\n    width,\n    height,\n    renderChart,\n    hasTooltip,\n    fadeElement,\n    highlightElement,\n    resetElement,\n    setChart,\n    setDatum,\n  ]);\n\n  return <Box ref={headerRef} />;\n}\n\nexport default ObsChart;\n"
            }
          },
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [1105, 1121],
              "sourceCode": "import { Box } from \"@mui/material\";\nimport { type Dispatch, type SetStateAction, useEffect, useRef } from \"react\";\n\ntype ObsChartProps = {\n  data: any;\n  otherData?: any;\n  width: number;\n  height: number;\n  renderChart: (params: {\n    data: any;\n    otherData?: any;\n    width: number;\n    height: number;\n  }) => SVGSVGElement;\n  hasTooltip: boolean;\n  fadeElement?: (elmt: SVGElement) => void;\n  highlightElement?: (elmt: SVGElement) => void;\n  resetElement?: (elmt: SVGElement) => void;\n  setChart: Dispatch<SetStateAction<SVGSVGElement>>;\n  setDatum: Dispatch<SetStateAction<any>>;\n  renderSVGOverlay: (chart: SVGSVGElement) => SVGElement | null;\n};\n\nfunction ObsChart({\n  data,\n  otherData,\n  width,\n  height,\n  renderChart,\n  hasTooltip,\n  fadeElement,\n  highlightElement,\n  resetElement,\n  setChart,\n  setDatum,\n  renderSVGOverlay,\n}: ObsChartProps) {\n  const headerRef = useRef();\n\n  useEffect(() => {\n    if (data === undefined || width === null) return;\n    const chart = renderChart({ data, otherData, width, height });\n    setChart(chart);\n\n    if (renderSVGOverlay) {\n      const overlay = renderSVGOverlay(chart);\n      if (overlay == null) return;\n      if (Array.isArray(overlay)) chart.append(...overlay);\n      else chart.append(overlay);\n    }\n\n    if (hasTooltip) {\n      let clicked = false;\n      let selectedDatum;\n      const tooltipMarks = chart.querySelectorAll(\".obs-tooltip *\");\n      for (const elmt of tooltipMarks) {\n        const dataIndex = elmt.__data__;\n        const elmtDatum = data[dataIndex];\n        const highlightSelected = () => {\n          if (fadeElement) tooltipMarks.forEach(fadeElement);\n          // possibly multiple mark elements for same datum\n          if (highlightElement) {\n            chart.querySelectorAll(`[data-index=\"${dataIndex}\"]`).forEach(highlightElement);\n          }\n        };\n        elmt.setAttribute(\"data-index\", dataIndex);\n        elmt.addEventListener(\"click\", (event) => {\n          if (clicked && selectedDatum === elmtDatum) {\n            clicked = false;\n            selectedDatum = null;\n          } else {\n            clicked = true;\n            selectedDatum = elmtDatum;\n            highlightSelected();\n          }\n          setDatum(selectedDatum);\n          event.stopPropagation();\n        });\n        elmt.addEventListener(\"mouseenter\", () => {\n          if (!clicked) {\n            selectedDatum = elmtDatum;\n            setDatum(selectedDatum);\n            highlightSelected();\n          }\n        });\n        elmt.addEventListener(\"mouseleave\", () => {\n          if (!clicked) {\n            selectedDatum = null;\n            setDatum(selectedDatum);\n            if (resetElement) tooltipMarks.forEach(resetElement);\n          }\n        });\n      }\n\n      chart.addEventListener(\"click\", () => {\n        if (clicked) {\n          clicked = false;\n          selectedDatum = null;\n          setDatum(selectedDatum);\n          if (resetElement) tooltipMarks.forEach(resetElement);\n        }\n      });\n    }\n    headerRef.current.append(chart);\n    return () => {\n      setDatum(null);\n      chart.remove();\n    };\n  }, [\n    data,\n    otherData,\n    width,\n    height,\n    renderChart,\n    hasTooltip,\n    fadeElement,\n    highlightElement,\n    resetElement,\n    setChart,\n    setDatum,\n  ]);\n\n  return <Box ref={headerRef} />;\n}\n\nexport default ObsChart;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsChart.tsx" },
        "span": [894, 903],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport { type Dispatch, type SetStateAction, useEffect, useRef } from \"react\";\n\ntype ObsChartProps = {\n  data: any;\n  otherData?: any;\n  width: number;\n  height: number;\n  renderChart: (params: {\n    data: any;\n    otherData?: any;\n    width: number;\n    height: number;\n  }) => SVGSVGElement;\n  hasTooltip: boolean;\n  fadeElement?: (elmt: SVGElement) => void;\n  highlightElement?: (elmt: SVGElement) => void;\n  resetElement?: (elmt: SVGElement) => void;\n  setChart: Dispatch<SetStateAction<SVGSVGElement>>;\n  setDatum: Dispatch<SetStateAction<any>>;\n  renderSVGOverlay: (chart: SVGSVGElement) => SVGElement | null;\n};\n\nfunction ObsChart({\n  data,\n  otherData,\n  width,\n  height,\n  renderChart,\n  hasTooltip,\n  fadeElement,\n  highlightElement,\n  resetElement,\n  setChart,\n  setDatum,\n  renderSVGOverlay,\n}: ObsChartProps) {\n  const headerRef = useRef();\n\n  useEffect(() => {\n    if (data === undefined || width === null) return;\n    const chart = renderChart({ data, otherData, width, height });\n    setChart(chart);\n\n    if (renderSVGOverlay) {\n      const overlay = renderSVGOverlay(chart);\n      if (overlay == null) return;\n      if (Array.isArray(overlay)) chart.append(...overlay);\n      else chart.append(overlay);\n    }\n\n    if (hasTooltip) {\n      let clicked = false;\n      let selectedDatum;\n      const tooltipMarks = chart.querySelectorAll(\".obs-tooltip *\");\n      for (const elmt of tooltipMarks) {\n        const dataIndex = elmt.__data__;\n        const elmtDatum = data[dataIndex];\n        const highlightSelected = () => {\n          if (fadeElement) tooltipMarks.forEach(fadeElement);\n          // possibly multiple mark elements for same datum\n          if (highlightElement) {\n            chart.querySelectorAll(`[data-index=\"${dataIndex}\"]`).forEach(highlightElement);\n          }\n        };\n        elmt.setAttribute(\"data-index\", dataIndex);\n        elmt.addEventListener(\"click\", (event) => {\n          if (clicked && selectedDatum === elmtDatum) {\n            clicked = false;\n            selectedDatum = null;\n          } else {\n            clicked = true;\n            selectedDatum = elmtDatum;\n            highlightSelected();\n          }\n          setDatum(selectedDatum);\n          event.stopPropagation();\n        });\n        elmt.addEventListener(\"mouseenter\", () => {\n          if (!clicked) {\n            selectedDatum = elmtDatum;\n            setDatum(selectedDatum);\n            highlightSelected();\n          }\n        });\n        elmt.addEventListener(\"mouseleave\", () => {\n          if (!clicked) {\n            selectedDatum = null;\n            setDatum(selectedDatum);\n            if (resetElement) tooltipMarks.forEach(resetElement);\n          }\n        });\n      }\n\n      chart.addEventListener(\"click\", () => {\n        if (clicked) {\n          clicked = false;\n          selectedDatum = null;\n          setDatum(selectedDatum);\n          if (resetElement) tooltipMarks.forEach(resetElement);\n        }\n      });\n    }\n    headerRef.current.append(chart);\n    return () => {\n      setDatum(null);\n      chart.remove();\n    };\n  }, [\n    data,\n    otherData,\n    width,\n    height,\n    renderChart,\n    hasTooltip,\n    fadeElement,\n    highlightElement,\n    resetElement,\n    setChart,\n    setDatum,\n  ]);\n\n  return <Box ref={headerRef} />;\n}\n\nexport default ObsChart;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsTooltip.tsx" },
        "span": [834, 838],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport type { ReactElement } from \"react\";\n\ntype ObsTooltipProps = {\n  width: number;\n  height: number;\n  xAnchor?: \"left\" | \"right\" | \"center\" | \"adapt\" | \"plotLeft\" | \"plotRight\";\n  yAnchor?: \"top\" | \"bottom\" | \"center\" | \"adapt\" | \"plotTop\" | \"plotBottom\";\n  dx?: number;\n  dy?: number;\n  xAccessor: (d: any, i?: number) => number;\n  yAccessor: (d: any, i?: number) => number;\n  renderTooltip: (datum: any) => ReactElement;\n  chart: ReactElement;\n  datum: any;\n};\n\nfunction ObsTooltip({\n  width,\n  height,\n  xAnchor = \"adapt\",\n  yAnchor = \"adapt\",\n  dx = 0,\n  dy = 0,\n  xAccessor,\n  yAccessor,\n  renderTooltip,\n  chart,\n  datum,\n}: ObsTooltipProps) {\n  if (!datum) return null;\n\n  const x = chart.scale(\"x\").apply(xAccessor(datum));\n  const y = chart.scale(\"y\").apply(yAccessor(datum));\n\n  let left;\n  let right;\n  let transformX;\n  if (xAnchor === \"plotLeft\") {\n    left = 0;\n  } else if (xAnchor === \"plotRight\") {\n    right = 0;\n  } else if (xAnchor === \"center\") {\n    left = x;\n    transformX = \"-50%\";\n  } else if (xAnchor === \"left\" || (xAnchor === \"adapt\" && x < width / 2)) {\n    left = x + dx;\n  } else {\n    right = width - x + dx;\n  }\n\n  let top;\n  let bottom;\n  let transformY;\n  if (yAnchor === \"plotTop\") {\n    top = 0;\n  } else if (yAnchor === \"plotBottom\") {\n    bottom = 0;\n  } else if (yAnchor === \"center\") {\n    top = y;\n    transformY = \"-50%\";\n  } else if (yAnchor === \"bottom\" || (yAnchor === \"adapt\" && y > height / 2)) {\n    bottom = height - y + dy;\n  } else {\n    top = y + dy;\n  }\n\n  return (\n    <Box\n      width={width}\n      height={height}\n      position=\"absolute\"\n      top={0}\n      left={0}\n      sx={{ pointerEvents: \"none\" }}\n    >\n      <Box\n        sx={{\n          position: \"absolute\",\n          left,\n          right,\n          top,\n          bottom,\n          transform: `translate(${transformX ?? 0}, ${transformY ?? 0})`,\n          pointerEvents: \"auto\",\n        }}\n      >\n        {renderTooltip(datum)}\n      </Box>\n    </Box>\n  );\n}\n\nexport default ObsTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsTooltip.tsx" },
        "span": [846, 851],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport type { ReactElement } from \"react\";\n\ntype ObsTooltipProps = {\n  width: number;\n  height: number;\n  xAnchor?: \"left\" | \"right\" | \"center\" | \"adapt\" | \"plotLeft\" | \"plotRight\";\n  yAnchor?: \"top\" | \"bottom\" | \"center\" | \"adapt\" | \"plotTop\" | \"plotBottom\";\n  dx?: number;\n  dy?: number;\n  xAccessor: (d: any, i?: number) => number;\n  yAccessor: (d: any, i?: number) => number;\n  renderTooltip: (datum: any) => ReactElement;\n  chart: ReactElement;\n  datum: any;\n};\n\nfunction ObsTooltip({\n  width,\n  height,\n  xAnchor = \"adapt\",\n  yAnchor = \"adapt\",\n  dx = 0,\n  dy = 0,\n  xAccessor,\n  yAccessor,\n  renderTooltip,\n  chart,\n  datum,\n}: ObsTooltipProps) {\n  if (!datum) return null;\n\n  const x = chart.scale(\"x\").apply(xAccessor(datum));\n  const y = chart.scale(\"y\").apply(yAccessor(datum));\n\n  let left;\n  let right;\n  let transformX;\n  if (xAnchor === \"plotLeft\") {\n    left = 0;\n  } else if (xAnchor === \"plotRight\") {\n    right = 0;\n  } else if (xAnchor === \"center\") {\n    left = x;\n    transformX = \"-50%\";\n  } else if (xAnchor === \"left\" || (xAnchor === \"adapt\" && x < width / 2)) {\n    left = x + dx;\n  } else {\n    right = width - x + dx;\n  }\n\n  let top;\n  let bottom;\n  let transformY;\n  if (yAnchor === \"plotTop\") {\n    top = 0;\n  } else if (yAnchor === \"plotBottom\") {\n    bottom = 0;\n  } else if (yAnchor === \"center\") {\n    top = y;\n    transformY = \"-50%\";\n  } else if (yAnchor === \"bottom\" || (yAnchor === \"adapt\" && y > height / 2)) {\n    bottom = height - y + dy;\n  } else {\n    top = y + dy;\n  }\n\n  return (\n    <Box\n      width={width}\n      height={height}\n      position=\"absolute\"\n      top={0}\n      left={0}\n      sx={{ pointerEvents: \"none\" }}\n    >\n      <Box\n        sx={{\n          position: \"absolute\",\n          left,\n          right,\n          top,\n          bottom,\n          transform: `translate(${transformX ?? 0}, ${transformY ?? 0})`,\n          pointerEvents: \"auto\",\n        }}\n      >\n        {renderTooltip(datum)}\n      </Box>\n    </Box>\n  );\n}\n\nexport default ObsTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsTooltip.tsx" },
        "span": [859, 869],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport type { ReactElement } from \"react\";\n\ntype ObsTooltipProps = {\n  width: number;\n  height: number;\n  xAnchor?: \"left\" | \"right\" | \"center\" | \"adapt\" | \"plotLeft\" | \"plotRight\";\n  yAnchor?: \"top\" | \"bottom\" | \"center\" | \"adapt\" | \"plotTop\" | \"plotBottom\";\n  dx?: number;\n  dy?: number;\n  xAccessor: (d: any, i?: number) => number;\n  yAccessor: (d: any, i?: number) => number;\n  renderTooltip: (datum: any) => ReactElement;\n  chart: ReactElement;\n  datum: any;\n};\n\nfunction ObsTooltip({\n  width,\n  height,\n  xAnchor = \"adapt\",\n  yAnchor = \"adapt\",\n  dx = 0,\n  dy = 0,\n  xAccessor,\n  yAccessor,\n  renderTooltip,\n  chart,\n  datum,\n}: ObsTooltipProps) {\n  if (!datum) return null;\n\n  const x = chart.scale(\"x\").apply(xAccessor(datum));\n  const y = chart.scale(\"y\").apply(yAccessor(datum));\n\n  let left;\n  let right;\n  let transformX;\n  if (xAnchor === \"plotLeft\") {\n    left = 0;\n  } else if (xAnchor === \"plotRight\") {\n    right = 0;\n  } else if (xAnchor === \"center\") {\n    left = x;\n    transformX = \"-50%\";\n  } else if (xAnchor === \"left\" || (xAnchor === \"adapt\" && x < width / 2)) {\n    left = x + dx;\n  } else {\n    right = width - x + dx;\n  }\n\n  let top;\n  let bottom;\n  let transformY;\n  if (yAnchor === \"plotTop\") {\n    top = 0;\n  } else if (yAnchor === \"plotBottom\") {\n    bottom = 0;\n  } else if (yAnchor === \"center\") {\n    top = y;\n    transformY = \"-50%\";\n  } else if (yAnchor === \"bottom\" || (yAnchor === \"adapt\" && y > height / 2)) {\n    bottom = height - y + dy;\n  } else {\n    top = y + dy;\n  }\n\n  return (\n    <Box\n      width={width}\n      height={height}\n      position=\"absolute\"\n      top={0}\n      left={0}\n      sx={{ pointerEvents: \"none\" }}\n    >\n      <Box\n        sx={{\n          position: \"absolute\",\n          left,\n          right,\n          top,\n          bottom,\n          transform: `translate(${transformX ?? 0}, ${transformY ?? 0})`,\n          pointerEvents: \"auto\",\n        }}\n      >\n        {renderTooltip(datum)}\n      </Box>\n    </Box>\n  );\n}\n\nexport default ObsTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsTooltip.tsx" },
        "span": [1194, 1197],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport type { ReactElement } from \"react\";\n\ntype ObsTooltipProps = {\n  width: number;\n  height: number;\n  xAnchor?: \"left\" | \"right\" | \"center\" | \"adapt\" | \"plotLeft\" | \"plotRight\";\n  yAnchor?: \"top\" | \"bottom\" | \"center\" | \"adapt\" | \"plotTop\" | \"plotBottom\";\n  dx?: number;\n  dy?: number;\n  xAccessor: (d: any, i?: number) => number;\n  yAccessor: (d: any, i?: number) => number;\n  renderTooltip: (datum: any) => ReactElement;\n  chart: ReactElement;\n  datum: any;\n};\n\nfunction ObsTooltip({\n  width,\n  height,\n  xAnchor = \"adapt\",\n  yAnchor = \"adapt\",\n  dx = 0,\n  dy = 0,\n  xAccessor,\n  yAccessor,\n  renderTooltip,\n  chart,\n  datum,\n}: ObsTooltipProps) {\n  if (!datum) return null;\n\n  const x = chart.scale(\"x\").apply(xAccessor(datum));\n  const y = chart.scale(\"y\").apply(yAccessor(datum));\n\n  let left;\n  let right;\n  let transformX;\n  if (xAnchor === \"plotLeft\") {\n    left = 0;\n  } else if (xAnchor === \"plotRight\") {\n    right = 0;\n  } else if (xAnchor === \"center\") {\n    left = x;\n    transformX = \"-50%\";\n  } else if (xAnchor === \"left\" || (xAnchor === \"adapt\" && x < width / 2)) {\n    left = x + dx;\n  } else {\n    right = width - x + dx;\n  }\n\n  let top;\n  let bottom;\n  let transformY;\n  if (yAnchor === \"plotTop\") {\n    top = 0;\n  } else if (yAnchor === \"plotBottom\") {\n    bottom = 0;\n  } else if (yAnchor === \"center\") {\n    top = y;\n    transformY = \"-50%\";\n  } else if (yAnchor === \"bottom\" || (yAnchor === \"adapt\" && y > height / 2)) {\n    bottom = height - y + dy;\n  } else {\n    top = y + dy;\n  }\n\n  return (\n    <Box\n      width={width}\n      height={height}\n      position=\"absolute\"\n      top={0}\n      left={0}\n      sx={{ pointerEvents: \"none\" }}\n    >\n      <Box\n        sx={{\n          position: \"absolute\",\n          left,\n          right,\n          top,\n          bottom,\n          transform: `translate(${transformX ?? 0}, ${transformY ?? 0})`,\n          pointerEvents: \"auto\",\n        }}\n      >\n        {renderTooltip(datum)}\n      </Box>\n    </Box>\n  );\n}\n\nexport default ObsTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsTooltip.tsx" },
        "span": [1205, 1211],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport type { ReactElement } from \"react\";\n\ntype ObsTooltipProps = {\n  width: number;\n  height: number;\n  xAnchor?: \"left\" | \"right\" | \"center\" | \"adapt\" | \"plotLeft\" | \"plotRight\";\n  yAnchor?: \"top\" | \"bottom\" | \"center\" | \"adapt\" | \"plotTop\" | \"plotBottom\";\n  dx?: number;\n  dy?: number;\n  xAccessor: (d: any, i?: number) => number;\n  yAccessor: (d: any, i?: number) => number;\n  renderTooltip: (datum: any) => ReactElement;\n  chart: ReactElement;\n  datum: any;\n};\n\nfunction ObsTooltip({\n  width,\n  height,\n  xAnchor = \"adapt\",\n  yAnchor = \"adapt\",\n  dx = 0,\n  dy = 0,\n  xAccessor,\n  yAccessor,\n  renderTooltip,\n  chart,\n  datum,\n}: ObsTooltipProps) {\n  if (!datum) return null;\n\n  const x = chart.scale(\"x\").apply(xAccessor(datum));\n  const y = chart.scale(\"y\").apply(yAccessor(datum));\n\n  let left;\n  let right;\n  let transformX;\n  if (xAnchor === \"plotLeft\") {\n    left = 0;\n  } else if (xAnchor === \"plotRight\") {\n    right = 0;\n  } else if (xAnchor === \"center\") {\n    left = x;\n    transformX = \"-50%\";\n  } else if (xAnchor === \"left\" || (xAnchor === \"adapt\" && x < width / 2)) {\n    left = x + dx;\n  } else {\n    right = width - x + dx;\n  }\n\n  let top;\n  let bottom;\n  let transformY;\n  if (yAnchor === \"plotTop\") {\n    top = 0;\n  } else if (yAnchor === \"plotBottom\") {\n    bottom = 0;\n  } else if (yAnchor === \"center\") {\n    top = y;\n    transformY = \"-50%\";\n  } else if (yAnchor === \"bottom\" || (yAnchor === \"adapt\" && y > height / 2)) {\n    bottom = height - y + dy;\n  } else {\n    top = y + dy;\n  }\n\n  return (\n    <Box\n      width={width}\n      height={height}\n      position=\"absolute\"\n      top={0}\n      left={0}\n      sx={{ pointerEvents: \"none\" }}\n    >\n      <Box\n        sx={{\n          position: \"absolute\",\n          left,\n          right,\n          top,\n          bottom,\n          transform: `translate(${transformX ?? 0}, ${transformY ?? 0})`,\n          pointerEvents: \"auto\",\n        }}\n      >\n        {renderTooltip(datum)}\n      </Box>\n    </Box>\n  );\n}\n\nexport default ObsTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/ObsPlot/ObsTooltip.tsx" },
        "span": [1219, 1229],
        "sourceCode": "import { Box } from \"@mui/material\";\nimport type { ReactElement } from \"react\";\n\ntype ObsTooltipProps = {\n  width: number;\n  height: number;\n  xAnchor?: \"left\" | \"right\" | \"center\" | \"adapt\" | \"plotLeft\" | \"plotRight\";\n  yAnchor?: \"top\" | \"bottom\" | \"center\" | \"adapt\" | \"plotTop\" | \"plotBottom\";\n  dx?: number;\n  dy?: number;\n  xAccessor: (d: any, i?: number) => number;\n  yAccessor: (d: any, i?: number) => number;\n  renderTooltip: (datum: any) => ReactElement;\n  chart: ReactElement;\n  datum: any;\n};\n\nfunction ObsTooltip({\n  width,\n  height,\n  xAnchor = \"adapt\",\n  yAnchor = \"adapt\",\n  dx = 0,\n  dy = 0,\n  xAccessor,\n  yAccessor,\n  renderTooltip,\n  chart,\n  datum,\n}: ObsTooltipProps) {\n  if (!datum) return null;\n\n  const x = chart.scale(\"x\").apply(xAccessor(datum));\n  const y = chart.scale(\"y\").apply(yAccessor(datum));\n\n  let left;\n  let right;\n  let transformX;\n  if (xAnchor === \"plotLeft\") {\n    left = 0;\n  } else if (xAnchor === \"plotRight\") {\n    right = 0;\n  } else if (xAnchor === \"center\") {\n    left = x;\n    transformX = \"-50%\";\n  } else if (xAnchor === \"left\" || (xAnchor === \"adapt\" && x < width / 2)) {\n    left = x + dx;\n  } else {\n    right = width - x + dx;\n  }\n\n  let top;\n  let bottom;\n  let transformY;\n  if (yAnchor === \"plotTop\") {\n    top = 0;\n  } else if (yAnchor === \"plotBottom\") {\n    bottom = 0;\n  } else if (yAnchor === \"center\") {\n    top = y;\n    transformY = \"-50%\";\n  } else if (yAnchor === \"bottom\" || (yAnchor === \"adapt\" && y > height / 2)) {\n    bottom = height - y + dy;\n  } else {\n    top = y + dy;\n  }\n\n  return (\n    <Box\n      width={width}\n      height={height}\n      position=\"absolute\"\n      top={0}\n      left={0}\n      sx={{ pointerEvents: \"none\" }}\n    >\n      <Box\n        sx={{\n          position: \"absolute\",\n          left,\n          right,\n          top,\n          bottom,\n          transform: `translate(${transformX ?? 0}, ${transformY ?? 0})`,\n          pointerEvents: \"auto\",\n        }}\n      >\n        {renderTooltip(datum)}\n      </Box>\n    </Box>\n  );\n}\n\nexport default ObsTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/suspicious/noImplicitAnyLet",
      "severity": "error",
      "description": "This variable implicitly has the any type.",
      "message": [
        { "elements": [], "content": "This variable implicitly has the " },
        { "elements": ["Emphasis"], "content": "any" },
        { "elements": [], "content": " type." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "Variable declarations without type annotation and initialization implicitly have the "
                },
                { "elements": ["Emphasis"], "content": "any" },
                {
                  "elements": [],
                  "content": " type. Declare a type or initialize the variable with some value."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtAsyncTooltip/OtAsyncTooltip.tsx" },
        "span": [3092, 3104],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Divider,\n  Skeleton,\n  Tooltip,\n  type TooltipProps,\n  styled,\n  tooltipClasses,\n} from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { type ReactElement, useEffect, useState } from \"react\";\nimport {\n  getEntityDescription,\n  getEntityIcon,\n  getEntityQuery,\n  getQueryVariables,\n} from \"./utils/asyncTooltipUtil\";\n\nimport StudyPublication from \"../StudyPublication\";\n\nconst DELAY_REQUEST = 1000;\n\nconst HtmlTooltip = styled(({ className, ...props }: TooltipProps) => (\n  <Tooltip {...props} classes={{ popper: className }} />\n))(({ theme }) => ({\n  [`& .${tooltipClasses.tooltip}`]: {\n    backgroundColor: theme.palette.common.white,\n    maxWidth: 400,\n    boxShadow: theme.boxShadow.default,\n    cursor: \"pointer\",\n    border: `1px solid ${theme.palette.grey[300]}`,\n    borderRadius: 4,\n  },\n\n  [`& .${tooltipClasses.arrow}`]: {\n    color: theme.palette.common.white,\n  },\n\n  [`& .${tooltipClasses.arrow}::before`]: {\n    border: `1px solid ${theme.palette.grey[300]}`,\n  },\n}));\n\ntype OtAsyncTooltipProps = {\n  children: ReactElement;\n  entity: string;\n  id: string;\n};\n\nfunction OtAsyncTooltip({ children, entity, id }: OtAsyncTooltipProps): ReactElement {\n  const variables = getQueryVariables(entity, id);\n\n  const query = getEntityQuery(entity);\n  const [open, setOpen] = useState(false);\n  const [aborterRef] = useState(new AbortController());\n  const [getTooltipData, { loading, data }] = useLazyQuery(query, {\n    fetchPolicy: \"network-only\",\n    context: { fetchOptions: { signal: aborterRef.signal } },\n  });\n\n  function getTooltipContent() {\n    let entityAccessor = entity;\n    if (loading || !data) return <AsyncTooltipLoadingView />;\n    if (entity === \"credible-set\") entityAccessor = \"credibleSet\";\n    return <AsyncTooltipDataView entity={entity} data={data?.[entityAccessor]} />;\n  }\n\n  function abortApiCall() {\n    aborterRef.abort();\n  }\n\n  function handleClose() {\n    setOpen(false);\n    abortApiCall();\n  }\n\n  function handleOpen() {\n    getTooltipData({ variables });\n    setOpen(true);\n  }\n\n  useEffect(() => {\n    return () => {\n      abortApiCall();\n    };\n  }, []);\n\n  const tooltipContent = getTooltipContent();\n\n  return (\n    <HtmlTooltip\n      arrow\n      placement=\"bottom-end\"\n      enterDelay={DELAY_REQUEST}\n      enterNextDelay={DELAY_REQUEST}\n      enterTouchDelay={DELAY_REQUEST}\n      open={open}\n      onClose={handleClose}\n      onOpen={handleOpen}\n      title={tooltipContent}\n    >\n      {children}\n    </HtmlTooltip>\n  );\n}\n\nfunction AsyncTooltipLoadingView(): ReactElement {\n  return (\n    <Box sx={{ width: 300 }}>\n      <Box>\n        <Skeleton />\n        <Skeleton />\n      </Box>\n      <Skeleton />\n      <Skeleton />\n    </Box>\n  );\n}\n\nfunction AsyncTooltipDataView({\n  entity,\n  data,\n}: {\n  entity: string;\n  data: Record<string, unknown>;\n}): ReactElement {\n  const showSubText = !!data?.mostSevereConsequence?.label || data?.publicationFirstAuthor;\n\n  function getSubtext() {\n    let finalSubText;\n\n    // variant subtext\n    const mostSevereConsequence = data?.mostSevereConsequence?.label;\n    if (mostSevereConsequence) finalSubText = `Most severe consequence: ${mostSevereConsequence}`;\n\n    // study subtext\n    const publicationData = data?.publicationFirstAuthor;\n    if (publicationData)\n      finalSubText = (\n        <StudyPublication\n          publicationDate={data?.publicationDate}\n          publicationFirstAuthor={data?.publicationFirstAuthor}\n          publicationJournal={data?.publicationJournal}\n        />\n      );\n\n    return finalSubText;\n  }\n\n  function getLabel() {\n    if (entity === \"credible-set\") return \"Credible set\";\n    return data?.name || data?.id || naLabel;\n  }\n\n  return (\n    <Box sx={{ p: 1 }}>\n      <Box\n        sx={{\n          p: 1,\n          py: 0,\n          fontSize: \"0.7rem\",\n          color: (theme) => theme.palette.grey[700],\n          textDecoration: \"underline\",\n        }}\n      >\n        {`${entity}/${data?.id}`}\n      </Box>\n      <Box sx={{ display: \"flex\", gap: 1, py: 1 }}>\n        <Box sx={{ p: 1, color: (theme) => theme.palette.primary.main }}>\n          <FontAwesomeIcon size=\"2x\" icon={getEntityIcon(entity)} />\n        </Box>\n        <Box sx={{ pt: 0.4 }}>\n          <Box\n            sx={{\n              typography: \"subtitle2\",\n              color: (theme) => theme.palette.grey[900],\n              textTransform: \"capitalize\",\n              fontWeight: \"bold\",\n            }}\n          >\n            {getLabel()}\n          </Box>{\" \"}\n          <Box sx={{ typography: \"body2\", color: (theme) => theme.palette.grey[800] }}>\n            {getEntityDescription(entity, data)}\n          </Box>\n        </Box>\n      </Box>\n      {showSubText && (\n        <>\n          <Divider />\n          <Box\n            sx={{ typography: \"caption\", color: (theme) => theme.palette.grey[900], pt: 1, pl: 1 }}\n          >\n            {getSubtext()}\n          </Box>\n        </>\n      )}\n    </Box>\n  );\n}\n\nexport default OtAsyncTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: abortApiCall",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: abortApiCall"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2215, 2227],
              "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Divider,\n  Skeleton,\n  Tooltip,\n  type TooltipProps,\n  styled,\n  tooltipClasses,\n} from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { type ReactElement, useEffect, useState } from \"react\";\nimport {\n  getEntityDescription,\n  getEntityIcon,\n  getEntityQuery,\n  getQueryVariables,\n} from \"./utils/asyncTooltipUtil\";\n\nimport StudyPublication from \"../StudyPublication\";\n\nconst DELAY_REQUEST = 1000;\n\nconst HtmlTooltip = styled(({ className, ...props }: TooltipProps) => (\n  <Tooltip {...props} classes={{ popper: className }} />\n))(({ theme }) => ({\n  [`& .${tooltipClasses.tooltip}`]: {\n    backgroundColor: theme.palette.common.white,\n    maxWidth: 400,\n    boxShadow: theme.boxShadow.default,\n    cursor: \"pointer\",\n    border: `1px solid ${theme.palette.grey[300]}`,\n    borderRadius: 4,\n  },\n\n  [`& .${tooltipClasses.arrow}`]: {\n    color: theme.palette.common.white,\n  },\n\n  [`& .${tooltipClasses.arrow}::before`]: {\n    border: `1px solid ${theme.palette.grey[300]}`,\n  },\n}));\n\ntype OtAsyncTooltipProps = {\n  children: ReactElement;\n  entity: string;\n  id: string;\n};\n\nfunction OtAsyncTooltip({ children, entity, id }: OtAsyncTooltipProps): ReactElement {\n  const variables = getQueryVariables(entity, id);\n\n  const query = getEntityQuery(entity);\n  const [open, setOpen] = useState(false);\n  const [aborterRef] = useState(new AbortController());\n  const [getTooltipData, { loading, data }] = useLazyQuery(query, {\n    fetchPolicy: \"network-only\",\n    context: { fetchOptions: { signal: aborterRef.signal } },\n  });\n\n  function getTooltipContent() {\n    let entityAccessor = entity;\n    if (loading || !data) return <AsyncTooltipLoadingView />;\n    if (entity === \"credible-set\") entityAccessor = \"credibleSet\";\n    return <AsyncTooltipDataView entity={entity} data={data?.[entityAccessor]} />;\n  }\n\n  function abortApiCall() {\n    aborterRef.abort();\n  }\n\n  function handleClose() {\n    setOpen(false);\n    abortApiCall();\n  }\n\n  function handleOpen() {\n    getTooltipData({ variables });\n    setOpen(true);\n  }\n\n  useEffect(() => {\n    return () => {\n      abortApiCall();\n    };\n  }, []);\n\n  const tooltipContent = getTooltipContent();\n\n  return (\n    <HtmlTooltip\n      arrow\n      placement=\"bottom-end\"\n      enterDelay={DELAY_REQUEST}\n      enterNextDelay={DELAY_REQUEST}\n      enterTouchDelay={DELAY_REQUEST}\n      open={open}\n      onClose={handleClose}\n      onOpen={handleOpen}\n      title={tooltipContent}\n    >\n      {children}\n    </HtmlTooltip>\n  );\n}\n\nfunction AsyncTooltipLoadingView(): ReactElement {\n  return (\n    <Box sx={{ width: 300 }}>\n      <Box>\n        <Skeleton />\n        <Skeleton />\n      </Box>\n      <Skeleton />\n      <Skeleton />\n    </Box>\n  );\n}\n\nfunction AsyncTooltipDataView({\n  entity,\n  data,\n}: {\n  entity: string;\n  data: Record<string, unknown>;\n}): ReactElement {\n  const showSubText = !!data?.mostSevereConsequence?.label || data?.publicationFirstAuthor;\n\n  function getSubtext() {\n    let finalSubText;\n\n    // variant subtext\n    const mostSevereConsequence = data?.mostSevereConsequence?.label;\n    if (mostSevereConsequence) finalSubText = `Most severe consequence: ${mostSevereConsequence}`;\n\n    // study subtext\n    const publicationData = data?.publicationFirstAuthor;\n    if (publicationData)\n      finalSubText = (\n        <StudyPublication\n          publicationDate={data?.publicationDate}\n          publicationFirstAuthor={data?.publicationFirstAuthor}\n          publicationJournal={data?.publicationJournal}\n        />\n      );\n\n    return finalSubText;\n  }\n\n  function getLabel() {\n    if (entity === \"credible-set\") return \"Credible set\";\n    return data?.name || data?.id || naLabel;\n  }\n\n  return (\n    <Box sx={{ p: 1 }}>\n      <Box\n        sx={{\n          p: 1,\n          py: 0,\n          fontSize: \"0.7rem\",\n          color: (theme) => theme.palette.grey[700],\n          textDecoration: \"underline\",\n        }}\n      >\n        {`${entity}/${data?.id}`}\n      </Box>\n      <Box sx={{ display: \"flex\", gap: 1, py: 1 }}>\n        <Box sx={{ p: 1, color: (theme) => theme.palette.primary.main }}>\n          <FontAwesomeIcon size=\"2x\" icon={getEntityIcon(entity)} />\n        </Box>\n        <Box sx={{ pt: 0.4 }}>\n          <Box\n            sx={{\n              typography: \"subtitle2\",\n              color: (theme) => theme.palette.grey[900],\n              textTransform: \"capitalize\",\n              fontWeight: \"bold\",\n            }}\n          >\n            {getLabel()}\n          </Box>{\" \"}\n          <Box sx={{ typography: \"body2\", color: (theme) => theme.palette.grey[800] }}>\n            {getEntityDescription(entity, data)}\n          </Box>\n        </Box>\n      </Box>\n      {showSubText && (\n        <>\n          <Divider />\n          <Box\n            sx={{ typography: \"caption\", color: (theme) => theme.palette.grey[900], pt: 1, pl: 1 }}\n          >\n            {getSubtext()}\n          </Box>\n        </>\n      )}\n    </Box>\n  );\n}\n\nexport default OtAsyncTooltip;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtAsyncTooltip/OtAsyncTooltip.tsx" },
        "span": [2172, 2181],
        "sourceCode": "import { useLazyQuery } from \"@apollo/client\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport {\n  Box,\n  Divider,\n  Skeleton,\n  Tooltip,\n  type TooltipProps,\n  styled,\n  tooltipClasses,\n} from \"@mui/material\";\nimport { naLabel } from \"@ot/constants\";\nimport { type ReactElement, useEffect, useState } from \"react\";\nimport {\n  getEntityDescription,\n  getEntityIcon,\n  getEntityQuery,\n  getQueryVariables,\n} from \"./utils/asyncTooltipUtil\";\n\nimport StudyPublication from \"../StudyPublication\";\n\nconst DELAY_REQUEST = 1000;\n\nconst HtmlTooltip = styled(({ className, ...props }: TooltipProps) => (\n  <Tooltip {...props} classes={{ popper: className }} />\n))(({ theme }) => ({\n  [`& .${tooltipClasses.tooltip}`]: {\n    backgroundColor: theme.palette.common.white,\n    maxWidth: 400,\n    boxShadow: theme.boxShadow.default,\n    cursor: \"pointer\",\n    border: `1px solid ${theme.palette.grey[300]}`,\n    borderRadius: 4,\n  },\n\n  [`& .${tooltipClasses.arrow}`]: {\n    color: theme.palette.common.white,\n  },\n\n  [`& .${tooltipClasses.arrow}::before`]: {\n    border: `1px solid ${theme.palette.grey[300]}`,\n  },\n}));\n\ntype OtAsyncTooltipProps = {\n  children: ReactElement;\n  entity: string;\n  id: string;\n};\n\nfunction OtAsyncTooltip({ children, entity, id }: OtAsyncTooltipProps): ReactElement {\n  const variables = getQueryVariables(entity, id);\n\n  const query = getEntityQuery(entity);\n  const [open, setOpen] = useState(false);\n  const [aborterRef] = useState(new AbortController());\n  const [getTooltipData, { loading, data }] = useLazyQuery(query, {\n    fetchPolicy: \"network-only\",\n    context: { fetchOptions: { signal: aborterRef.signal } },\n  });\n\n  function getTooltipContent() {\n    let entityAccessor = entity;\n    if (loading || !data) return <AsyncTooltipLoadingView />;\n    if (entity === \"credible-set\") entityAccessor = \"credibleSet\";\n    return <AsyncTooltipDataView entity={entity} data={data?.[entityAccessor]} />;\n  }\n\n  function abortApiCall() {\n    aborterRef.abort();\n  }\n\n  function handleClose() {\n    setOpen(false);\n    abortApiCall();\n  }\n\n  function handleOpen() {\n    getTooltipData({ variables });\n    setOpen(true);\n  }\n\n  useEffect(() => {\n    return () => {\n      abortApiCall();\n    };\n  }, []);\n\n  const tooltipContent = getTooltipContent();\n\n  return (\n    <HtmlTooltip\n      arrow\n      placement=\"bottom-end\"\n      enterDelay={DELAY_REQUEST}\n      enterNextDelay={DELAY_REQUEST}\n      enterTouchDelay={DELAY_REQUEST}\n      open={open}\n      onClose={handleClose}\n      onOpen={handleOpen}\n      title={tooltipContent}\n    >\n      {children}\n    </HtmlTooltip>\n  );\n}\n\nfunction AsyncTooltipLoadingView(): ReactElement {\n  return (\n    <Box sx={{ width: 300 }}>\n      <Box>\n        <Skeleton />\n        <Skeleton />\n      </Box>\n      <Skeleton />\n      <Skeleton />\n    </Box>\n  );\n}\n\nfunction AsyncTooltipDataView({\n  entity,\n  data,\n}: {\n  entity: string;\n  data: Record<string, unknown>;\n}): ReactElement {\n  const showSubText = !!data?.mostSevereConsequence?.label || data?.publicationFirstAuthor;\n\n  function getSubtext() {\n    let finalSubText;\n\n    // variant subtext\n    const mostSevereConsequence = data?.mostSevereConsequence?.label;\n    if (mostSevereConsequence) finalSubText = `Most severe consequence: ${mostSevereConsequence}`;\n\n    // study subtext\n    const publicationData = data?.publicationFirstAuthor;\n    if (publicationData)\n      finalSubText = (\n        <StudyPublication\n          publicationDate={data?.publicationDate}\n          publicationFirstAuthor={data?.publicationFirstAuthor}\n          publicationJournal={data?.publicationJournal}\n        />\n      );\n\n    return finalSubText;\n  }\n\n  function getLabel() {\n    if (entity === \"credible-set\") return \"Credible set\";\n    return data?.name || data?.id || naLabel;\n  }\n\n  return (\n    <Box sx={{ p: 1 }}>\n      <Box\n        sx={{\n          p: 1,\n          py: 0,\n          fontSize: \"0.7rem\",\n          color: (theme) => theme.palette.grey[700],\n          textDecoration: \"underline\",\n        }}\n      >\n        {`${entity}/${data?.id}`}\n      </Box>\n      <Box sx={{ display: \"flex\", gap: 1, py: 1 }}>\n        <Box sx={{ p: 1, color: (theme) => theme.palette.primary.main }}>\n          <FontAwesomeIcon size=\"2x\" icon={getEntityIcon(entity)} />\n        </Box>\n        <Box sx={{ pt: 0.4 }}>\n          <Box\n            sx={{\n              typography: \"subtitle2\",\n              color: (theme) => theme.palette.grey[900],\n              textTransform: \"capitalize\",\n              fontWeight: \"bold\",\n            }}\n          >\n            {getLabel()}\n          </Box>{\" \"}\n          <Box sx={{ typography: \"body2\", color: (theme) => theme.palette.grey[800] }}>\n            {getEntityDescription(entity, data)}\n          </Box>\n        </Box>\n      </Box>\n      {showSubText && (\n        <>\n          <Divider />\n          <Box\n            sx={{ typography: \"caption\", color: (theme) => theme.palette.grey[900], pt: 1, pl: 1 }}\n          >\n            {getSubtext()}\n          </Box>\n        </>\n      )}\n    </Box>\n  );\n}\n\nexport default OtAsyncTooltip;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [14277, 14578],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: loadingCells",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: loadingCells"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2348, 2360],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [2305, 2312],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: mappedColumns",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: mappedColumns"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2363, 2376],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [2305, 2312],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: enableRowSelection",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: enableRowSelection"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7400, 7418],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [7213, 7222],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: pagination.pageSize",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: pagination.pageSize"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7295, 7314],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [7213, 7222],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: setTableData",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: setTableData"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7327, 7339],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [7213, 7222],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: enableRowSelection",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: enableRowSelection"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7506, 7524],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [7484, 7493],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: table.getSelectedRowModel",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: table.getSelectedRowModel"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7544, 7569],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [7484, 7493],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: getSelectedRows",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: getSelectedRows"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7528, 7543],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [7484, 7493],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: table.getSelectedRowModel()",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: table.getSelectedRowModel()"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [7585, 7612],
              "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTableSSP.tsx" },
        "span": [7484, 7493],
        "sourceCode": "import { faAngleLeft, faAngleRight, faBackwardStep } from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, CircularProgress, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type PaginationState,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getPaginationRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useReducer, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport { INIT_PAGE_SIZE, type OtTableSSPProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\nimport { addRows, setLoading, setNewData, textSearch } from \"./context/otTableActions\";\nimport { createInitialState, otTableReducer } from \"./context/otTableReducer\";\nimport { getTableRows } from \"./service/tableService\";\n\nimport useCursorBatchDownloader from \"../../hooks/useCursorBatchDownloader\";\nimport { useApolloClient } from \"../../providers/OTApolloProvider/OTApolloProvider\";\n\nfunction OtTableSSP({\n  showGlobalFilter = true,\n  columns = [],\n  verticalHeaders = false,\n  query,\n  variables,\n  entity,\n  sectionName,\n  dataDownloaderFileStem,\n  dataDownloaderColumns,\n  dataDownloader,\n  showColumnVisibilityControl = true,\n  setInitialRequestData,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableSSPProps): ReactElement {\n  const client = useApolloClient();\n  const [state, dispatch] = useReducer(otTableReducer, \"\", createInitialState);\n  const [rowSelection, setRowSelection] = useState({});\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: INIT_PAGE_SIZE,\n  });\n\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const tableColumns = useMemo(\n    () => (state.initialLoading ? loadingCells : mappedColumns),\n    [state.initialLoading]\n  );\n\n  const table = useReactTable({\n    data: state.rows,\n    columns: tableColumns,\n    rowCount: state.count,\n    state: {\n      pagination,\n      rowSelection,\n    },\n    autoResetPageIndex: false,\n    // manualPagination: true,\n    onPaginationChange: onPaginationChange,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  /****\n   * call the higher order function if row selection is enabled\n   ****/\n  function onRowSelection(row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  /**********************************************\n   * DEFAULT FUNCTION CALLBACK TRIGGERED BY\n   * REACT TABLE IN ANY PAGE CHANGE EVENT *\n   * @param:\n   * updater: @type callback function\n   **********************************************/\n\n  function onPaginationChange(updater) {\n    const newPagination = updater(pagination);\n\n    // switch () {\n    //   case (pagination.pageSize !== newPagination.pageSize): {\n    //     onPageSizeChange(newPagination);\n    //     break;\n    //   }\n    //   case (newPagination.pageIndex > pagination.pageIndex): {\n    //     onPageChange(newPagination);\n    //     break;\n    //   }\n    //   default: {\n    //   setPagination(newPagination);\n    //   break;\n    //   }\n    // }\n\n    if (pagination.pageSize !== newPagination.pageSize) {\n      onPageSizeChange(newPagination);\n    } else if (newPagination.pageIndex > pagination.pageIndex) {\n      onPageChange(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE INDEX CHANGE\n   * CHECK IF MORE DATA IS REQUIRED BY CHECKING\n   * NUMBER OF ROWS ALREADY FETCHED, PREVENT EXCESSIVE\n   * API CALLS IN CASE USER PAGINATE BACK AND FORTH\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageChange(newPagination: PaginationState) {\n    if (needMoreData(pagination.pageSize, newPagination.pageIndex)) {\n      addNewData(newPagination);\n    } else {\n      setPagination(newPagination);\n    }\n  }\n\n  /**********************************************\n   * FUNCTION FOR PAGE SIZE CHANGE\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function onPageSizeChange(newPagination: PaginationState) {\n    setTableData({ newPagination });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH MORE DATA (PAGINATION)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AS PER TABLE STATE\n   * SETS PAGINATION AFTER DATA IS FETCHED TO AVOID\n   * SHOWING EMPTY ROWS\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n\n  function addNewData(newPagination: PaginationState) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: state.cursor,\n      size: pagination.pageSize,\n      freeTextQuery: state.freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(addRows(d.data[entity][sectionName]));\n      setPagination(newPagination);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO FETCH NEW DATA (PAGE SIZE CHANGE OR SEARCH TEXT)\n   * SETTING LOADING TRUE BEFORE FETCHING\n   * FETCH DATA AND PASSING CURSOR AS NULL\n   * @param:\n   * newPagination: @type PaginationState \"@tanstack/react-table\"\n   **********************************************/\n  function setTableData({ newPagination = pagination, freeTextQuery = state.freeTextQuery }) {\n    dispatch(setLoading(true));\n    getTableRows({\n      query,\n      variables,\n      cursor: null,\n      size: newPagination.pageSize,\n      freeTextQuery,\n      client,\n    }).then((d) => {\n      dispatch(setNewData(d.data[entity][sectionName]));\n      if (!state.freeTextQuery) setInitialRequestData(d);\n    });\n  }\n\n  /**********************************************\n   * FUNCTION TO TO CHECK IF MORE DATA IS NEEDED\n   * IN CASE USER PAGINATE BACKWARDS\n   * @param:\n   * pageSize: number\n   * pageIndex: number\n   * @return : boolean\n   **********************************************/\n  function needMoreData(pageSize: number, pageIndex: number) {\n    const dataLength = table.options.data.length;\n    return dataLength < (pageIndex + 1) * pageSize;\n  }\n\n  /*********************************\n   * STORES ALL DATA IN FOR EXPORT *\n   *********************************/\n  const getWholeDataset = useCursorBatchDownloader(\n    query,\n    { ...variables, freeTextQuery: state.freeTextQuery },\n    `data[${entity}][${sectionName}]`\n  );\n\n  useEffect(() => {\n    const newPagination = {\n      pageIndex: 0,\n      pageSize: pagination.pageSize,\n    };\n    setTableData({ newPagination, freeTextQuery: state.freeTextQuery });\n    enableRowSelection && setRowSelection({ 0: true });\n  }, [state.freeTextQuery]);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const playgroundVariables = { ...variables, cursor: null, size: 10 };\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && (\n            <OtTableSearch\n              setGlobalSearchTerm={(freeTextQuery) => {\n                dispatch(textSearch(freeTextQuery));\n              }}\n            />\n          )}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={getWholeDataset}\n              fileStem={dataDownloaderFileStem}\n              query={query.loc.source.body}\n              variables={playgroundVariables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader numeric={header.column.columnDef.numeric}>\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            sx={{ typography: \"subtitle2\" }}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                          </OtTableHeaderText>\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={() => onRowSelection(row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/* Table footer component container */}\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        {state.loading && <CircularProgress sx={{ mx: (theme) => theme.spacing(2) }} size={25} />}\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={state.loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n              setPagination({\n                pageIndex: 0,\n                pageSize: Number(e.target.value),\n              });\n            }}\n          >\n            {/* TODO: set page size  */}\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(pagination.pageIndex, pagination.pageSize, state.count)}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"first page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage() || state.loading}\n              aria-label=\"previous page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage() || state.loading}\n              aria-label=\"next page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\n// TODO: FIND A WAY TO USE SAME FUNCTION FROM CLIENT TABLE\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTableSSP;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/complexity/noForEach",
      "severity": "error",
      "description": "Prefer for...of instead of forEach.",
      "message": [
        { "elements": [], "content": "Prefer " },
        { "elements": ["Emphasis"], "content": "for...of" },
        { "elements": [], "content": " instead of " },
        { "elements": ["Emphasis"], "content": "forEach" },
        { "elements": [], "content": "." }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                { "elements": ["Emphasis"], "content": "forEach" },
                {
                  "elements": [],
                  "content": " may lead to performance issues when working with large arrays. When combined with functions like "
                },
                { "elements": ["Emphasis"], "content": "filter" },
                { "elements": [], "content": " or " },
                { "elements": ["Emphasis"], "content": "map" },
                {
                  "elements": [],
                  "content": ", this causes multiple iterations over the same type."
                }
              ]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [12095, 12396],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: loadingRows",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: loadingRows"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2948, 2959],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [2923, 2930],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: rows",
      "message": [
        { "elements": [], "content": "This hook does not specify all of its dependencies: rows" }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [2962, 2966],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [2923, 2930],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: loadingCells",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: loadingCells"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3029, 3041],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [3004, 3011],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: mappedColumns",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: mappedColumns"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [3044, 3057],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [3004, 3011],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: enableRowSelection",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: enableRowSelection"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4547, 4565],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          },
          {
            "log": [
              "info",
              [{ "elements": [], "content": "Either include it or remove the dependency array" }]
            ]
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [4525, 4534],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: enableRowSelection",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: enableRowSelection"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4634, 4652],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [4612, 4621],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: table.getSelectedRowModel",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: table.getSelectedRowModel"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4672, 4697],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [4612, 4621],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook does not specify all of its dependencies: getSelectedRows",
      "message": [
        {
          "elements": [],
          "content": "This hook does not specify all of its dependencies: getSelectedRows"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [
                {
                  "elements": [],
                  "content": "This dependency is not specified in the hook dependency list."
                }
              ]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4656, 4671],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [4612, 4621],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    },
    {
      "category": "lint/correctness/useExhaustiveDependencies",
      "severity": "error",
      "description": "This hook specifies more dependencies than necessary: table.getSelectedRowModel()",
      "message": [
        {
          "elements": [],
          "content": "This hook specifies more dependencies than necessary: table.getSelectedRowModel()"
        }
      ],
      "advices": {
        "advices": [
          {
            "log": [
              "info",
              [{ "elements": [], "content": "This dependency can be removed from the list." }]
            ]
          },
          {
            "frame": {
              "path": null,
              "span": [4713, 4740],
              "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
            }
          }
        ]
      },
      "verboseAdvices": { "advices": [] },
      "location": {
        "path": { "file": "./packages/ui/src/components/OtTable/OtTable.tsx" },
        "span": [4612, 4621],
        "sourceCode": "import {\n  faAngleLeft,\n  faAngleRight,\n  faArrowDown,\n  faArrowUp,\n  faBackwardStep,\n  faForwardStep,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Box, Grid, IconButton, NativeSelect, Skeleton } from \"@mui/material\";\nimport {\n  type ColumnFiltersState,\n  type FilterFn,\n  type Row,\n  flexRender,\n  getCoreRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { type ReactElement, type ReactNode, useEffect, useMemo, useState } from \"react\";\n\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { type RankingInfo, rankItem } from \"@tanstack/match-sorter-utils\";\n\nimport DataDownloader from \"../DataDownloader\";\nimport Tooltip from \"../Tooltip\";\nimport OtTableColumnFilter from \"./OtTableColumnFilter\";\nimport OtTableColumnVisibility from \"./OtTableColumnVisibility\";\n// import { naLabel } from \"@ot/constants\";\nimport OtTableSearch from \"./OtTableSearch\";\nimport {\n  FontAwesomeIconPadded,\n  OtTD,\n  OtTH,\n  OtTR,\n  OtTableCellContainer,\n  OtTableContainer,\n  OtTableHeader,\n  OtTableHeaderText,\n} from \"./otTableLayout\";\nimport type { OtTableProps } from \"./types/tableTypes\";\nimport {\n  getCurrentPagePosition,\n  getDefaultSortObj,\n  getFilterValueFromObject,\n  getLoadingRows,\n  isNestedColumns,\n  mapTableColumnToTanstackColumns,\n} from \"./utils/tableUtils\";\n\ndeclare module \"@tanstack/table-core\" {\n  interface FilterFns {\n    searchFilterFn: FilterFn<unknown>;\n  }\n\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n}\n\nconst searchFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n  const allRowValuesInString = getFilterValueFromObject(row.original);\n  const containsSubstr = new RegExp(value, \"i\").test(allRowValuesInString);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed || containsSubstr;\n};\n\n// missing keys from column data obj\n/************\n *  WIDTH *\n * minWidth\n ************/\n\nfunction OtTable({\n  showGlobalFilter = true,\n  columns = [],\n  rows = [],\n  verticalHeaders = false,\n  order,\n  sortBy,\n  dataDownloader,\n  dataDownloaderColumns,\n  dataDownloaderFileStem,\n  query,\n  variables,\n  showColumnVisibilityControl = true,\n  loading,\n  enableMultipleRowSelection = false,\n  getSelectedRows,\n}: OtTableProps): ReactElement {\n  const [globalFilter, setGlobalFilter] = useState(\"\");\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [rowSelection, setRowSelection] = useState({});\n\n  const mappedColumns = mapTableColumnToTanstackColumns(columns);\n  const loadingRows = getLoadingRows(10);\n  const loadingCells = getLoadingCells(mappedColumns);\n  const enableRowSelection = !!getSelectedRows || enableMultipleRowSelection;\n\n  const tableData = useMemo(() => (loading ? loadingRows : rows), [loading]);\n  const tableColumns = useMemo(() => (loading ? loadingCells : mappedColumns), [loading]);\n\n  function getCellData(cell: Record<string, unknown>): ReactNode {\n    return <>{flexRender(cell.column.columnDef.cell, cell.getContext())}</>;\n  }\n\n  const table = useReactTable({\n    data: tableData,\n    columns: tableColumns,\n    filterFns: {\n      searchFilterFn: searchFilter,\n    },\n    state: {\n      columnFilters,\n      globalFilter,\n      rowSelection,\n    },\n    initialState: {\n      sorting: getDefaultSortObj(sortBy, order),\n    },\n    onColumnFiltersChange: setColumnFilters,\n    onGlobalFilterChange: setGlobalFilter,\n    globalFilterFn: searchFilter,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    enableRowSelection: enableRowSelection,\n    enableMultiRowSelection: enableMultipleRowSelection,\n    onRowSelectionChange: setRowSelection,\n  });\n\n  function onRowSelection(_e: any, row: Row<any>) {\n    enableRowSelection && row.toggleSelected();\n  }\n\n  // TODO:\n  // question: do we want to reset selected item to first if sorting is changed\n  // issue: useEffect is getting called 3 times\n\n  // useEffect(() => {\n  //   const firstRowIdInSortedRow = table.getSortedRowModel().rows[0].id;\n  //   enableRowSelection &&\n  //     setRowSelection({\n  //       [firstRowIdInSortedRow]: true,\n  //     });\n  // }, [table.getSortedRowModel()]);\n\n  useEffect(() => {\n    enableRowSelection && setRowSelection({ 0: true });\n  }, []);\n\n  useEffect(() => {\n    enableRowSelection && getSelectedRows(table.getSelectedRowModel().rows);\n  }, [table.getSelectedRowModel()]);\n\n  return (\n    <div>\n      {/* Global Search */}\n      <Grid\n        container\n        sx={{ display: \"flex\", justifyContent: \"space-between\", gap: { xs: 2, md: 0 } }}\n      >\n        <Grid item sm={12} md={4}>\n          {showGlobalFilter && <OtTableSearch setGlobalSearchTerm={setGlobalFilter} />}\n        </Grid>\n\n        <Grid item sm={12} md={8} sx={{ display: \"flex\", justifyContent: \"end\", gap: 1 }}>\n          {showColumnVisibilityControl && <OtTableColumnVisibility table={table} />}\n          {dataDownloader && (\n            <DataDownloader\n              columns={dataDownloaderColumns || columns}\n              rows={rows}\n              fileStem={dataDownloaderFileStem}\n              query={query}\n              variables={variables}\n            />\n          )}\n        </Grid>\n      </Grid>\n      {/* Table component container */}\n      <Box sx={{ w: 1, overflowX: \"auto\", marginTop: (theme) => theme.spacing(3) }}>\n        {/* Table component */}\n        <OtTableContainer>\n          <thead>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <tr key={headerGroup.id}>\n                {headerGroup.headers.map((header) => {\n                  return (\n                    <OtTH\n                      key={header.id}\n                      colSpan={header.colSpan}\n                      stickyColumn={header.column.columnDef.sticky}\n                    >\n                      {header.isPlaceholder ? null : (\n                        <OtTableHeader\n                          canBeSorted={header.column.getCanSort()}\n                          numeric={header.column.columnDef.numeric}\n                        >\n                          <OtTableHeaderText\n                            verticalHeader={\n                              header.column.columnDef.verticalHeader || verticalHeaders\n                            }\n                            onClick={header.column.getToggleSortingHandler()}\n                          >\n                            <Tooltip\n                              style={\"\"}\n                              title={header.column.columnDef.tooltip}\n                              showHelpIcon={!!header.column.columnDef.tooltip}\n                            >\n                              {flexRender(header.column.columnDef.header, header.getContext())}\n                            </Tooltip>\n                            {!header.column.getIsSorted() && header.column.getCanSort() && (\n                              <FontAwesomeIcon\n                                size=\"sm\"\n                                icon={faArrowUp}\n                                className=\"sortableColumn\"\n                              />\n                            )}\n                            {{\n                              asc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowUp} />,\n                              desc: <FontAwesomeIconPadded size=\"sm\" icon={faArrowDown} />,\n                            }[header.column.getIsSorted() as string] ?? null}\n                          </OtTableHeaderText>\n\n                          {header.column.getCanFilter() ? (\n                            <OtTableColumnFilter column={header.column} />\n                          ) : null}\n                        </OtTableHeader>\n                      )}\n                    </OtTH>\n                  );\n                })}\n              </tr>\n            ))}\n          </thead>\n          <tbody>\n            {table.getRowModel().rows.map((row) => {\n              return (\n                <OtTR\n                  key={row.id}\n                  onClick={(e) => onRowSelection(e, row)}\n                  enableRowSelection={enableRowSelection}\n                  isSelected={row.getIsSelected()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    return (\n                      <OtTD key={cell.id} stickyColumn={cell.column.columnDef.sticky}>\n                        <OtTableCellContainer numeric={cell.column.columnDef.numeric}>\n                          {getCellData(cell)}\n                          {/* {flexRender(cell.column.columnDef.cell, cell.getContext())} */}\n                          {/* TODO: check NA value */}\n                          {/* {Boolean(flexRender(cell.column.columnDef.cell, cell.getContext())) ||\n                            naLabel} */}\n                        </OtTableCellContainer>\n                      </OtTD>\n                    );\n                  })}\n                </OtTR>\n              );\n            })}\n          </tbody>\n        </OtTableContainer>\n      </Box>\n\n      {/*\n       ************************\n       * TABLE FOOTER ACTIONS *\n       ************************\n       */}\n\n      <Box\n        sx={{\n          display: \"flex\",\n          justifyContent: \"end\",\n          alignItems: \"center\",\n          padding: (theme) => `${theme.spacing(2)} 0 `,\n        }}\n      >\n        <div>\n          <label htmlFor=\"paginationSelect\">Rows per page:</label>\n          <NativeSelect\n            id=\"paginationSelect\"\n            disableUnderline\n            disabled={loading}\n            sx={{ pl: (theme) => theme.spacing(2) }}\n            value={table.getState().pagination.pageSize}\n            onChange={(e) => {\n              table.setPageSize(Number(e.target.value));\n            }}\n          >\n            {[10, 25, 100].map((pageSize) => (\n              <option key={pageSize} value={pageSize}>\n                {pageSize}\n              </option>\n            ))}\n          </NativeSelect>\n        </div>\n\n        <Box\n          sx={{\n            display: \"flex\",\n            alignItems: \"center\",\n            gap: (theme) => theme.spacing(3),\n            marginLeft: (theme) => theme.spacing(3),\n          }}\n        >\n          <div>\n            <span>\n              {getCurrentPagePosition(\n                table.getState().pagination.pageIndex,\n                table.getState().pagination.pageSize,\n                table.getGroupedRowModel().rows.length\n              )}\n            </span>\n          </div>\n\n          <div className=\"paginationAction\">\n            <IconButton\n              onClick={() => table.setPageIndex(0)}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"First Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faBackwardStep} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.previousPage()}\n              disabled={!table.getCanPreviousPage()}\n              aria-label=\"Previous Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleLeft} />\n            </IconButton>\n\n            <IconButton\n              onClick={() => table.nextPage()}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"Next Page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faAngleRight} />\n            </IconButton>\n            <IconButton\n              onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n              disabled={!table.getCanNextPage()}\n              aria-label=\"last page\"\n            >\n              <FontAwesomeIcon size=\"2xs\" icon={faForwardStep} />\n            </IconButton>\n          </div>\n        </Box>\n      </Box>\n    </div>\n  );\n}\n\nfunction getLoadingCells(columms: Array<Record<string, unknown>>) {\n  const arr: Record<string, unknown>[] = [];\n  columms.forEach((e) => {\n    if (isNestedColumns(e)) {\n      const headerObj = {\n        header: e.header || e.label,\n        columns: getLoadingCells(e.columns),\n      };\n      arr.push(headerObj);\n    } else arr.push({ ...e, cell: () => <Skeleton sx={{ minWidth: \"50px\" }} variant=\"text\" /> });\n  });\n  return arr;\n}\n\nexport default OtTable;\n"
      },
      "tags": [],
      "source": null
    }
  ],
  "command": "check"
}

info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
